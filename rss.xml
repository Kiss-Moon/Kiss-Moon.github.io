<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Keep Coding</title>
        <subtitle></subtitle>
        <icon>https://www.liangmeng.xyz/images/favicon.ico</icon>
        <link>https://www.liangmeng.xyz</link>
        <author>
          <name>MAC、凉梦</name>
        </author>
        <description>花落微凉梦清幽</description>
        <language>zh-CN</language>
        <pubDate>Fri, 06 May 2022 11:58:00 +0800</pubDate>
        <lastBuildDate>Fri, 06 May 2022 11:58:00 +0800</lastBuildDate>
        <category term="后端" />
        <category term="软件" />
        <category term="Python" />
        <category term="C/C++" />
        <category term="Markdown" />
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95%E8%AF%A6%E8%A7%A3/</guid>
            <title>滑动窗口法详解</title>
            <link>https://www.liangmeng.xyz/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95%E8%AF%A6%E8%A7%A3/</link>
            <category term="力扣题库" scheme="https://www.liangmeng.xyz/categories/LeetCode/" />
            <category term="滑动窗口法" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95/" />
            <category term="滑动窗口法详解" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95%E8%AF%A6%E8%A7%A3/" />
            <pubDate>Fri, 06 May 2022 11:58:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;算法介绍&#34;&gt;&lt;a href=&#34;#算法介绍&#34; class=&#34;headerlink&#34; title=&#34;算法介绍&#34;&gt;&lt;/a&gt;算法介绍&lt;/h1&gt;&lt;p&gt;滑动窗口法是在给定特定窗口大小的数组或字符串上执行要求的操作，该算法可以将部分问题中的嵌套循环转变为单循环，具有较小的时间复杂度O(n^2^)→O(n)。&lt;/p&gt;
&lt;h1 id=&#34;算法框架&#34;&gt;&lt;a href=&#34;#算法框架&#34; class=&#34;headerlink&#34; title=&#34;算法框架&#34;&gt;&lt;/a&gt;算法框架&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;滑动：窗口往某个方向移动的。&lt;/li&gt;
&lt;li&gt;窗口：窗口大小可以是固定的，也可以是变化的，可以不断扩容直到满足一定的条件，也可以不断缩小直到找到一个满足条件的最小窗口。&lt;h1 id=&#34;算法思路&#34;&gt;&lt;a href=&#34;#算法思路&#34; class=&#34;headerlink&#34; title=&#34;算法思路&#34;&gt;&lt;/a&gt;算法思路&lt;/h1&gt;&lt;/li&gt;
&lt;li&gt;定义左右指针，初始化left &amp;#x3D; right &amp;#x3D; 0，把索引闭区间[left, right]称为一个窗口。&lt;/li&gt;
&lt;li&gt;不断增加right指针扩大窗口[left, right]，直到窗口中的部分符合要求（寻找可行解）。&lt;/li&gt;
&lt;li&gt;停止增加right指针，然后不断增加left指针缩小窗口[left, right]，直到窗口中的部分不再符合要求，于此同时需要不断更新结果（优化可行解，寻找最优解）。&lt;/li&gt;
&lt;li&gt;重复第2步和第3步，直到right指针到达字符串或者数组的尽头。&lt;h1 id=&#34;算法模板&#34;&gt;&lt;a href=&#34;#算法模板&#34; class=&#34;headerlink&#34; title=&#34;算法模板&#34;&gt;&lt;/a&gt;算法模板&lt;/h1&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 窗口大小不固定
left, right = 0, 0
res = ??? # 根据实际需要设置
while right &amp;lt; n:
    window.add(right指针对应的元素)
    right += 1
    while window符合要求:
        检查是否需要更新res
        window.remove(left指针对应的元素)
        low += 1

return res	
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 窗口大小固定
right = 0
res = ??? # 根据实际需要设置
while right &amp;lt; n:
    window.add(right指针对应的元素)
    right += 1
    if right &amp;gt;= k: # 窗口达到最大值
        检查是否需要更新res
        window.remove(right-k对应的元素)

return res
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 巧用哈希表记录
left, right = 0, 0
res = ??? # 根据实际需要设置
hashTable = set()/defaultdict(int)
while right &amp;lt; n:
    更新hashTable # window.add(right对应的元素)
    检查是否需要更新res
    while window符合要求:
        更新hashTable # window.remove(left对应的元素)
        检查是否需要更新res
    right += 1

return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;算法应用&#34;&gt;&lt;a href=&#34;#算法应用&#34; class=&#34;headerlink&#34; title=&#34;算法应用&#34;&gt;&lt;/a&gt;算法应用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;窗口大小不固定&lt;br&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1zaXplLXN1YmFycmF5LXN1bS8=&#34;&gt;LeetCode209.长度最小的子数组&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -&amp;gt; int:
        n = len(nums)
        res = n+1
        low, high = 0, 0
        count = 0
        while high &amp;lt; n:
            count += nums[high]
            while count &amp;gt;= target:
                res = min(res, high-low+1)
                count -= nums[low]
                low += 1
            high += 1
        return 0 if res == n+1 else res
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;窗口大小固定&lt;br&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29udGFpbnMtZHVwbGljYXRlLWlpLw==&#34;&gt;LeetCode219.存在重复元素II&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -&amp;gt; bool:
        n = len(nums)
        sonNums = set()
        for high in range(n):
            if high &amp;gt; k:
                sonNums.remove(nums[high-k-1])
            if nums[high] in sonNums:
                return True
            sonNums.add(nums[high])        
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;巧借哈希表记录&lt;br&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVwZWF0ZWQtZG5hLXNlcXVlbmNlcy8=&#34;&gt;LeetCode187.重复的DNA序列&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class Solution:
    def findRepeatedDnaSequences(self, s: str) -&amp;gt; List[str]:
        n = len(s)
        if n &amp;lt;= 10:
            return []
        res = []
        hashTable = defaultdict(int)
        high = 9
        while high &amp;lt; n:
            ason = s[high-9:high+1]
            hashTable[ason] += 1
            if hashTable[ason] == 2:
                res.append(ason)
            high += 1
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/455537e282324427a9ca8800bab115bf.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/ArtificialIntelligence/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/</guid>
            <title>第二章-人工智能的知识表示</title>
            <link>https://www.liangmeng.xyz/ArtificialIntelligence/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/</link>
            <category term="人工智能" scheme="https://www.liangmeng.xyz/categories/ArtificialIntelligence/" />
            <category term="第二章-人工智能的知识表示" scheme="https://www.liangmeng.xyz/categories/ArtificialIntelligence/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/" />
            <category term="人工智能" scheme="https://www.liangmeng.xyz/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" />
            <category term="笔记" scheme="https://www.liangmeng.xyz/tags/%E7%AC%94%E8%AE%B0/" />
            <pubDate>Thu, 05 May 2022 17:53:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;知识表示&#34;&gt;&lt;a href=&#34;#知识表示&#34; class=&#34;headerlink&#34; title=&#34;知识表示&#34;&gt;&lt;/a&gt;知识表示&lt;/h1&gt;&lt;h2 id=&#34;知识与知识表示&#34;&gt;&lt;a href=&#34;#知识与知识表示&#34; class=&#34;headerlink&#34; title=&#34;知识与知识表示&#34;&gt;&lt;/a&gt;知识与知识表示&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;知识是人类智能的基础（符号主义学派）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;智能活动过程主要是一个&lt;strong&gt;获取知识并运用知识的过程&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;人工智能问题的求解也是以知识为基础的，&lt;strong&gt;知识的获取、知识的表示和运用知识进行推理&lt;/strong&gt;是人工智能学科研究的3个主要问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;知识的含义和结构&#34;&gt;&lt;a href=&#34;#知识的含义和结构&#34; class=&#34;headerlink&#34; title=&#34;知识的含义和结构&#34;&gt;&lt;/a&gt;知识的含义和结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;知识是经过裁剪、塑造、解释和转换的信息。&lt;/li&gt;
&lt;li&gt;知识是由特定领域的描述、关系和过程组成的。&lt;/li&gt;
&lt;li&gt;知识&amp;#x3D;事实+信念+启发式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;知识的金字塔结构&#34;&gt;&lt;a href=&#34;#知识的金字塔结构&#34; class=&#34;headerlink&#34; title=&#34;知识的金字塔结构&#34;&gt;&lt;/a&gt;知识的金字塔结构&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/c1f0b5309c264f2182cebc482f6850d0.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据：是记录信息的符号，是信息的载体和表示。&lt;/li&gt;
&lt;li&gt;信息：是对数据的解释，是数据在具体的场合下具体的含义。&lt;/li&gt;
&lt;li&gt;知识：一般把有关信息关联在一起所形成的信息结构称为知识。&lt;/li&gt;
&lt;li&gt;元知识：指使用知识的知识。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/5a66337774844381baf9f02783c97e77.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;知识的种类&#34;&gt;&lt;a href=&#34;#知识的种类&#34; class=&#34;headerlink&#34; title=&#34;知识的种类&#34;&gt;&lt;/a&gt;知识的种类&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/d71f5674cad24abb9b3218deef22bd7a.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;知识的特性&#34;&gt;&lt;a href=&#34;#知识的特性&#34; class=&#34;headerlink&#34; title=&#34;知识的特性&#34;&gt;&lt;/a&gt;知识的特性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;相对正确性：&lt;strong&gt;不同规则下有不同的正确性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;不确定性：&lt;strong&gt;不只有“真”和“假”两种状态&lt;/strong&gt;。引起原因：随机性、模糊性、不完全性和经验性。&lt;/li&gt;
&lt;li&gt;可表示性。&lt;/li&gt;
&lt;li&gt;可利用性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;知识表示-1&#34;&gt;&lt;a href=&#34;#知识表示-1&#34; class=&#34;headerlink&#34; title=&#34;知识表示&#34;&gt;&lt;/a&gt;知识表示&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;知识表示的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;面向计算机的知识描述或表达的形式或方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知识表示的过程就是&lt;strong&gt;把知识编码成某种数据结构的过程&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知识表示的要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示能力：正确、有效地表示。&lt;/li&gt;
&lt;li&gt;可利用性：有利于进行有效的推理。&lt;/li&gt;
&lt;li&gt;可组织性：按某种方式组织成某种结构。&lt;/li&gt;
&lt;li&gt;可维护性：便于增、删、改等操作。&lt;/li&gt;
&lt;li&gt;可实现性：便于在计算机上实现。&lt;/li&gt;
&lt;li&gt;自然性：符合人们的日常习惯。&lt;/li&gt;
&lt;li&gt;可理解性：易读、易懂、易获取等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;知识表示的方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;谓词逻辑表示&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;产生式表示&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语义网络表示&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;框架表示&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一阶谓词逻辑表示法&#34;&gt;&lt;a href=&#34;#一阶谓词逻辑表示法&#34; class=&#34;headerlink&#34; title=&#34;一阶谓词逻辑表示法&#34;&gt;&lt;/a&gt;一阶谓词逻辑表示法&lt;/h2&gt;&lt;p&gt;以&lt;strong&gt;数理逻辑&lt;/strong&gt;为基础，是目前为止能够表达人类思维活动规律的一种&lt;strong&gt;最精确&lt;/strong&gt;的形式语言。&lt;/p&gt;
&lt;h3 id=&#34;基本概念&#34;&gt;&lt;a href=&#34;#基本概念&#34; class=&#34;headerlink&#34; title=&#34;基本概念&#34;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;个体域：个体变元的变化范围称为个体域（论述域），包揽一切事物的集合称为全总个体域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;谓词、函数、量词：&lt;/p&gt;
&lt;p&gt;n元谓词：P(x&lt;del&gt;1&lt;/del&gt;, x&lt;del&gt;2&lt;/del&gt;, ……, x&lt;del&gt;n&lt;/del&gt;)，&lt;strong&gt;大写字母&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;n元函数：f(x&lt;del&gt;1&lt;/del&gt;, x&lt;del&gt;2&lt;/del&gt;, ……, x&lt;del&gt;n&lt;/del&gt;)，&lt;strong&gt;小写字母&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;全称量词：∀x，所有。&lt;/p&gt;
&lt;p&gt;存在量词：∃x，存在。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常用的谓词联接符号：&lt;strong&gt;按优先级从高到低排列&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;否定：﹁，非。&lt;/li&gt;
&lt;li&gt;合取：∧，与。&lt;/li&gt;
&lt;li&gt;析取：∨，或。&lt;/li&gt;
&lt;li&gt;蕴含：→，如果…那么。&lt;/li&gt;
&lt;li&gt;等价：↔，当且仅当。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;辖域：紧接于量词之后被量词作用的谓词公式称为该量词的辖域，可用括号明示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指导变元、约束变元、自由变元：&lt;/p&gt;
&lt;p&gt;指导变元：量词后面的变元称为量词的指导变元。&lt;/p&gt;
&lt;p&gt;约束变元：在一个量词的辖域中的与该量词的指导变元相同的变元称为约束变元。&lt;/p&gt;
&lt;p&gt;自由变元：其它的变元称为自由变元。&lt;br&gt;$$&lt;br&gt;∀x(P(x, y) → Q(x))&lt;br&gt;$$&lt;br&gt;其中，第一个x为指导变元，第二个x和第三个x为约束变元，y为自由变元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;改名规则：使一个谓词公式中的&lt;strong&gt;每一个变元仅以一种形式出现&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;换名规则：将某量词辖域中出现的某个&lt;strong&gt;约束变元&lt;/strong&gt;以及对应的&lt;strong&gt;指导变元&lt;/strong&gt;更改为本辖域中没有出现过的个体变元，等价性不变。&lt;/li&gt;
&lt;li&gt;代替规则：将某量词辖域中出现的某个&lt;strong&gt;自由变元&lt;/strong&gt;的所有出现用本辖域中未曾出现过的某个个体变元符号代替，等价性不变。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;谓词公式表示知识的步骤&#34;&gt;&lt;a href=&#34;#谓词公式表示知识的步骤&#34; class=&#34;headerlink&#34; title=&#34;谓词公式表示知识的步骤&#34;&gt;&lt;/a&gt;谓词公式表示知识的步骤&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定义谓词及个体，确定每个谓词及个体的确切含义。&lt;/li&gt;
&lt;li&gt;根据所要表达的事物或概念，为每个谓词中的变元赋以特定的值。&lt;/li&gt;
&lt;li&gt;根据所要表达的知识的语义，用适当的联接符号将各个谓词联接起来，形成谓词公式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;经典例子一：机器人移盒子问题&#34;&gt;&lt;a href=&#34;#经典例子一：机器人移盒子问题&#34; class=&#34;headerlink&#34; title=&#34;经典例子一：机器人移盒子问题&#34;&gt;&lt;/a&gt;经典例子一：机器人移盒子问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;问题描述：设在一房间里，c处有一个机器人，a和b处各有一张桌子，分别称为a桌和b桌，a桌上有一个盒子，如图所示。要求机器人从c处出发把盒子从a桌上拿到b桌上，再回到c处。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;img data-src=&#34;https://img-blog.csdnimg.cn/b8570bdbad244208af9c5fdfb47a0235.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;问题求解：过程如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;描述状态的谓词&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;TABLE(x)：x是桌子。&lt;/p&gt;
&lt;p&gt;EMPTY(y)：y手中是空的。&lt;/p&gt;
&lt;p&gt;AT(y, z)：y在z处。&lt;/p&gt;
&lt;p&gt;HOLDS(y, w)：y拿着w。&lt;/p&gt;
&lt;p&gt;ON(w, x)：w在x的桌面上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;变元的个体域&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;x的个体域是{a, b}&lt;/p&gt;
&lt;p&gt;y的个体域是{robot}&lt;/p&gt;
&lt;p&gt;z的个体域是{a, b, c}&lt;/p&gt;
&lt;p&gt;w的个体域是{box}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;问题的初始状态&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;AT(robot, c)&lt;/p&gt;
&lt;p&gt;EMPTY(robot)&lt;/p&gt;
&lt;p&gt;ON(box, a)&lt;/p&gt;
&lt;p&gt;TABLE(a)&lt;/p&gt;
&lt;p&gt;TABLE(b)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;问题的目标状态&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;AT(robot, c)&lt;/p&gt;
&lt;p&gt;EMPTY(robot)&lt;/p&gt;
&lt;p&gt;ON(box, b)&lt;/p&gt;
&lt;p&gt;TABLE(a)&lt;/p&gt;
&lt;p&gt;TABLE(b)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;描述操作的谓词&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;条件部分：用来说明执行该动作必须具备的先决条件，用谓词公式来表示。&lt;/p&gt;
&lt;p&gt;动作部分：给出了该操作对问题状态的改变情况，通过在执行该操作前的问题状态中删除和增加相应的谓词来实现。&lt;/p&gt;
&lt;p&gt;Goto(x, y)：从x处走到y处。&lt;/p&gt;
&lt;p&gt;Pickup(x)：在x处拿起盒子。&lt;/p&gt;
&lt;p&gt;Setdown(x)：在x处放下盒子。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;各操作的条件和动作&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Goto(x, y)&lt;/p&gt;
&lt;p&gt;条件：AT(robot, x)&lt;/p&gt;
&lt;p&gt;动作：删除AT(robot, x)，添加AT(robot, y)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pickup(x):&lt;/p&gt;
&lt;p&gt;条件：AT(robot, x)，TABLE(x)，ON(box, x)，EMPTY(robot)&lt;/p&gt;
&lt;p&gt;动作：删除EMPTY(robot)，ON(box, x)，添加HOLDS(robot, box)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Setdown(x):&lt;/p&gt;
&lt;p&gt;条件：AT(robot, x)，TABLE(x)，HOLDS(robot, box)&lt;/p&gt;
&lt;p&gt;动作：删除HOLDS(robot, box)，添加EMPTY(robot)，ON(box, x)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;各操作的执行方法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;机器人在执行一个操作前，都要检查该动作的先决条件是否可以满足，如果满足，就执行相应的操作，否则再检查下一个操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;机器人的完整行动过程&lt;/strong&gt;：           &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;状态1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;状态2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;状态3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;AT(robot, c)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;AT(robot, a)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;AT(robot, a)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;EMPTY(robot)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Goto(c, a)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;EMPTY(robot)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Pickup(a)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;HOLDS(robot, box)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;ON(box, a)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ON(box, a)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TABLE(a)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;TABLE(a)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TABLE(a)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TABLE(b)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;TABLE(b)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TABLE(b)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;状态4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;状态5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;AT(robot, b)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;AT(robot, b)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Goto(a, b)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;HOLDS(robot, box)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Setdown(b)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;EMPTY(robot)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Goto(b, c)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TABLE(a)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ON(box, b)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TABLE(b)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TABLE(a)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TABLE(b)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;状态6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;AT(robot, c)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;EMPTY(robot)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;ON(box, b)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;TABLE(a)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;TABLE(b)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;经典例子二：猴子摘香蕉问题&#34;&gt;&lt;a href=&#34;#经典例子二：猴子摘香蕉问题&#34; class=&#34;headerlink&#34; title=&#34;经典例子二：猴子摘香蕉问题&#34;&gt;&lt;/a&gt;经典例子二：猴子摘香蕉问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;问题描述：设房间里有一只猴子，位于a处。在c处上方的天花板有一串香蕉，猴子想吃，但摘不到。房间的b处还有一个箱子，如果猴子站到箱子上，就可以摸着天花板。请用谓词逻辑知识表示描述上述问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题求解：过程如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;描述状态的谓词：&lt;/p&gt;
&lt;p&gt;AT(x, y)：表示x在y处。&lt;/p&gt;
&lt;p&gt;ONBOX：表示猴子在箱子上面。&lt;/p&gt;
&lt;p&gt;HB：猴子摘到香蕉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;变元的个体域：&lt;/p&gt;
&lt;p&gt;x的个体域是{monkey, box, banana}&lt;/p&gt;
&lt;p&gt;y的个体域是{a, b, c}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题的初始状态：&lt;/p&gt;
&lt;p&gt;AT(monkey, a)&lt;/p&gt;
&lt;p&gt;AT(box, b)&lt;/p&gt;
&lt;p&gt;﹁ONBOX&lt;/p&gt;
&lt;p&gt;﹁HB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题的目标状态:&lt;/p&gt;
&lt;p&gt;AT(monkey, c)&lt;/p&gt;
&lt;p&gt;AT(box, c)&lt;/p&gt;
&lt;p&gt;ONBOX&lt;/p&gt;
&lt;p&gt;HB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;描述操作的谓词:&lt;/p&gt;
&lt;p&gt;GOTO(u, v)：表示猴子从u处走到v处。&lt;/p&gt;
&lt;p&gt;PUSHBOX(v, w)：表示猴子推着箱子从v处移到w处。&lt;/p&gt;
&lt;p&gt;CLIMBBOX：表示猴子爬上箱子。&lt;/p&gt;
&lt;p&gt;GRASP：表示猴子摘取香蕉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;各操作的条件和动作：&lt;/p&gt;
&lt;p&gt;GOTO(u, v)&lt;/p&gt;
&lt;p&gt;条件：﹁ONBOX，AT(monkey, u)&lt;/p&gt;
&lt;p&gt;动作：删除AT(monkey, u)，添加AT(monkey, v)&lt;/p&gt;
&lt;p&gt;PUSHBOX(v, w)&lt;/p&gt;
&lt;p&gt;条件：﹁ONBOX，AT(monkey, v)，AT(box, v)&lt;/p&gt;
&lt;p&gt;动作：AT(monkey, v)，AT(box, w)&lt;/p&gt;
&lt;p&gt;CLIMBBOX：&lt;/p&gt;
&lt;p&gt;条件：﹁ONBOX，AT(monkey, w)，AT(box, w)&lt;/p&gt;
&lt;p&gt;动作：删除﹁ONBOX，添加ONBOX&lt;/p&gt;
&lt;p&gt;GRASP：&lt;/p&gt;
&lt;p&gt;条件：ONBOX，AT(box, c)，﹁HB&lt;/p&gt;
&lt;p&gt;动作：删除﹁HB，添加HB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;猴子的完整行动过程&lt;/p&gt;
&lt;p&gt;与前述机器人移盒子问题类似，略。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;谓词逻辑表达法的特点&#34;&gt;&lt;a href=&#34;#谓词逻辑表达法的特点&#34; class=&#34;headerlink&#34; title=&#34;谓词逻辑表达法的特点&#34;&gt;&lt;/a&gt;谓词逻辑表达法的特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：严密性、自然性、通用性、易于实现&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：知识表示能力差、知识库管理困难、组合爆炸、效率低&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;产生式表示法&#34;&gt;&lt;a href=&#34;#产生式表示法&#34; class=&#34;headerlink&#34; title=&#34;产生式表示法&#34;&gt;&lt;/a&gt;产生式表示法&lt;/h2&gt;&lt;h3 id=&#34;知识的产生式表示方法&#34;&gt;&lt;a href=&#34;#知识的产生式表示方法&#34; class=&#34;headerlink&#34; title=&#34;知识的产生式表示方法&#34;&gt;&lt;/a&gt;知识的产生式表示方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;事实的概念：事实是断言一个语言变量的值或断言多个语言变量之间关系的陈述句。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事实的表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;确定性知识：（对象，属性，值）或（关系，对象1，对象2）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非确定性知识：（对象，属性，值，可信度因子）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;规则的表示：&lt;strong&gt;P→Q 或者 IF P THEN Q&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/8f53bff7ac434d8b9d7684915c35d44b.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;产生式系统的基本结构&#34;&gt;&lt;a href=&#34;#产生式系统的基本结构&#34; class=&#34;headerlink&#34; title=&#34;产生式系统的基本结构&#34;&gt;&lt;/a&gt;产生式系统的基本结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;综合数据库DB&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;存放推理过程的各种当前信息。&lt;/li&gt;
&lt;li&gt;作为推理过程选择可用规则的依据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则库RB，也称为知识库KB&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;存放推理所需要的所有规则（知识集），是推理的根本。&lt;/li&gt;
&lt;li&gt;要求知识的完整性、一致性、准确性、灵活性和可组织性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制系统，也称为推理机&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;控制整个产生式系统的运行，决定问题求解过程的推理线路。&lt;/li&gt;
&lt;li&gt;主要任务：选择匹配、冲突消解、执行操作、终止推理、路径解释。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;产生式系统的运行过程&#34;&gt;&lt;a href=&#34;#产生式系统的运行过程&#34; class=&#34;headerlink&#34; title=&#34;产生式系统的运行过程&#34;&gt;&lt;/a&gt;产生式系统的运行过程&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/e729310fe47441c39904984afb12e36a.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;经典例子一：猴子摘香蕉问题&#34;&gt;&lt;a href=&#34;#经典例子一：猴子摘香蕉问题&#34; class=&#34;headerlink&#34; title=&#34;经典例子一：猴子摘香蕉问题&#34;&gt;&lt;/a&gt;经典例子一：猴子摘香蕉问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;综合数据库：（M, B, Box, On, H）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;M：猴子的位置&lt;/p&gt;
&lt;p&gt;B：香蕉的位置&lt;/p&gt;
&lt;p&gt;Box：箱子的位置&lt;/p&gt;
&lt;p&gt;On&amp;#x3D;0：猴子在地板上&lt;/p&gt;
&lt;p&gt;On&amp;#x3D;1：猴子在箱子上&lt;/p&gt;
&lt;p&gt;H&amp;#x3D;0：猴子没有抓到香蕉&lt;/p&gt;
&lt;p&gt;H&amp;#x3D;1：猴子抓到了香蕉&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始状态：（a, c, b, 0, 0）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结束状态：（c, c, c, 1, 1）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;规则集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;r1: IF(x, y, z, 0, 0)THEN(w, y, z, 0, 0)（猴子移动）&lt;/p&gt;
&lt;p&gt;r2: IF(x, y, x, 0, 0)THEN(z, y, z, 0, 0)（猴子推箱子）&lt;/p&gt;
&lt;p&gt;r3: IF(x, y, x, 0, 0)THEN(x, y, x, 1, 0)（猴子爬箱子）&lt;/p&gt;
&lt;p&gt;r4: IF(x, y, x, 1, 0)THEN(x, y, x, 0, 0)（猴子下箱子）&lt;/p&gt;
&lt;p&gt;r5: IF(x, x, x, 1, 0)THEN(x, x, x, 1, 1)（猴子抓香蕉）&lt;/p&gt;
&lt;p&gt;其中，x, y, z, w为变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;行动过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;r1: IF(a, c, b, 0, 0)THEN(b, c, b, 0, 0)&lt;/p&gt;
&lt;p&gt;r2: IF(b, c, b, 0, 0)THEN(c, c, c, 0, 0)&lt;/p&gt;
&lt;p&gt;&lt;del&gt;r3: IF(b, c, b, 0, 0)THEN(b, c, b, 1, 0)&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;r3: IF(c, c, c, 0, 0)THEN(c, c, c, 1, 0)&lt;/p&gt;
&lt;p&gt;&lt;del&gt;r4: IF(b, c, b, 1, 0)THEN(b, c, b, 0, 0)&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;r5: IF(c, c, c, 1, 0)THEN(c, c, c, 1, 1)&lt;/p&gt;
&lt;p&gt;在已知事实下，r1→r2→r3→r5可得到香蕉。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;经典问题二：传道士与野人问题&#34;&gt;&lt;a href=&#34;#经典问题二：传道士与野人问题&#34; class=&#34;headerlink&#34; title=&#34;经典问题二：传道士与野人问题&#34;&gt;&lt;/a&gt;经典问题二：传道士与野人问题&lt;/h3&gt;&lt;p&gt;N个传教士，N个野人，一条船，可同时乘坐k个人；要求在任何时刻，在河的两岸，传教士和野人同时存在时，传教士的人数不能少于野人的人数。问：如何过河（以N&amp;#x3D;3，k&amp;#x3D;2为例）？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;综合数据库：（m，c，b），其中0≤m≤3，0≤c≤3，b∈{0，1}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始状态：（3，3，1）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;L&lt;/th&gt;
&lt;th&gt;R&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目标状态：（0，0，0）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;L&lt;/th&gt;
&lt;th&gt;R&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;规则集&lt;/p&gt;
&lt;p&gt;r1: IF(m, c, 1)THEN(m-1, c, 0)&lt;/p&gt;
&lt;p&gt;r2: IF(m, c, 1)THEN(m, c-1, 0)&lt;/p&gt;
&lt;p&gt;r3: IF(m, c, 1)THEN(m-1, c-1, 0)&lt;/p&gt;
&lt;p&gt;r4: IF(m, c, 1)THEN(m-2, c, 0)&lt;/p&gt;
&lt;p&gt;r5: IF(m, c, 1)THEN(m, c-2, 0)&lt;/p&gt;
&lt;p&gt;r6: IF(m, c, 0)THEN(m+1, c, 1)&lt;/p&gt;
&lt;p&gt;r7: IF(m, c, 0)THEN(m, c+1, 1)&lt;/p&gt;
&lt;p&gt;r8: IF(m, c, 0)THEN(m+1, c+1, 1)&lt;/p&gt;
&lt;p&gt;r9: IF(m, c, 0)THEN(m+2, c, 1)&lt;/p&gt;
&lt;p&gt;r10: IF(m, c, 0)THEN(m, c+2, 1)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行动过程&lt;/p&gt;
&lt;p&gt;r5: IF(3, 3, 1)THEN(3, 1, 0)（船运2个c到右岸）&lt;/p&gt;
&lt;p&gt;r7: IF(3, 1, 0)THEN(3, 2, 1)（船运1个c到左岸）&lt;/p&gt;
&lt;p&gt;r5: IF(3, 2, 1)THEN(3, 0, 0)（船运2个c到右岸）&lt;/p&gt;
&lt;p&gt;r7: IF(3, 0, 0)THEN(3, 1, 1)（船运1个c到左岸）&lt;/p&gt;
&lt;p&gt;r4: IF(3, 1, 1)THEN(1, 1, 0)（船运2个m到右岸）&lt;/p&gt;
&lt;p&gt;r8: IF(1, 1, 0)THEN(2, 2, 1)（船运1个m和一个c到左岸）&lt;/p&gt;
&lt;p&gt;r4: IF(2, 2, 1)THEN(0, 2, 0)（船运2个m到右岸）&lt;/p&gt;
&lt;p&gt;r7: IF(0, 2, 0)THEN(0, 3, 1)（船运1个c到左岸）&lt;/p&gt;
&lt;p&gt;r5: IF(0, 3, 1)THEN(0, 1, 0)（船运2个c到右岸）&lt;/p&gt;
&lt;p&gt;r7: IF(0, 1, 0)THEN(0, 2, 1)（船运1个c到左岸）&lt;/p&gt;
&lt;p&gt;r5: IF(0, 2, 1)THEN(0, 0, 0)（船运2个c到右岸）&lt;/p&gt;
&lt;p&gt;在已知事实下，r5→r7→r5→r7→r4→r8→r4→r7→r5→r7→r5可顺利过河。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;产生式系统的特点&#34;&gt;&lt;a href=&#34;#产生式系统的特点&#34; class=&#34;headerlink&#34; title=&#34;产生式系统的特点&#34;&gt;&lt;/a&gt;产生式系统的特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：自然性、模块性、有效性。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：效率较低、不便于表示结构性知识。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;语义网络表示法&#34;&gt;&lt;a href=&#34;#语义网络表示法&#34; class=&#34;headerlink&#34; title=&#34;语义网络表示法&#34;&gt;&lt;/a&gt;语义网络表示法&lt;/h2&gt;&lt;h3 id=&#34;语义网络的基本表示&#34;&gt;&lt;a href=&#34;#语义网络的基本表示&#34; class=&#34;headerlink&#34; title=&#34;语义网络的基本表示&#34;&gt;&lt;/a&gt;语义网络的基本表示&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;节点：概念、事物、对象、行为、状态等。&lt;/li&gt;
&lt;li&gt;有向弧：节点间的联系或关系。&lt;/li&gt;
&lt;li&gt;语义基元：（节点1，弧，节点2）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基本网元&lt;/strong&gt;：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/1fa172fd05a4460999eadf24a48564da.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;h3 id=&#34;基本语义关系&#34;&gt;&lt;a href=&#34;#基本语义关系&#34; class=&#34;headerlink&#34; title=&#34;基本语义关系&#34;&gt;&lt;/a&gt;基本语义关系&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实例关系&lt;/strong&gt;：ISA（is-a，具体与抽象，“是一个”）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分类关系&lt;/strong&gt;：AKO（a-kind-of，子类与超类，“是一种”）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成员关系&lt;/strong&gt;：A-Member-of（个体与集体，“是一员”）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;以上三种关系都具有属性的继承性，处于具体层的节点可以继承所有抽象层节点的所有属性。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;聚类关系&lt;/strong&gt;：Part-of（部分与整体，“是一部分”）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;聚类关系一般不具有属性的继承性&lt;/strong&gt;。如手不一定具有人的各种属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;属性关系&lt;/strong&gt;：Have、Can&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间关系&lt;/strong&gt;：After、Before&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;位置关系&lt;/strong&gt;：Located-on、Located-under、Located-at、Located-inside、Located-outside&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;相近关系&lt;/strong&gt;：Similar-to、Near-to&lt;h3 id=&#34;事物和概念的表示&#34;&gt;&lt;a href=&#34;#事物和概念的表示&#34; class=&#34;headerlink&#34; title=&#34;事物和概念的表示&#34;&gt;&lt;/a&gt;事物和概念的表示&lt;/h3&gt;一个语义基元&amp;#x2F;基本网元可以表示一个一元关系或一个二元关系，当要表示多元关系时，需要把它转化为一个或多个二元关系的组合。&lt;br&gt;例：用语义网络表示&lt;br&gt;①李新的笔记本的牌子是“联想”、颜色黑灰。&lt;br&gt;②王红的笔记本的牌子是“方正”、颜色粉红。&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/2172b81b17f2449bbeb6f94980ec2c83.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;h3 id=&#34;情况和动作的表示&#34;&gt;&lt;a href=&#34;#情况和动作的表示&#34; class=&#34;headerlink&#34; title=&#34;情况和动作的表示&#34;&gt;&lt;/a&gt;情况和动作的表示&lt;/h3&gt;例：用语义网络表示“小燕子这只燕子从春天到秋天占有一个巢”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如果不增加情况节点，会导致语义无法表示或不完整。&lt;/strong&gt;&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/29b49cc18e0c45f2a76f73a1d9399d52.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;增加情况节点后的网络如下。&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/cc560fe3719b4da0802cae1c2a262769.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;基于语义网络的推理&#34;&gt;&lt;a href=&#34;#基于语义网络的推理&#34; class=&#34;headerlink&#34; title=&#34;基于语义网络的推理&#34;&gt;&lt;/a&gt;基于语义网络的推理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;继承&lt;/strong&gt;：把对事物的描述从抽象节点传递到实例节点。通过继承可以得到所需节点的一些属性值，它通常是&lt;strong&gt;沿着ISA、AKO等继承弧&lt;/strong&gt;进行的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;匹配&lt;/strong&gt;：指在知识库的语义网络中&lt;strong&gt;寻找与待求解问题相符&lt;/strong&gt;的语义网络模式。&lt;h3 id=&#34;语义网络表示法的特点&#34;&gt;&lt;a href=&#34;#语义网络表示法的特点&#34; class=&#34;headerlink&#34; title=&#34;语义网络表示法的特点&#34;&gt;&lt;/a&gt;语义网络表示法的特点&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点：结构性、联想性、自索引性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：非严格性、复杂性&lt;/strong&gt;。&lt;h2 id=&#34;框架表示法&#34;&gt;&lt;a href=&#34;#框架表示法&#34; class=&#34;headerlink&#34; title=&#34;框架表示法&#34;&gt;&lt;/a&gt;框架表示法&lt;/h2&gt;&lt;h3 id=&#34;基本概念-1&#34;&gt;&lt;a href=&#34;#基本概念-1&#34; class=&#34;headerlink&#34; title=&#34;基本概念&#34;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;框架：一种通用数据结构，知识的基本单元。&lt;/li&gt;
&lt;li&gt;实例框架：框架的一个具体实例。&lt;/li&gt;
&lt;li&gt;框架系统：把一组有关的框架连结起来。&lt;/li&gt;
&lt;li&gt;框架系统推理：由框架之间的协调来完成。&lt;h3 id=&#34;基本组成&#34;&gt;&lt;a href=&#34;#基本组成&#34; class=&#34;headerlink&#34; title=&#34;基本组成&#34;&gt;&lt;/a&gt;基本组成&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;框架名&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;槽名（对象的一种属性）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;侧面名（属性的一个方面）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;值&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一个框架由若干个槽组成，一个槽由若干个侧面组成&lt;/strong&gt;&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/573dd6a8e386465fbf774e6ac68a7dd2.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;说明信息&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单位(Unit)：槽值或侧面值的书写格式。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;范围(Area)：槽值或侧面值的指定范围。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;默认值(Default)：缺省时的默认值。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;框架(&amp;lt;Frame&amp;gt;)：以另一个框架作为槽值或侧面值。&lt;/strong&gt;&lt;h3 id=&#34;框架系统&#34;&gt;&lt;a href=&#34;#框架系统&#34; class=&#34;headerlink&#34; title=&#34;框架系统&#34;&gt;&lt;/a&gt;框架系统&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;横向联系&lt;/strong&gt;&lt;br&gt;以另一个框架作为槽值或侧面值时框架之间的联系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;纵向联系&lt;/strong&gt;&lt;br&gt;以预定义槽名AKO和ISA来继承时框架之间的联系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特性继承&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;通过ISA、AKO链来实现。&lt;/li&gt;
&lt;li&gt;当需要查询某一事物的某个属性，且描述该事物的框架未提供其属性值时，系统就沿着ISA和AKO链追溯到具有相同槽的类或超类框架。&lt;/li&gt;
&lt;li&gt;如果该槽提供有Default值，就继承该默认值作为查询结果返回。&lt;/li&gt;
&lt;li&gt;如果该槽提供有If-Needed侧面供继承，则执行If-Needed操作，去产生一个值作为查询结果。&lt;/li&gt;
&lt;li&gt;如果对某个事物的某一属性进行了赋值或修改操作，则系统会自动沿着ISA和AKO链追溯到具有相应的类或超类框架，去执行If-Added操作来进行后继处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;If-Needed和If-Added的区别&lt;/strong&gt;：前者是在系统试图查询某个事物框架中未记载的属性值时激活，并根据查询需求，被动地即时产生所需要的属性值；后者是在系统对某个框架的属性作赋值或修改工作后激活，通过进行配套的后继处理来消除可能存在的不一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实例&lt;br&gt;一个直接描述硕士生有关情况的框架&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/1faa0a8a2af14f66b9731949072d6b2b.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;通过继承关系描述硕士生有关情况的框架。&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/f9a81424268f46ac9f0d797a282a5430.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/0f40ab93a7374bacbbeb4c17091bdd9f.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;问题求解过程&#34;&gt;&lt;a href=&#34;#问题求解过程&#34; class=&#34;headerlink&#34; title=&#34;问题求解过程&#34;&gt;&lt;/a&gt;问题求解过程&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;匹配&lt;/strong&gt;：对相应槽的槽名和槽值逐个进行比较。&lt;br&gt;&lt;strong&gt;填槽&lt;/strong&gt;：利用继承关系来实现。&lt;/p&gt;
&lt;h3 id=&#34;框架表示法的特点&#34;&gt;&lt;a href=&#34;#框架表示法的特点&#34; class=&#34;headerlink&#34; title=&#34;框架表示法的特点&#34;&gt;&lt;/a&gt;框架表示法的特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：结构性、深层性、继承性、自然性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：缺乏框架的形式理论、缺乏过程性知识表示、清晰性难以保证。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/699baef601044c6ebf39e18b5208a5e1.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/9-%E5%9B%9E%E6%96%87%E6%95%B0/</guid>
            <title>9-回文数</title>
            <link>https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/9-%E5%9B%9E%E6%96%87%E6%95%B0/</link>
            <category term="力扣题库" scheme="https://www.liangmeng.xyz/categories/LeetCode/" />
            <category term="难度简单" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/" />
            <category term="9-回文数" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/9-%E5%9B%9E%E6%96%87%E6%95%B0/" />
            <pubDate>Wed, 27 Apr 2022 17:23:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;题目描述&#34;&gt;&lt;a href=&#34;#题目描述&#34; class=&#34;headerlink&#34; title=&#34;题目描述&#34;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。&lt;br&gt;回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;br&gt;例如，121 是回文，而 123 不是。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：x &amp;#x3D; 121&lt;br&gt;输出：true&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;输入：x &amp;#x3D; -121&lt;br&gt;输出：false&lt;br&gt;解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。&lt;/p&gt;
&lt;p&gt;示例 3：&lt;br&gt;输入：x &amp;#x3D; 10&lt;br&gt;输出：false&lt;br&gt;解释：从右向左读, 为 01 。因此它不是一个回文数。&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;-2^31^ &amp;lt;&amp;#x3D; x &amp;lt;&amp;#x3D; 2^31^ - 1&lt;/p&gt;
&lt;h1 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h1&gt;&lt;p&gt;回文数常见的解法就是从中间往两边比较，只要有一位不对称，那么这个数就不是回文数。&lt;br&gt;所以，需要判断数字的位数是奇数还是偶数。如果是奇数位，需要去掉中间的那个数，使其变成偶数位。&lt;br&gt;接下来，我们考虑一下特殊情况：&lt;br&gt;1.负数不可能是回文数，因为负号不可能对称。&lt;br&gt;2.长度大于1且个位为0的数不可能是回文数，因为末位0不可能对称。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class Solution:
    def isPalindrome(self, x: int) -&amp;gt; bool:
        if x &amp;lt; 0 or (x%10 == 0 and x != 0):
            return False
        x = str(x)
        n = len(x)
        if n == 1:
            return True
        elif n%2 == 1:
            mid = (n-1)//2
            # 反转一半数字
            rexr = x[:mid:-1]
            if rexr == x[:mid]:
                return True
            return False
        else:
            midr = n//2
            # 反转一半数字
            rexr = x[:midr-1:-1]
            if rexr == x[:midr]:
                return True 
            return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;官方题解&#34;&gt;&lt;a href=&#34;#官方题解&#34; class=&#34;headerlink&#34; title=&#34;官方题解&#34;&gt;&lt;/a&gt;官方题解&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;class Solution &amp;#123;
public:
    bool isPalindrome(int x) &amp;#123;
        // 特殊情况：
        // 如上所述，当 x &amp;lt; 0 时，x 不是回文数。
        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，
        // 则其第一位数字也应该是 0
        // 只有 0 满足这一属性
        if (x &amp;lt; 0 || (x % 10 == 0 &amp;amp;&amp;amp; x != 0)) &amp;#123;
            return false;
        &amp;#125;

        int revertedNumber = 0;
        while (x &amp;gt; revertedNumber) &amp;#123;
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        &amp;#125;

        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
        return x == revertedNumber || x == revertedNumber / 10;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/7a41645c08594f39a5e09dde3a983d25.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E4%B8%AD%E7%AD%89/6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</guid>
            <title>6-Z字形变换</title>
            <link>https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E4%B8%AD%E7%AD%89/6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</link>
            <category term="力扣题库" scheme="https://www.liangmeng.xyz/categories/LeetCode/" />
            <category term="难度中等" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E9%9A%BE%E5%BA%A6%E4%B8%AD%E7%AD%89/" />
            <category term="Z字形变换" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E9%9A%BE%E5%BA%A6%E4%B8%AD%E7%AD%89/Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/" />
            <pubDate>Wed, 27 Apr 2022 13:55:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;题目描述&#34;&gt;&lt;a href=&#34;#题目描述&#34; class=&#34;headerlink&#34; title=&#34;题目描述&#34;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
&lt;p&gt;比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。&lt;br&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：s &amp;#x3D; “PAYPALISHIRING”, numRows &amp;#x3D; 3&lt;br&gt;输出：”PAHNAPLSIIGYIR”&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;输入：s &amp;#x3D; “PAYPALISHIRING”, numRows &amp;#x3D; 4&lt;br&gt;输出：”PINALSIGYAHRPI”&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;p&gt;输入：s &amp;#x3D; “A”, numRows &amp;#x3D; 1&lt;br&gt;输出：”A”&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;1 &amp;lt;&amp;#x3D; s.length &amp;lt;&amp;#x3D; 1000&lt;br&gt;s 由英文字母（小写和大写）、’,’ 和 ‘.’ 组成&lt;br&gt;1 &amp;lt;&amp;#x3D; numRows &amp;lt;&amp;#x3D; 1000&lt;/p&gt;
&lt;h1 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h1&gt;&lt;h2 id=&#34;思路一：过程模拟&#34;&gt;&lt;a href=&#34;#思路一：过程模拟&#34; class=&#34;headerlink&#34; title=&#34;思路一：过程模拟&#34;&gt;&lt;/a&gt;思路一：过程模拟&lt;/h2&gt;&lt;p&gt;定义numRows个数组，用于存放每一行的所有字符，然后直接模拟排列过程，最后先按行连接再按列连接即可，空间复杂度较高。&lt;br&gt;易错点在于，当numRows &amp;#x3D;&amp;#x3D; 1或numRows &amp;gt;&amp;#x3D; s.length时，需要特殊处理，直接返回s。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class Solution:
    def convert(self, s: str, numRows: int) -&amp;gt; str:
        if numRows == 1 or numRows &amp;gt;= len(s):
            return s
        all = [[] for i in range(numRows)]
        row, dire = 0, 1
        for i in range(len(s)):
            all[row].append(s[i])
            if row == numRows-1:
                dire = -1
            elif row == 0:
                dire = 1
            row += dire
            
        res = &amp;quot;&amp;quot;
        for i in range(numRows):
            res += &amp;quot;&amp;quot;.join(all[i])
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;思路二：寻找排列规律&#34;&gt;&lt;a href=&#34;#思路二：寻找排列规律&#34; class=&#34;headerlink&#34; title=&#34;思路二：寻找排列规律&#34;&gt;&lt;/a&gt;思路二：寻找排列规律&lt;/h2&gt;&lt;p&gt;同一行的数字存在一定的规律，如果找到这个规律，那么只需要一次遍历就能够完成题解。&lt;br&gt;先来看看示例1，数字代表字符串的下标。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;第一行：0，4，8，12（依次增4）&lt;br&gt;第二行：1，3，5，7，9，11，13（先增2再增2，2+2&amp;#x3D;4）&lt;br&gt;第三行：2，6，10（依次增4）&lt;/p&gt;
&lt;p&gt;再来看看示例2，同上。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;第一行：0，6，12（依次增6）&lt;br&gt;第二行：1，5，7，11，13（先增4再增2，4+2&amp;#x3D;6）&lt;br&gt;第三行：2，4，8，10（先增2，再增4，2+4&amp;#x3D;6）&lt;br&gt;第四行：3，9（依次增6）&lt;/p&gt;
&lt;p&gt;可以推得，排列的周期为T &amp;#x3D; 2*numRows-2。&lt;br&gt;对于第零行，每个周期内只产生一个字符，且字符的坐标x满足x%T&amp;#x3D;0。&lt;br&gt;对于第 i 行（0&amp;lt;i&amp;lt;numRows-1），每个周期产生两个字符，且第一个字符的坐标x满足x%T&amp;#x3D;i，第二个字符的坐标y满足x%T&amp;#x3D;T-i。&lt;br&gt;对于最后一行，每个周期产生一个字符，且字符的坐标x满足x%T&amp;#x3D;numRows-1。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;if numRows == 1 or numRows &amp;gt;= len(s):
            return s
        
        T = 2*numRows-2
        ans = [&amp;quot;&amp;quot; for i in range(numRows)]
        for x in range(len(s)):
            mod = x%T
            if 0 &amp;lt;= mod &amp;lt;= numRows-1:
                ans[mod] += s[x]
            else:
                ans[T-mod] += s[x]
        return &amp;quot;&amp;quot;.join(ans)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;官方题解&#34;&gt;&lt;a href=&#34;#官方题解&#34; class=&#34;headerlink&#34; title=&#34;官方题解&#34;&gt;&lt;/a&gt;官方题解&lt;/h1&gt;&lt;h1 id=&#34;思路一&#34;&gt;&lt;a href=&#34;#思路一&#34; class=&#34;headerlink&#34; title=&#34;思路一&#34;&gt;&lt;/a&gt;思路一&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class Solution:
    def convert(self, s: str, numRows: int) -&amp;gt; str:
        n, r = len(s), numRows
        if r == 1 or r &amp;gt;= n:
            return s
        t = r * 2 - 2
        c = (n + t - 1) // t * (r - 1)
        mat = [[&amp;#39;&amp;#39;] * c for _ in range(r)]
        x, y = 0, 0
        for i, ch in enumerate(s):
            mat[x][y] = ch
            if i % t &amp;lt; r - 1:
                x += 1  # 向下移动
            else:
                x -= 1
                y += 1  # 向右上移动
        return &amp;#39;&amp;#39;.join(ch for row in mat for ch in row if ch)
# 时间复杂度：O(r⋅n)，其中r=numRows，n 为字符串 s 的长度。时间主要消耗在矩阵的创建和遍历上，矩阵的行数为r，列数可以视为O(n)。
# 空间复杂度：O(r⋅n)。矩阵需要O(r⋅n) 的空间。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 矩阵压缩
class Solution:
    def convert(self, s: str, numRows: int) -&amp;gt; str:
        n, r = len(s), numRows
        if r == 1 or r &amp;gt;= n:
            return s
        t = r * 2 - 2
        c = (n + t - 1) // t * (r - 1)
        mat = [[&amp;#39;&amp;#39;] * c for _ in range(r)]
        x, y = 0, 0
        for i, ch in enumerate(s):
            mat[x][y] = ch
            if i % t &amp;lt; r - 1:
                x += 1  # 向下移动
            else:
                x -= 1
                y += 1  # 向右上移动
        return &amp;#39;&amp;#39;.join(ch for row in mat for ch in row if ch)

# 时间复杂度：O(n)。
# 空间复杂度：O(n)。压缩后的矩阵需要 O(n) 的空间。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;思路二&#34;&gt;&lt;a href=&#34;#思路二&#34; class=&#34;headerlink&#34; title=&#34;思路二&#34;&gt;&lt;/a&gt;思路二&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class Solution:
    def convert(self, s: str, numRows: int) -&amp;gt; str:
        n, r = len(s), numRows
        if r == 1 or r &amp;gt;= n:
            return s
        t = r * 2 - 2
        ans = []
        for i in range(r):  # 枚举矩阵的行
            for j in range(0, n - i, t):  # 枚举每个周期的起始下标
                ans.append(s[j + i])  # 当前周期的第一个字符
                if 0 &amp;lt; i &amp;lt; r - 1 and j + t - i &amp;lt; n:
                    ans.append(s[j + t - i])  # 当前周期的第二个字符
        return &amp;#39;&amp;#39;.join(ans)
# 时间复杂度：O(n)，其中 n 为字符串 s 的长度。s 中的每个字符仅会被访问一次，因此时间复杂度为O(n)。
# 空间复杂度：O(1)。返回值不计入空间复杂度。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/5eb2eccf3f81436dac42128918d9cb42.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/ComputerNetwork/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
            <title>计算机网络的基本概念</title>
            <link>https://www.liangmeng.xyz/ComputerNetwork/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
            <category term="计算机网络" scheme="https://www.liangmeng.xyz/categories/ComputerNetwork/" />
            <category term="计算机网络的基本概念" scheme="https://www.liangmeng.xyz/categories/ComputerNetwork/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" />
            <category term="笔记" scheme="https://www.liangmeng.xyz/tags/%E7%AC%94%E8%AE%B0/" />
            <category term="计算机网络" scheme="https://www.liangmeng.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
            <pubDate>Tue, 26 Apr 2022 21:47:00 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/WrittenExamination/Tencent_20220424/</guid>
            <title>腾讯20220424</title>
            <link>https://www.liangmeng.xyz/WrittenExamination/Tencent_20220424/</link>
            <category term="企业笔试" scheme="https://www.liangmeng.xyz/categories/WrittenExamination/" />
            <category term="腾讯笔试题" scheme="https://www.liangmeng.xyz/categories/WrittenExamination/%E8%85%BE%E8%AE%AF%E7%AC%94%E8%AF%95%E9%A2%98/" />
            <category term="算法" scheme="https://www.liangmeng.xyz/tags/%E7%AE%97%E6%B3%95/" />
            <category term="牛客网" scheme="https://www.liangmeng.xyz/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/" />
            <category term="笔试" scheme="https://www.liangmeng.xyz/tags/%E7%AC%94%E8%AF%95/" />
            <category term="腾讯" scheme="https://www.liangmeng.xyz/tags/%E8%85%BE%E8%AE%AF/" />
            <pubDate>Tue, 26 Apr 2022 02:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;前言&#34;&gt;&lt;a href=&#34;#前言&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;笔试一共五道编程题，满分是100分，时间是两个小时，可以跳题，使用的平台是牛客网，允许跳出界面使用本地IDE。&lt;/p&gt;
&lt;h1 id=&#34;题目一：构建数字&#34;&gt;&lt;a href=&#34;#题目一：构建数字&#34; class=&#34;headerlink&#34; title=&#34;题目一：构建数字&#34;&gt;&lt;/a&gt;题目一：构建数字&lt;/h1&gt;&lt;p&gt;给定n个长度均为m的数字字符串，从上往下构建成m个新的数，去掉前置0后按照从小到大的顺序输出。&lt;/p&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;第一行包括一个整数n。&lt;/p&gt;
&lt;p&gt;接下来n行每行包括一个长度为m的数字字符串。&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;第一行包括新构建的数按从小到大排列。&lt;/p&gt;
&lt;p&gt;输入示例：&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;0121&lt;/p&gt;
&lt;p&gt;1502&lt;/p&gt;
&lt;p&gt;2138&lt;/p&gt;
&lt;p&gt;输出示例：&lt;/p&gt;
&lt;p&gt;12 128 151 203&lt;/p&gt;
&lt;h2 id=&#34;思路&#34;&gt;&lt;a href=&#34;#思路&#34; class=&#34;headerlink&#34; title=&#34;思路&#34;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;该题比较简单，可以直接暴力求解，需要注意的是前置0的处理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;n = int(input())
nums = []
for i in range(n):
    num = input()
    nums.append(num)

ans = []
for i in range(len(nums[0])):
    a = &amp;quot;&amp;quot;
    for j in range(n):
        a += nums[j][i]
    # int()函数会直接去掉前置0
    ans.append(int(a))

ans.sort()
for i in range(len(ans)):
    print(ans[i], end=&amp;quot; &amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目二：淘汰数字&#34;&gt;&lt;a href=&#34;#题目二：淘汰数字&#34; class=&#34;headerlink&#34; title=&#34;题目二：淘汰数字&#34;&gt;&lt;/a&gt;题目二：淘汰数字&lt;/h1&gt;&lt;p&gt;给定一个数组，下标从1~n，每次淘汰下标为非质数的数字，剩下的数形成新的数组，重复上述过程，直到数组内只剩下一个数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本题为核心代码模式，只需要补充解法类的实现代码即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;第一行包括一个长度为n的数组。&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;第一行包括一个整数。&lt;/p&gt;
&lt;p&gt;输入示例1：&lt;/p&gt;
&lt;p&gt;[1, 2, 3, 4]&lt;/p&gt;
&lt;p&gt;输出示例1：&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;输入示例2：&lt;/p&gt;
&lt;p&gt;[3, 1 , 1 , 4 , 5, 6]&lt;/p&gt;
&lt;p&gt;输出示例2：&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;h2 id=&#34;思路-1&#34;&gt;&lt;a href=&#34;#思路-1&#34; class=&#34;headerlink&#34; title=&#34;思路&#34;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;本题也是直接暴力求解，重点是求出n内的所有质数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;from math import sqrt, ceil
class Solution:
    def isP(self, x):
        m = ceil(sqrt(x))+1
        for j in range(2, m):
            if x%j == 0:
                return False
        return True

    def getNumber(self , a):
        # write code here
        n = len(a)
        pnums = [2]
        for i in range(3, n):
            if self.isP(i):
                pnums.append(i)
        while n != 1:
            k = 0
            for i in range(len(pnums)):
                if pnums[i] &amp;gt; n:
                    break
                a[k] = a[pnums[i]-1]
                k += 1
            n = k
        return a[0]
    
a = [1,2,3,4] # [3,1,1,4,5,6]
print(Solution().getNumber(a))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目三：士兵分配&#34;&gt;&lt;a href=&#34;#题目三：士兵分配&#34; class=&#34;headerlink&#34; title=&#34;题目三：士兵分配&#34;&gt;&lt;/a&gt;题目三：士兵分配&lt;/h1&gt;&lt;p&gt;给定一定数量的士兵，编号为1&lt;del&gt;n，用长度为n的0&amp;#x2F;1串s表示，其中0代表该士兵只会进攻，1代表该士兵只会防御，且其攻击力或防御力等于其编号。将士兵分组，编号为1&lt;/del&gt;pos的士兵为进攻组，该组的攻击力之和用w表示，编号为pos+1~n的士兵为防御组，该组的防御力之和用v表示，求|w-v|的最小值。注意：pos可以取0，当pos取0时，表示将所有士兵分到防御组，而进攻组没有士兵。&lt;/p&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;第一行包括一个整数n，表示士兵的数量。&lt;/p&gt;
&lt;p&gt;第二行包括一个0&amp;#x2F;1字符串s，表示士兵的状态。&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;第一行包括一个整数，表示|w-v|的最小值。&lt;/p&gt;
&lt;p&gt;输入示例1：&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;0011&lt;/p&gt;
&lt;p&gt;输出示例1：&lt;/p&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;输入示例2：&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;1000101&lt;/p&gt;
&lt;p&gt;输出示例2：&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;h2 id=&#34;思路-2&#34;&gt;&lt;a href=&#34;#思路-2&#34; class=&#34;headerlink&#34; title=&#34;思路&#34;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;思路一：暴力求解。遍历整个字符串，在每一个位置对其进行分割，得到左右两个子串，然后分别统计左右两边的攻击力或防御力，与此同时不断刷新差值绝对值的最小值。这种方法的算法复杂度较高，无法AC。&lt;/p&gt;
&lt;p&gt;思路二：逐个分配。可以先假设所有的士兵都在右边，左边没有士兵，即pos为0的情况，此时w和v均可知。然后遍历整个字符串，将士兵逐个从右边分配到左边，如果分配的士兵为0，那么w加上该士兵的编号，v不变；如果分配的士兵为1，那么v减去该士兵的编号，w不变，与此同时不断刷新差值绝对值的最小值即可。&lt;/p&gt;
&lt;p&gt;以下为思路二的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;n = int(input())
s = input()
# 因为编号为1~n，且pos的取值范围为0~n
# 所以添加两个占位符可以简化问题的求解过程
s = &amp;quot;-&amp;quot; + s + &amp;quot;-&amp;quot;
w = 0
v = 0
for i in range(n+2):
    if s[i] == &amp;quot;1&amp;quot;:
        v += i
res = v
for i in range(n+2):
    if s[i] == &amp;quot;0&amp;quot;:
        w += i
    if s[i] == &amp;quot;1&amp;quot;:
        v -= i
    res = min(res, abs(w-v))
print(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目四：合并链表&#34;&gt;&lt;a href=&#34;#题目四：合并链表&#34; class=&#34;headerlink&#34; title=&#34;题目四：合并链表&#34;&gt;&lt;/a&gt;题目四：合并链表&lt;/h1&gt;&lt;p&gt;给出一个链表数组，该链表数组均是某一个环状链表的一部分，请将这些链表组合并成环状链表，然后需要找到一个位置，使得从这个位置将环切开后，按照顺序或逆序遍历这个环，形成的链字典序尽量小，并返回这条链。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;链表字典序的定义：对于两个链表a、b，从头节点到尾节点遍历，找到第一个不相同的节点值并比较大小，如果a[i].val &amp;lt; b[i].val，则认为a的字典序小于b的字典序。例如：链表{1,2,3} &amp;lt; 链表{1,2,4},     链表{3,4,5} &amp;lt; 链表{6,7}。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;环状链表不存在相同的节点值。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;该题环状链表节点个数最小为2  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个链表都是在环状链表上的顺时针的一部分。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给定的链表数组一定能组成一个环状链表。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入示例1：&lt;/p&gt;
&lt;p&gt;[{1, 2, 3}, {2, 3, 4}, {4, 1}]&lt;/p&gt;
&lt;p&gt;输出示例1：&lt;/p&gt;
&lt;p&gt;{1, 2, 3, 4}&lt;/p&gt;
&lt;p&gt;输入示例2：&lt;/p&gt;
&lt;p&gt;[{3, 7, 4}, {7, 4, 5, 1, 10, 3}]&lt;/p&gt;
&lt;p&gt;输出示例2：&lt;/p&gt;
&lt;p&gt;{1, 5, 4, 7, 3, 10}&lt;/p&gt;
&lt;h2 id=&#34;思路-3&#34;&gt;&lt;a href=&#34;#思路-3&#34; class=&#34;headerlink&#34; title=&#34;思路&#34;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;用字典存每个下标的前驱和后继，即可还原环状链表。接下来考虑切口位置，可将其转化为确定头节点和遍历方向的问题。要使字典序最小，那么头节点必须是链表里面的最小值（确定头节点），而下一节点为头节点的前驱节点和后继节点中较小的一个（确定遍历方向）。&lt;/p&gt;
&lt;p&gt;本题的解法并不难，难的是如何处理输入，将其合并成一个环状链表。系统中采用的核心代码模式，只需补充解法类的实现代码即可，这里给出的是完整代码。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;from re import compile
from xmlrpc.client import MAXINT
inp = input()
lss = compile(&amp;#39;\d+&amp;#39;).findall(inp)
ring = dict()
head = MAXINT
for i in range(len(lss)-1):
    ring[int(lss[i])] = int(lss[i+1])
    head = min(head, int(lss[i]))

rering = &amp;#123;v : k for k, v in ring.items()&amp;#125;
pre = rering[head]
nex = ring[head]
res = &amp;#39;&amp;#123;&amp;#39; + str(head) + &amp;#39;,&amp;#39;
if pre &amp;lt; nex:
    for i in range(len(rering)-1):
        res += str(rering[head]) + &amp;#39;,&amp;#39;
        head = rering[head]
if pre &amp;gt; nex:
    for i in range(len(ring)-1):
        res += str(ring[head]) + &amp;#39;,&amp;#39;
        head = ring[head]
print(res[:-1] + &amp;#39;&amp;#125;&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目五：买卖股票&#34;&gt;&lt;a href=&#34;#题目五：买卖股票&#34; class=&#34;headerlink&#34; title=&#34;题目五：买卖股票&#34;&gt;&lt;/a&gt;题目五：买卖股票&lt;/h1&gt;&lt;p&gt;现在有一个长度为n的价格数组a，表示某只股票每天的价格。每天最多可以买入或卖出该只股票的一股，买入或者卖出没有手续费，且卖出股票前必须手里已经有股票才能卖出，但是持有的股票数目不受限制，并且初始资金为m元，在任何时刻都不能进行透支，即资金必须始终大于等于0。请问在n天结束之后，拥有的最大总资产是多少？其中总资产 &amp;#x3D; 股票数目 * 股票价格 + 现金。&lt;/p&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;第一行包括两个整数n和m，分别表示天数和初始资金。&lt;/p&gt;
&lt;p&gt;第二行包括n个整数，分别表示该只股票每天的价格。&lt;/p&gt;
&lt;p&gt;输入示例：&lt;/p&gt;
&lt;p&gt;6 2&lt;/p&gt;
&lt;p&gt;2 3 1 1 1 2&lt;/p&gt;
&lt;p&gt;输出示例：&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;h2 id=&#34;思路-4&#34;&gt;&lt;a href=&#34;#思路-4&#34; class=&#34;headerlink&#34; title=&#34;思路&#34;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;动态规划，01背包的变种。定义dp[i][j]代表前i天，手上当前持有j只股票的最大现金数，那么可以根据每天选择买入还是卖出达成转移。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;n, m = map(int, input().split())
prices = list(map(int, input().split()))
prices.insert(0, -1e16)
dp = [[-1e16 for i in range(n+2)] for j in range(n+2)]
dp[0][0] = m
for i in range(1, n+1):
    for j in range(n+1):
        # 今天不买不卖的情况
        nodo = dp[i-1][j]
        # 今天买入一股的情况
        buy = -1e16
        if j &amp;gt; 0 and dp[i-1][j-1] &amp;gt;= prices[i]:
            buy = dp[i-1][j-1]-prices[i]
        # 昨天卖出一股的情况
        sell = dp[i-1][j+1]+prices[i]
        # 取资金数目最大的一种
        dp[i][j] = max(nodo, buy, sell)


res = -1e16
for i in range(n+1):
    res = max(res, dp[n][i] + i*prices[n])

print(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/99febfcb8347451c8aa3aa067c9d61c1.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/ArtificialIntelligence/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/</guid>
            <title>第一章-人工智能的概述</title>
            <link>https://www.liangmeng.xyz/ArtificialIntelligence/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/</link>
            <category term="人工智能" scheme="https://www.liangmeng.xyz/categories/ArtificialIntelligence/" />
            <category term="第一章-人工智能的概述" scheme="https://www.liangmeng.xyz/categories/ArtificialIntelligence/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/" />
            <category term="人工智能" scheme="https://www.liangmeng.xyz/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" />
            <category term="笔记" scheme="https://www.liangmeng.xyz/tags/%E7%AC%94%E8%AE%B0/" />
            <pubDate>Sat, 23 Apr 2022 17:19:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;人工智能概述&#34;&gt;&lt;a href=&#34;#人工智能概述&#34; class=&#34;headerlink&#34; title=&#34;人工智能概述&#34;&gt;&lt;/a&gt;人工智能概述&lt;/h1&gt;&lt;h2 id=&#34;人工智能的定义&#34;&gt;&lt;a href=&#34;#人工智能的定义&#34; class=&#34;headerlink&#34; title=&#34;人工智能的定义&#34;&gt;&lt;/a&gt;人工智能的定义&lt;/h2&gt;&lt;h3 id=&#34;什么是智能&#34;&gt;&lt;a href=&#34;#什么是智能&#34; class=&#34;headerlink&#34; title=&#34;什么是智能&#34;&gt;&lt;/a&gt;什么是智能&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;自然智能：指人类和一些动物所具有的智力和行为能力。&lt;/li&gt;
&lt;li&gt;人类的自然智能（简称智能）：指人类在认识客观世界中，由思维过程和脑力活动所表现出的综合能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;智能的不同观点&#34;&gt;&lt;a href=&#34;#智能的不同观点&#34; class=&#34;headerlink&#34; title=&#34;智能的不同观点&#34;&gt;&lt;/a&gt;智能的不同观点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;思维理论：&lt;strong&gt;智能来源于思维活动，智能的核心是思维，人的一切知识都是思维的产物&lt;/strong&gt;。可望通过对思维规律和思维方法的研究来揭示智能的本质。&lt;/li&gt;
&lt;li&gt;知识阈值理论：&lt;strong&gt;智能取决于知识的数量及其可运用程度&lt;/strong&gt;。一个系统所具有的可运用知识越多，其智能就会越高。&lt;/li&gt;
&lt;li&gt;进化理论：智能取决于感知和行为，取决于对外界复杂环境的适应，智能不需要知识、不需要表示、不需要推理，&lt;strong&gt;智能可由逐步进化来实现&lt;/strong&gt;。（MIT，Brooks，人造机器虫研究）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;智能的层次结构&#34;&gt;&lt;a href=&#34;#智能的层次结构&#34; class=&#34;headerlink&#34; title=&#34;智能的层次结构&#34;&gt;&lt;/a&gt;智能的层次结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;高层智能：以大脑皮层（抑制中枢）为主，主要完成记忆、思维等活动。&lt;/li&gt;
&lt;li&gt;中层智能：以丘脑（间脑，感觉中枢）为主，主要完成感知活动。&lt;/li&gt;
&lt;li&gt;低层智能：以小脑、脊髓为主，主要完成动作反应活动。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;思维理论和知识阈值理论对应高层智能，而进化理论对应中层智能和低层智能&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;智能包含的能力&#34;&gt;&lt;a href=&#34;#智能包含的能力&#34; class=&#34;headerlink&#34; title=&#34;智能包含的能力&#34;&gt;&lt;/a&gt;智能包含的能力&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;感知能力：&lt;strong&gt;人类获得外界信息的基本途径&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;感知–动作方式：对简单、紧急的信息。&lt;/p&gt;
&lt;p&gt;感知–思维–动作方式：对复杂的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;记忆和思维的能力：&lt;/p&gt;
&lt;p&gt;记忆：对感知到的外界信息和由思维产生的内部知识的&lt;strong&gt;存储&lt;/strong&gt;过程。&lt;/p&gt;
&lt;p&gt;思维：对已存储信息或知识的本质属性、内部规律的&lt;strong&gt;认识&lt;/strong&gt;过程。&lt;/p&gt;
&lt;p&gt;思维方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象思维（逻辑思维）：根据&lt;strong&gt;逻辑规则&lt;/strong&gt;对信息和知识进行处理的理性思维方式。&lt;/li&gt;
&lt;li&gt;形象思维（直感思维）：根据&lt;strong&gt;感性形象认识材料&lt;/strong&gt;对客观现象进行处理的一种思维方式。&lt;/li&gt;
&lt;li&gt;灵感思维（顿悟思维）：是一种显意识和潜意识相互作用的思维方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;学习和自适应能力：&lt;/p&gt;
&lt;p&gt;学习：&lt;strong&gt;是一个具有特定目的的知识获取过程，是人的一种本能&lt;/strong&gt;。不同人的学习方法、能力不同。&lt;/p&gt;
&lt;p&gt;自适应：&lt;strong&gt;是一种通过自我调节适应外界环境的过程，是人的一种本能&lt;/strong&gt;。不同人的适应能力不同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行为能力：&lt;strong&gt;对感知的外界信息做出动作反应的能力&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;信息来源：由感知直接获得的外界信息或经过思维加工后的信息。&lt;/p&gt;
&lt;p&gt;实现过程’：通过脊髓来控制，由语言、表情、体姿等来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;什么是人工智能&#34;&gt;&lt;a href=&#34;#什么是人工智能&#34; class=&#34;headerlink&#34; title=&#34;什么是人工智能&#34;&gt;&lt;/a&gt;什么是人工智能&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;学科的名称。&lt;/li&gt;
&lt;li&gt;人工方法实现的智能。&lt;/li&gt;
&lt;li&gt;计算机模拟实现的智能。&lt;/li&gt;
&lt;li&gt;人造的智能机器或系统。&lt;/li&gt;
&lt;li&gt;模仿、延伸以及扩展人的智能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;人工智能典型的4种定义方法&#34;&gt;&lt;a href=&#34;#人工智能典型的4种定义方法&#34; class=&#34;headerlink&#34; title=&#34;人工智能典型的4种定义方法&#34;&gt;&lt;/a&gt;人工智能典型的4种定义方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;类人思维方法（认知模型方法）：1978年贝尔曼，人工智能是那些与人的思维、决策、问题求解和学习等有关活动的自动化。&lt;/li&gt;
&lt;li&gt;类人行为方法（图灵测试方法）：1990年库兹韦勒，人工智能是一种创建机器的技艺，这种机器能够执行需要人的智能才能完成的功能。&lt;/li&gt;
&lt;li&gt;理性思维方法（思维法则方法）：1985年查尼艾克、麦克德莫特，人工智能是通过计算模型来进行心智能力研究的。&lt;/li&gt;
&lt;li&gt;理性行为方法（理性智能体方法）：1998年尼尔森，人工智能关心的是人工制品种的智能行为，即人工智能就是研究和建造理性智能体。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;理性思维方法与理性行为方法的关系：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;前者强调正确思维，后者强调合理行动。&lt;/li&gt;
&lt;li&gt;理性行为可以依据理性思维进行。&lt;/li&gt;
&lt;li&gt;理性行为不一定要依据理性思维进行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;人工智能的一般解释&#34;&gt;&lt;a href=&#34;#人工智能的一般解释&#34; class=&#34;headerlink&#34; title=&#34;人工智能的一般解释&#34;&gt;&lt;/a&gt;人工智能的一般解释&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;从能力的角度：人工智能是指&lt;strong&gt;用人工的方法在机器上实现的智能&lt;/strong&gt;，是智能机器所执行的通常与人类智能有关的功能，如判断、推理、证明、识别、感知、理解、设计、思考、规划、学习和问题求解等思维活动。&lt;/li&gt;
&lt;li&gt;从学科的角度：人工智能是&lt;strong&gt;一门研究如何构造智能机器或智能系统，去模拟、延伸和扩展人类智能的学科&lt;/strong&gt;，是计算机科学中涉及研究、设计和应用智能机器的一个分支。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;人工智能的研究目标&#34;&gt;&lt;a href=&#34;#人工智能的研究目标&#34; class=&#34;headerlink&#34; title=&#34;人工智能的研究目标&#34;&gt;&lt;/a&gt;人工智能的研究目标&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1978年斯洛曼，三个主要目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对智能行为有效解释的理论分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解释人类智能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;构造具有智能的人工制品。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;远期目标：&lt;strong&gt;用自动机重现人类的思维过程和智能行为&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;揭示人类智能的根本机理，用智能机器去模拟、延伸和扩展人类的智能。涉及到脑科学、认知科学、计算机科学、系统科学、控制论等多种学科，并依赖于它们的共同发展。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;近期目标：&lt;strong&gt;建造智能计算机代替人类的部分智力劳动&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;研究如何使现有的计算机更聪明，即使它能够运用知识去处理问题，能够模拟人类的智能行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;远期目标和近期目标的相互关系：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;远期目标为近期目标指明了方向。&lt;/li&gt;
&lt;li&gt;近期目标则为远期目标奠定了理论和技术基础。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;人工智能的发展简史&#34;&gt;&lt;a href=&#34;#人工智能的发展简史&#34; class=&#34;headerlink&#34; title=&#34;人工智能的发展简史&#34;&gt;&lt;/a&gt;人工智能的发展简史&lt;/h2&gt;&lt;h3 id=&#34;简史总结&#34;&gt;&lt;a href=&#34;#简史总结&#34; class=&#34;headerlink&#34; title=&#34;简史总结&#34;&gt;&lt;/a&gt;简史总结&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/c6054800e515405aaec1fe1371859be4.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;人工智能的研究内容&#34;&gt;&lt;a href=&#34;#人工智能的研究内容&#34; class=&#34;headerlink&#34; title=&#34;人工智能的研究内容&#34;&gt;&lt;/a&gt;人工智能的研究内容&lt;/h2&gt;&lt;h3 id=&#34;研究内容&#34;&gt;&lt;a href=&#34;#研究内容&#34; class=&#34;headerlink&#34; title=&#34;研究内容&#34;&gt;&lt;/a&gt;研究内容&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如何获取知识？&lt;/li&gt;
&lt;li&gt;如何将获取的知识以计算机内部代码形式加以合理表示？&lt;/li&gt;
&lt;li&gt;如何运用知识进行推理，解决实际问题？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;人工智能研究方法与途径&#34;&gt;&lt;a href=&#34;#人工智能研究方法与途径&#34; class=&#34;headerlink&#34; title=&#34;人工智能研究方法与途径&#34;&gt;&lt;/a&gt;人工智能研究方法与途径&lt;/h2&gt;&lt;h3 id=&#34;三大学派&#34;&gt;&lt;a href=&#34;#三大学派&#34; class=&#34;headerlink&#34; title=&#34;三大学派&#34;&gt;&lt;/a&gt;三大学派&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;符号主义：运用计算机科学的方法（逻辑演绎）。&lt;ul&gt;
&lt;li&gt;智能的基础是&lt;strong&gt;知识&lt;/strong&gt;，其核心是&lt;strong&gt;知识表示和知识推理&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;知识可用符号表示，也可用符号进行推理&lt;/strong&gt;，因而可以建立基于知识的人类智能和机器智能的统一的理论体系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能模拟，构造能够模拟大脑功能的智能系统&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;联结主义：运用仿生学的方法（网络连接机制）。&lt;ul&gt;
&lt;li&gt;智能行为的基元是&lt;strong&gt;神经元&lt;/strong&gt;，而不是符号。&lt;/li&gt;
&lt;li&gt;思维过程是&lt;strong&gt;神经元的联结活动过程&lt;/strong&gt;，而不是符号运算过程，反对符号主义关于物理符号系统的假设。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结构模拟，构造模拟大脑结构的神经网络系统&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;行为主义：运用进化论的思想（控制论和机器学习方法）。&lt;ul&gt;
&lt;li&gt;智能取决于&lt;strong&gt;感知和行动&lt;/strong&gt;，即“感知-动作”模型。&lt;/li&gt;
&lt;li&gt;智能不需要知识、不需要表示、不需要推理，人工智能可以像人类智能那样&lt;strong&gt;逐步进化&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;行为模拟，构造具有进化能力的智能系统&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;人工智能的研究领域&#34;&gt;&lt;a href=&#34;#人工智能的研究领域&#34; class=&#34;headerlink&#34; title=&#34;人工智能的研究领域&#34;&gt;&lt;/a&gt;人工智能的研究领域&lt;/h2&gt;&lt;h3 id=&#34;研究领域&#34;&gt;&lt;a href=&#34;#研究领域&#34; class=&#34;headerlink&#34; title=&#34;研究领域&#34;&gt;&lt;/a&gt;研究领域&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;机器思维：&lt;strong&gt;推理（确定性推理、不确定性推理）和搜索（状态空间搜索、与&amp;#x2F;或树搜索、博弈树搜索）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;机器感知：计算机视觉、模式识别和自然语言处理。&lt;/li&gt;
&lt;li&gt;机器行为：智能控制&amp;#x2F;制造。&lt;/li&gt;
&lt;li&gt;机器学习：符号学习和神经学习。&lt;/li&gt;
&lt;li&gt;计算智能：神经计算、进化计算和模糊计算。&lt;/li&gt;
&lt;li&gt;分布智能：并行求解。&lt;/li&gt;
&lt;li&gt;智能系统：专家系统和智能决策支持系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;人工智能的研究现状与发展方向&#34;&gt;&lt;a href=&#34;#人工智能的研究现状与发展方向&#34; class=&#34;headerlink&#34; title=&#34;人工智能的研究现状与发展方向&#34;&gt;&lt;/a&gt;人工智能的研究现状与发展方向&lt;/h2&gt;&lt;h3 id=&#34;研究现状&#34;&gt;&lt;a href=&#34;#研究现状&#34; class=&#34;headerlink&#34; title=&#34;研究现状&#34;&gt;&lt;/a&gt;研究现状&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;多学科交叉研究&lt;/li&gt;
&lt;li&gt;多学派和多技术融合研究&lt;/li&gt;
&lt;li&gt;分布智能研究&lt;/li&gt;
&lt;li&gt;群体智能研究&lt;/li&gt;
&lt;li&gt;社会智能研究&lt;/li&gt;
&lt;li&gt;集成智能研究&lt;/li&gt;
&lt;li&gt;认知计算与情感计算研究&lt;/li&gt;
&lt;li&gt;智能系统与智能服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;发展方向&#34;&gt;&lt;a href=&#34;#发展方向&#34; class=&#34;headerlink&#34; title=&#34;发展方向&#34;&gt;&lt;/a&gt;发展方向&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;知识 + 数据 + 算法 + 算力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/bbb8c160345142c6bb9b8b6c0617f5bd.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/StereotypedWriting/OperatingSystem/</guid>
            <title>计算机八股文之操作系统</title>
            <link>https://www.liangmeng.xyz/StereotypedWriting/OperatingSystem/</link>
            <category term="计算机八股文" scheme="https://www.liangmeng.xyz/categories/StereotypedWriting/" />
            <category term="操作系统" scheme="https://www.liangmeng.xyz/categories/StereotypedWriting/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
            <category term="笔记" scheme="https://www.liangmeng.xyz/tags/%E7%AC%94%E8%AE%B0/" />
            <category term="计算机八股文" scheme="https://www.liangmeng.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%85%AB%E8%82%A1%E6%96%87/" />
            <category term="操作系统" scheme="https://www.liangmeng.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
            <pubDate>Fri, 15 Apr 2022 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;简要概述一下什么是操作系统？&#34;&gt;&lt;a href=&#34;#简要概述一下什么是操作系统？&#34; class=&#34;headerlink&#34; title=&#34;简要概述一下什么是操作系统？&#34;&gt;&lt;/a&gt;简要概述一下什么是操作系统？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;操作系统是&lt;strong&gt;管理计算机硬件和软件资源&lt;/strong&gt;的计算机程序，提供一个计算机用户与计算机硬件系统之间的接口（向上对用户程序提供接口，向下接管硬件资源）。&lt;/li&gt;
&lt;li&gt;操作系统本质上也是一个软件，作为最接近硬件的&lt;strong&gt;系统软件，负责处理器管理、存储器管理、设备驱动管理、文件系统管理和提供用户接口。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;操作系统的分类有哪些？&#34;&gt;&lt;a href=&#34;#操作系统的分类有哪些？&#34; class=&#34;headerlink&#34; title=&#34;操作系统的分类有哪些？&#34;&gt;&lt;/a&gt;操作系统的分类有哪些？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;操作系统一般可分为&lt;strong&gt;批处理操作系统、分时操作系统和实时操作系统。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;若一个操作系统兼顾批处理和分时的功能，则称该系统为&lt;strong&gt;通用操作系统&lt;/strong&gt;，常见的通用操作系统有：Windows、Linux、MacOS等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;什么是内核态和用户态？&#34;&gt;&lt;a href=&#34;#什么是内核态和用户态？&#34; class=&#34;headerlink&#34; title=&#34;什么是内核态和用户态？&#34;&gt;&lt;/a&gt;什么是内核态和用户态？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;为了&lt;strong&gt;避免操作系统和关键数据被用户程序破坏&lt;/strong&gt;，将处理器的执行状态分为内核态和用户态。&lt;/li&gt;
&lt;li&gt;内核态是操作系统管理程序执行时所处的状态，&lt;strong&gt;能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用户态是用户程序执行时处理器所处的状态，&lt;strong&gt;不能执行特权指令，只能访问用户地址空间。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用户程序运行在用户态，操作系统内核运行在内核态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;如何实现内核态和用户态的切换？&#34;&gt;&lt;a href=&#34;#如何实现内核态和用户态的切换？&#34; class=&#34;headerlink&#34; title=&#34;如何实现内核态和用户态的切换？&#34;&gt;&lt;/a&gt;如何实现内核态和用户态的切换？&lt;/h1&gt;&lt;p&gt;处理器从用户态切换到内核态的方法有三种：&lt;strong&gt;系统调用、异常、外部中断。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统调用，操作系统的最小功能单位，是操作系统提供的&lt;strong&gt;用户接口，是软中断。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;异常，也叫做&lt;strong&gt;内中断，是由错误引起的&lt;/strong&gt;，如文件损坏、缺页故障等。&lt;/li&gt;
&lt;li&gt;外部中断，通过两根信号线来通知处理器&lt;strong&gt;外设的状态变化，是硬中断。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;软中断和硬中断的区别与联系？&#34;&gt;&lt;a href=&#34;#软中断和硬中断的区别与联系？&#34; class=&#34;headerlink&#34; title=&#34;软中断和硬中断的区别与联系？&#34;&gt;&lt;/a&gt;软中断和硬中断的区别与联系？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;硬中断是有&lt;strong&gt;外设硬件&lt;/strong&gt;发出的，&lt;strong&gt;需要有中断控制器&lt;/strong&gt;的参与。其过程是外设侦测到变化，告知中断控制器，中断控制器通过CPU或内存的中断脚通CPU，然后&lt;strong&gt;硬件&lt;/strong&gt;进行程序计数器及堆栈寄存器的现场保存工作（引发上下文切换），并根据中断向量调用&lt;strong&gt;硬中断处理程序&lt;/strong&gt;进行中断处理。&lt;/li&gt;
&lt;li&gt;软中断则通常是由&lt;strong&gt;硬中断处理程序或者进程调度程序等软件程序&lt;/strong&gt;发出的中断信号，&lt;strong&gt;无需中断控制器&lt;/strong&gt;的参与，直接以一个CPU指令之形式指示&lt;strong&gt;CPU&lt;/strong&gt;进行程序计数器及堆栈寄存器之现场保存工作(亦会引发上下文切换)，并调用相应的&lt;strong&gt;软中断处理程序&lt;/strong&gt;进行中断处理(即我们通常所言之系统调用)。&lt;/li&gt;
&lt;li&gt;硬中断直接以硬件的方式引发，处理速度快。软中断以软件指令的方式引发，适合于对响应速度要求不是特别严格的场景。&lt;/li&gt;
&lt;li&gt;硬中断通过设置 CPU 的屏蔽位可进行屏蔽，软中断则由于是指令之方式给出，不能屏蔽（&lt;strong&gt;硬中断可以被屏蔽，软中断不可以被屏蔽&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;硬中断和软中断**均会引起上下文切换(进程&amp;#x2F;线程之切换)**，进程切换的过程是差不多的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;并发和并行的区别？&#34;&gt;&lt;a href=&#34;#并发和并行的区别？&#34; class=&#34;headerlink&#34; title=&#34;并发和并行的区别？&#34;&gt;&lt;/a&gt;并发和并行的区别？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;并发：宏观上看多个程序在同时运行，比如在单核CPU上的多任务，但微观上看程序的指令是&lt;strong&gt;交替运行&lt;/strong&gt;的，&lt;strong&gt;CPU在任何时刻最多只能同时运行一条指令&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;并行：严格意义上的同时运行，比如多核CPU，程序的指令是&lt;strong&gt;同时运行&lt;/strong&gt;的，&lt;strong&gt;CPU在任何时刻最多能够同时运行多条指令&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;并发&lt;strong&gt;不能&lt;/strong&gt;提高计算机的性能，而并行&lt;strong&gt;能够&lt;/strong&gt;提高计算机的性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;什么是进程、线程、协程？&#34;&gt;&lt;a href=&#34;#什么是进程、线程、协程？&#34; class=&#34;headerlink&#34; title=&#34;什么是进程、线程、协程？&#34;&gt;&lt;/a&gt;什么是进程、线程、协程？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;进程：进程是&lt;strong&gt;系统进行资源分配和管理的基本单位&lt;/strong&gt;。每个进程都有自己&lt;strong&gt;独立的内存空间&lt;/strong&gt;，不同进程之间可以进行通信。由于进程比较重量，占据独立的内存，所以进程上下文的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对来说比较安全。&lt;/li&gt;
&lt;li&gt;线程：线程是进程的一个实体，是&lt;strong&gt;CPU调度和分派的基本单位&lt;/strong&gt;，它是比进程更小的能够独立运行的单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（栈、寄存器、程序计数器），但是它可&lt;strong&gt;与同属一个进程的其他线程共享进程所拥有的全部资源&lt;/strong&gt;。线程间的通信主要通过共享内存，上下文的切换开销比较少，但相比进程不够稳定，容易丢失数据。&lt;/li&gt;
&lt;li&gt;协程：协程是&lt;strong&gt;一种用户态的轻量级线程&lt;/strong&gt;，协程的&lt;strong&gt;调度完全由用户控制&lt;/strong&gt;。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方。在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则&lt;strong&gt;基本没有内核切换的开销，可以不加锁地访问全局变量&lt;/strong&gt;，所以上下文的切换非常快。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;进程和线程的区别？&#34;&gt;&lt;a href=&#34;#进程和线程的区别？&#34; class=&#34;headerlink&#34; title=&#34;进程和线程的区别？&#34;&gt;&lt;/a&gt;进程和线程的区别？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一个程序至少有一个进程，一个进程至少有一个线程。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从系统调度上看：进程是资源分配和管理的基本单位，线程是CPU调度和分派的基本单位。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从上下文切换上看：线程上下文的切换要比进程上下文的切换快得多。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从系统开销上看：创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间、I&amp;#x2F;O设备等，而创建或撤销线程时，系统只需要为之分配或回收少量资源，如栈、寄存器等，所以进程切换的开销要远大于线程切换的开销。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;协程和线程的区别？&#34;&gt;&lt;a href=&#34;#协程和线程的区别？&#34; class=&#34;headerlink&#34; title=&#34;协程和线程的区别？&#34;&gt;&lt;/a&gt;协程和线程的区别？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个线程可以有多个协程，一个进程也可以有多个协程。线程和进程都是同步机制，而协程是异步机制。&lt;/li&gt;
&lt;li&gt;协程是由程序自身控制的，没有线程切换的开销，执行效率非常高。&lt;/li&gt;
&lt;li&gt;协程不需要多线程的锁机制：在协程中控制共享资源不需要加锁，只需要判断状态即可，所以执行效率比多线程高很多。&lt;/li&gt;
&lt;li&gt;线程是抢占式的，而协程是非抢占式的，需要用户释放使用权切换到其他协程，因此同一时间只有一个协程拥有运行权，相当于单线程。&lt;/li&gt;
&lt;li&gt;协程不被操作系统内核管理，而完全由程序控制。线程是被分割的CPU资源，协程是组织好的代码流程，线程是协程的资源。但协程不会直接使用线程，协程直接利用的是执行器来关联任意线程或线程池。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;进程的基本操作有哪些？&#34;&gt;&lt;a href=&#34;#进程的基本操作有哪些？&#34; class=&#34;headerlink&#34; title=&#34;进程的基本操作有哪些？&#34;&gt;&lt;/a&gt;进程的基本操作有哪些？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;fork()创建子进程：&lt;strong&gt;fork()函数调用一次，返回两次，在父进程中返回子进程的PID，而在子进程中返回0&lt;/strong&gt;，可以利用这个特点来判断一个进程是父进程还是子进程。&lt;br&gt;（1）新创建子进程几乎但不完全与父进程相同：子进程得到与父进程用户级&lt;strong&gt;虚拟地址空间相同（但是独立的）一份副本&lt;/strong&gt;，包括代码和数据段、堆、共享库以及用户栈；子进程还获得与父进程所有&lt;strong&gt;打开文件的描述符相同的一份副本&lt;/strong&gt;，这意味着子进程可以读写父进程中任何打开的文件。&lt;br&gt;（2）父进程与子进程最大的区别在于它们的进程ID（PID）不同。&lt;/li&gt;
&lt;li&gt;exec()执行新程序：&lt;strong&gt;exec()函数可以替换当前进程的代码，执行一个新的程序，而不是继续执行当前程序&lt;/strong&gt;。exec()函数可以接受一个参数，这个参数是一个字符串，表示要执行的新程序的路径，如果参数是一个相对路径，那么它会被解析为当前进程的工作目录下的路径。&lt;/li&gt;
&lt;li&gt;wait()等待子进程结束：&lt;strong&gt;wait()函数可以等待子进程结束，并返回子进程的返回值。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;waitpid()等待子进程结束：&lt;strong&gt;waitpid()函数可以等待指定的子进程结束，并返回子进程的返回值。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;exit()退出当前进程：&lt;strong&gt;exit()函数可以退出当前进程，并返回一个整数。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/WrittenExamination/Honor_20220412/</guid>
            <title>荣耀20220412</title>
            <link>https://www.liangmeng.xyz/WrittenExamination/Honor_20220412/</link>
            <category term="企业笔试" scheme="https://www.liangmeng.xyz/categories/WrittenExamination/" />
            <category term="荣耀笔试题" scheme="https://www.liangmeng.xyz/categories/WrittenExamination/%E8%8D%A3%E8%80%80%E7%AC%94%E8%AF%95%E9%A2%98/" />
            <category term="算法" scheme="https://www.liangmeng.xyz/tags/%E7%AE%97%E6%B3%95/" />
            <category term="牛客网" scheme="https://www.liangmeng.xyz/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/" />
            <category term="荣耀" scheme="https://www.liangmeng.xyz/tags/%E8%8D%A3%E8%80%80/" />
            <category term="笔试" scheme="https://www.liangmeng.xyz/tags/%E7%AC%94%E8%AF%95/" />
            <pubDate>Wed, 13 Apr 2022 22:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;前言&#34;&gt;&lt;a href=&#34;#前言&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;笔试一共三道编程题，分数依次为100、200、300，需要按顺序依次完成，只有做完这一道题，才能进入下一道题，无法跳题，使用的是牛客网，允许跳出界面使用自己的IDE。&lt;/p&gt;
&lt;h1 id=&#34;题目一：字符串分割&#34;&gt;&lt;a href=&#34;#题目一：字符串分割&#34; class=&#34;headerlink&#34; title=&#34;题目一：字符串分割&#34;&gt;&lt;/a&gt;题目一：字符串分割&lt;/h1&gt;&lt;p&gt;给定一系列的字符串，字符串的个数为N，每个字符串的长度不超过100。长度小于8的字符串用零补足，长度大于等于8的字符串，按8位位一组的形式不断分割，最后剩余部分用零补足。&lt;/p&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;第一行包括一个整数N和N个原始字符串。&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;第一行包括分割后的字符串按字典序从小到大排列。&lt;/p&gt;
&lt;p&gt;输入示例：&lt;/p&gt;
&lt;p&gt;2 abc 123456789&lt;/p&gt;
&lt;p&gt;输出示例：&lt;/p&gt;
&lt;p&gt;12345678 90000000 abc00000&lt;/p&gt;
&lt;h2 id=&#34;思路：&#34;&gt;&lt;a href=&#34;#思路：&#34; class=&#34;headerlink&#34; title=&#34;思路：&#34;&gt;&lt;/a&gt;思路：&lt;/h2&gt;&lt;p&gt;这一题比较简单，只需要按照题目的描述做即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;inp = input().split()
n = int(inp[0])
ls = []
for i in range(1, n+1):
    string = inp[i]
    while len(string) &amp;gt; 8:
        ls.append(string[:8])
        string = string[8:]
    ls.append(string + &amp;quot;0&amp;quot;*(8-len(string)))
ls.sort()
print(&amp;quot; &amp;quot;.join(ls))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目二：蜜蜂采蜜&#34;&gt;&lt;a href=&#34;#题目二：蜜蜂采蜜&#34; class=&#34;headerlink&#34; title=&#34;题目二：蜜蜂采蜜&#34;&gt;&lt;/a&gt;题目二：蜜蜂采蜜&lt;/h1&gt;&lt;p&gt;平原上，一群蜜蜂离开蜂巢采蜜，要连续采集5片花丛后归巢。&lt;br&gt;已知5片花丛相对蜂巢的坐标，请你帮它们规划一下到访花丛的顺序，以使飞行总距离最短。&lt;/p&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;以蜂巢为平面坐标原点的5片花丛A、B、C、D、E的坐标，坐标值为整数。&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;从出发到返回蜂巢最短路径的长度取整值，取整办法为舍弃小数点后面的值。&lt;/p&gt;
&lt;p&gt;输入示例：&lt;/p&gt;
&lt;p&gt;200 0 200 10 200 50 200 30 200 25&lt;/p&gt;
&lt;p&gt;输出示例：&lt;/p&gt;
&lt;p&gt;456&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;样例中的10个数，相邻两个分别为一组，表示一个花丛相对蜂巢的坐标：A(x1, y1)、B(x2, y2)、C(x3, y3)、D(x4, y4)、E(x5, y5)，分表代表x1,y1,x2,y2,x3,y3,x4,y4,x5,y5。&lt;/p&gt;
&lt;h2 id=&#34;说明：&#34;&gt;&lt;a href=&#34;#说明：&#34; class=&#34;headerlink&#34; title=&#34;说明：&#34;&gt;&lt;/a&gt;说明：&lt;/h2&gt;&lt;p&gt;本题实际上是一道旅行商问题（TSP），经典的TSP可以描述为：一个商品推销员要去若干个城市推销商品，该推销员从一个城市出发，需要经过所有城市后，回到出发地。应如何选择行进路线，以使总的行程最短。从图论的角度来看，该问题实质是在一个带权完全无向图中，找一个权值最小的Hamilton回路。由于该问题的可行解是所有顶点的全排列，随着顶点数的增加，会产生组合爆炸，它是一个NP完全问题。&lt;/p&gt;
&lt;p&gt;常见的解法有暴力破解、深度优先遍历，动态规划等。&lt;/p&gt;
&lt;p&gt;高级的解法有模拟退火算法，遗传算法，粒子群算法、神经网络等&lt;/p&gt;
&lt;h2 id=&#34;思路一：&#34;&gt;&lt;a href=&#34;#思路一：&#34; class=&#34;headerlink&#34; title=&#34;思路一：&#34;&gt;&lt;/a&gt;思路一：&lt;/h2&gt;&lt;p&gt;暴力破解，求出五片花丛所有可能的到访顺序（全排列），取飞行总距离最短的路径即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;from math import sqrt, floor
from xmlrpc.client import MAXINT
inp = list(map(int, input().split()))
mincost = MAXINT
ls = [(inp[i*2], inp[i*2+1]) for i in range(5)]
matrix = [[0 for i in range(5)] for j in range(5)]
for i in range(5):
    for j in range(5):
        matrix[i][j] = sqrt((ls[i][0]-ls[j][0])**2 + (ls[i][1]-ls[j][1])**2)

def Perm(nums, begin, end):
    global mincost, ls, matrix, path
    if begin &amp;gt;= end:
        cost = 0
        for i in range(4):
            cost += matrix[nums[i]][nums[i+1]]
        cost = cost + sqrt((ls[nums[0]][0]**2) + (ls[nums[0]][1]**2)) + sqrt((ls[nums[-1]][0]**2) + (ls[nums[-1]][1]**2))
        if cost &amp;lt; mincost:
            path = nums
            mincost = cost
        return
    else:
        for num in range(begin, end):
            nums[begin], nums[num] = nums[num], nums[begin]
            Perm(nums, begin+1, end)
            nums[begin], nums[num] = nums[num], nums[begin]

nums = [i for i in range(5)]
Perm(nums, 0, len(nums))
print(floor(mincost))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;思路二：&#34;&gt;&lt;a href=&#34;#思路二：&#34; class=&#34;headerlink&#34; title=&#34;思路二：&#34;&gt;&lt;/a&gt;思路二：&lt;/h2&gt;&lt;p&gt;采用深度优先遍历来寻找最短路径，并在遍历过程中通过不断剪枝来简化求解过程，广义上来讲也是全排列的一种。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;from math import sqrt, floor
from xmlrpc.client import MAXINT

def DFS(u, cnt, cost):
    global mincost, matrix, visited
    if cost &amp;gt; mincost:
        return
    if cnt == 6:
        cost = cost + sqrt((ls[u][0]**2) + (ls[u][1]**2)) + sqrt((ls[0][0]**2) + (ls[0][1]**2))
        if cost &amp;lt; mincost:
            mincost = cost
    visited[u] = 1
    for v in range(6):
        if not visited[v]:
            DFS(v, cnt+1, cost + matrix[u][v])
    visited[u] = 0

inp = list(map(int, input().split()))
mincost = MAXINT
visited = [0 for i in range(6)]
ls = [(inp[i*2], inp[i*2+1]) for i in range(5)]
ls.insert(0, (0, 0))
matrix = [[0 for i in range(6)] for j in range(6)]
for i in range(6):
    for j in range(6):
        matrix[i][j] = sqrt((ls[i][0]-ls[j][0])**2 + (ls[i][1]-ls[j][1])**2)

DFS(0, 1, 0)
print(floor(mincost))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;惨痛经历&#34;&gt;&lt;a href=&#34;#惨痛经历&#34; class=&#34;headerlink&#34; title=&#34;惨痛经历&#34;&gt;&lt;/a&gt;惨痛经历&lt;/h1&gt;&lt;p&gt;因为邮件上写着系统开放时间为18:00-21:00（不同于美团写着笔试时间为16:00-18:00），所以我习惯性得以为笔试时间为三个小时，当我悠哉游哉地把第二题做完返回系统时，笔试已经结束了，因此只提交了第一题，直接人麻了。。。所以，各位小伙伴无论是在比赛还是在测试，一定先看好时间！！！当然，对于秒AK的大佬来说，时间根本不是事，那就当我没说。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/8010e6fa388344ca9c90c1cd9cdb368b.png#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/WrittenExamination/MeiTuan_20220409/</guid>
            <title>美团20220409</title>
            <link>https://www.liangmeng.xyz/WrittenExamination/MeiTuan_20220409/</link>
            <category term="企业笔试" scheme="https://www.liangmeng.xyz/categories/WrittenExamination/" />
            <category term="美团笔试题" scheme="https://www.liangmeng.xyz/categories/WrittenExamination/%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E9%A2%98/" />
            <category term="算法" scheme="https://www.liangmeng.xyz/tags/%E7%AE%97%E6%B3%95/" />
            <category term="笔试" scheme="https://www.liangmeng.xyz/tags/%E7%AC%94%E8%AF%95/" />
            <category term="赛码网" scheme="https://www.liangmeng.xyz/tags/%E8%B5%9B%E7%A0%81%E7%BD%91/" />
            <category term="美团" scheme="https://www.liangmeng.xyz/tags/%E7%BE%8E%E5%9B%A2/" />
            <pubDate>Sun, 10 Apr 2022 18:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a href=&#34;#前言&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;笔试一共五道编程题（四+一），一为专项编程题，估计不同岗位有题目不一样，使用的是赛码网，允许跳出界面使用自己的IDE。&lt;/p&gt;
&lt;p&gt;在此感谢&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlYm9ydHQ/dHlwZT1ibG9n&#34;&gt;筱羊冰冰&lt;/span&gt;提供的部分题目及题解。&lt;/p&gt;
&lt;h2 id=&#34;题目一：数圈游戏&#34;&gt;&lt;a href=&#34;#题目一：数圈游戏&#34; class=&#34;headerlink&#34; title=&#34;题目一：数圈游戏&#34;&gt;&lt;/a&gt;题目一：数圈游戏&lt;/h2&gt;&lt;p&gt;给定一个整数n，计算该整数含有的圆圈个数。数字0-9对应的圈数如下：&lt;br&gt;0: 1&lt;br&gt;1: 0&lt;br&gt;2: 0&lt;br&gt;3: 0&lt;br&gt;4: 0&lt;br&gt;5: 0&lt;br&gt;6: 1&lt;br&gt;7: 0&lt;br&gt;8: 2&lt;br&gt;9: 1&lt;/p&gt;
&lt;p&gt;输入：&lt;br&gt;第一行为一个整数n，表示数圈游戏的数字。&lt;/p&gt;
&lt;p&gt;输入示例：&lt;br&gt;60498&lt;br&gt;输出示例：&lt;br&gt;5&lt;/p&gt;
&lt;p&gt;限制：&lt;br&gt;80%的测试用例：n&amp;lt;&amp;#x3D;10000&lt;br&gt;100%的测试用例：n&amp;lt;&amp;#x3D;100000000&lt;/p&gt;
&lt;h3 id=&#34;思路：&#34;&gt;&lt;a href=&#34;#思路：&#34; class=&#34;headerlink&#34; title=&#34;思路：&#34;&gt;&lt;/a&gt;思路：&lt;/h3&gt;&lt;p&gt;该题较为简单，一次遍历累加即可。&lt;/p&gt;
&lt;h2 id=&#34;题目二：士兵排队&#34;&gt;&lt;a href=&#34;#题目二：士兵排队&#34; class=&#34;headerlink&#34; title=&#34;题目二：士兵排队&#34;&gt;&lt;/a&gt;题目二：士兵排队&lt;/h2&gt;&lt;p&gt;给定一定数量的士兵，将士兵按照身高从小到大排列，身高相同者按照姓名的字典序从小到大排列。&lt;/p&gt;
&lt;p&gt;输入：&lt;br&gt;第一行为一个整数n，表示士兵的数量。&lt;br&gt;第二行为n个士兵的身高，单位为cm。&lt;br&gt;第三行为n个士兵的姓名。&lt;/p&gt;
&lt;p&gt;输入示例：&lt;br&gt;4&lt;br&gt;176 170 176 176&lt;br&gt;bamma tom alpha beta&lt;/p&gt;
&lt;p&gt;输出示例：&lt;br&gt;tom alpha bamma beta&lt;/p&gt;
&lt;p&gt;限制：&lt;br&gt;士兵身高 hi &amp;lt;&amp;#x3D; 300&lt;br&gt;士兵姓名长度 ni &amp;lt;&amp;#x3D; 20&lt;/p&gt;
&lt;h3 id=&#34;思路一：&#34;&gt;&lt;a href=&#34;#思路一：&#34; class=&#34;headerlink&#34; title=&#34;思路一：&#34;&gt;&lt;/a&gt;思路一：&lt;/h3&gt;&lt;p&gt;将每一个人的身高和名字按照 (身高，名字) 的格式存储，然后进行两次排序，先按照身高排序，再按照名字排序即可。（利用了python排序算法的稳定性！）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;n = int(input())
heights = list(map(str, input().split()))
names = list(map(str, input().split()))
ls = []
for i in range(n):
    ls.append((heights[i], names[i]))
# lambda函数指定排序规则
ls.sort(key=lambda x:x[1])
ls.sort(key=lambda x:x[0])
for i in range(n):
    print(ls[i][1], end=&amp;#39; &amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;思路二：&#34;&gt;&lt;a href=&#34;#思路二：&#34; class=&#34;headerlink&#34; title=&#34;思路二：&#34;&gt;&lt;/a&gt;思路二：&lt;/h3&gt;&lt;p&gt;因为身高的限制为 hi &amp;lt;&amp;#x3D; 300，所以身高最高只能为三位数，那么我们可以把所有身高都通过补前置零的方式化为三位数，然后再与名字拼接成一个字符串，这样只需要一次排序就能够得出结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;n = int(input())
heights = list(map(str, input().split()))
names = list(map(str, input().split()))
for i in range(n):
    # str.zfill()自动填充
    heights[i] = heights[i].zfill(3) + names[i]
heights.sort()
for i in range(n):
    print(heights[i][3:], end=&amp;#39; &amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;题目三：路径搜索&#34;&gt;&lt;a href=&#34;#题目三：路径搜索&#34; class=&#34;headerlink&#34; title=&#34;题目三：路径搜索&#34;&gt;&lt;/a&gt;题目三：路径搜索&lt;/h2&gt;&lt;p&gt;给定一个地图，询问是否存在一条从起点到终点的直接通路。注意，通路是双向的。&lt;/p&gt;
&lt;p&gt;输入：&lt;br&gt;第一行包括两个整数n和m，分别表示地图上点的数量和通路的数量。&lt;br&gt;第二行包括m个整数，表示地图上通路的一端。&lt;br&gt;第三行包括m个整数，表示地图上通路的另一端。&lt;br&gt;第四行包括k个整数，表示询问的次数。&lt;br&gt;接下来的k行每行包括两个整数，分别表示起点和终点。&lt;/p&gt;
&lt;p&gt;输入示例：&lt;br&gt;4 5&lt;br&gt;1 2 1 3 1&lt;br&gt;2 3 3 4 4&lt;br&gt;4&lt;br&gt;1 3&lt;br&gt;2 4&lt;br&gt;2 1&lt;br&gt;3 2&lt;/p&gt;
&lt;p&gt;输出示例：&lt;br&gt;Yes&lt;br&gt;No&lt;br&gt;Yes&lt;br&gt;Yes&lt;/p&gt;
&lt;h3 id=&#34;思路：-1&#34;&gt;&lt;a href=&#34;#思路：-1&#34; class=&#34;headerlink&#34; title=&#34;思路：&#34;&gt;&lt;/a&gt;思路：&lt;/h3&gt;&lt;p&gt;筱羊冰冰：上来就看错了，然后花了好久写了类似并查集的东西，然后用不上……&lt;br&gt;（果然大佬就是不一样，上来直接手撕并查集）&lt;br&gt;这道题只需要检查有无指定通路就行了，不过要特别注意查询范围，因为通路是双向的而且要求的是直接通路。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;n, m = map(int, input().split())
lsu = list(map(int, input().split()))
lsv = list(map(int, input().split()))
k = int(input())
ways = set((lsu[i], lsv[i]) for i in range(m))
out = []
for _ in range(k):
    u, v = map(int, input().split())
    if (u, v) in ways or (v, u) in ways:
        out.append(&amp;#39;Yes&amp;#39;)
    else:
        out.append(&amp;#39;No&amp;#39;)
print(&amp;#39;\n&amp;#39;.join(out))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;题目四：井字棋&#34;&gt;&lt;a href=&#34;#题目四：井字棋&#34; class=&#34;headerlink&#34; title=&#34;题目四：井字棋&#34;&gt;&lt;/a&gt;题目四：井字棋&lt;/h2&gt;&lt;p&gt;给定一个2x2的棋盘和n中不同的颜色，要求每行每列均不能出现相同的颜色，计算总共有多少种填充方案。&lt;/p&gt;
&lt;p&gt;输入：&lt;br&gt;第一行包括一个整数n，表示颜色的数量。&lt;/p&gt;
&lt;p&gt;输出：&lt;br&gt;输出一个整数，表示有多少种填充方案。&lt;/p&gt;
&lt;p&gt;输入示例：&lt;br&gt;2&lt;/p&gt;
&lt;p&gt;输出示例：&lt;br&gt;2&lt;/p&gt;
&lt;p&gt;限制：&lt;br&gt;颜色的种类n &amp;lt;&amp;#x3D; 10&lt;/p&gt;
&lt;h3 id=&#34;思路：-2&#34;&gt;&lt;a href=&#34;#思路：-2&#34; class=&#34;headerlink&#34; title=&#34;思路：&#34;&gt;&lt;/a&gt;思路：&lt;/h3&gt;&lt;p&gt;筱羊冰冰：有一说一，感觉就属这个题有意思吧。我当时看完，感觉就有一点像排列组合(业余玩家，不太清楚具体的类型)。&lt;br&gt;n种颜色，如果颜色足够(指大于四种)，我们其实也只能取出四种来操作，所以只需要一个&lt;br&gt;$$&lt;br&gt;C_n^4&lt;br&gt;$$&lt;br&gt;所以我们其实只需要考虑四种以内的情况。&lt;/p&gt;
&lt;p&gt;两种颜色：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;和&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;三种颜色：&lt;br&gt;我们自然可以想到，拿两种颜色就可以填上面的两种&lt;br&gt;$$&lt;br&gt;C_3^2 * 2&lt;br&gt;$$&lt;br&gt;然后，如果是三种颜色都要，有12种，肯定是有一个重复的，那么对角线重复就有两种情况，剩下的其实就是将三个数字填入三个位置，&lt;br&gt;$$&lt;br&gt;A_3^3&lt;br&gt;$$&lt;br&gt;就是6 + 6*2 &amp;#x3D; 18。&lt;/p&gt;
&lt;p&gt;到这里其实就应该明白了，我们只需要知道 i 种颜色有多少种即可，因为 i &amp;#x3D; 2, 3, 4，我们完全可以直接写出来，剩下的就是一个组合问题，再给出一个阶乘列表。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# ls[i]为i种颜色都使用，对应的可能数
# 四种颜色忘了说了，不过就是个A44
ls = [0, 0, 2, 12, 24]
# ls_jc[i] = i!
ls_jc = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]
ret = 0
n = int(input())
if n &amp;lt;= 1:
    # 他在系统公告中，提示了0的问题
    ret = 0
elif n &amp;lt;= 4:
    for i in range(2, n+1):
        ret += ls[i] * ls_jc[n] // (ls_jc[i] * ls_jc[n-i])
        # 还有一个限制就是输出大小，这里原题目是有的
        ret %= 1000000007
else:
    for i in range(2, 5):
        ret += ls[i] * ls_jc[n] // (ls_jc[i] * ls_jc[n-i])
        ret %= 1000000007
print(ret)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;小插曲：&#34;&gt;&lt;a href=&#34;#小插曲：&#34; class=&#34;headerlink&#34; title=&#34;小插曲：&#34;&gt;&lt;/a&gt;小插曲：&lt;/h3&gt;&lt;p&gt;当时有一块写错了，然后跑出来只有27%，自己就去看了一下范围是小于等于十，那么案例至少有10个吧。&lt;br&gt;然后自己因为有边界检测，负数、0、1、2都能正确，那么至少对三个，反推出案例应该是11个，那么就是3往上有问题，所以将矛头对准了ls[3]，果然是算少了，改成12，啪的一下，很快就过了……&lt;/p&gt;
&lt;h2 id=&#34;题目五：堆积木&#34;&gt;&lt;a href=&#34;#题目五：堆积木&#34; class=&#34;headerlink&#34; title=&#34;题目五：堆积木&#34;&gt;&lt;/a&gt;题目五：堆积木&lt;/h2&gt;&lt;p&gt;给定一个已有的字符串和一个目标字符串，可以从右边删除一个字符，也可以往左边插入一个字符，删除和插入操作的次数没有限制，问最少操作多少次可以使已有字符串变成目标字符串。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;输入&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;原串长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1 5 3 4 6&lt;/td&gt;
&lt;td&gt;原串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;目标串长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2 1 5 3 4&lt;/td&gt;
&lt;td&gt;目标串&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;思路：-3&#34;&gt;&lt;a href=&#34;#思路：-3&#34; class=&#34;headerlink&#34; title=&#34;思路：&#34;&gt;&lt;/a&gt;思路：&lt;/h3&gt;&lt;p&gt;筱羊冰冰：这个题，其实看明白了就没那么难，其实就是找最长公共子序列。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;from collections import deque
l_old = int(input())
old = input().split()
l_new = int(input())
new = input().split()
length = 0
# 这里没啥原因，就是deque的头插尾插都比较快，O(1)的
s1, s2 = deque(), deque()
judge = 0
while True:
    s1.append(old[length])
    s2.appendleft(new[-length-1])
    length += 1
    if s1 == s2:
        judge = 1
        break
    elif length == min(l_old, l_new):
        break
if judge:
    print(l_old+l_new - length*2)
else:
    print(l_old+l_new)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;重大失误：&#34;&gt;&lt;a href=&#34;#重大失误：&#34; class=&#34;headerlink&#34; title=&#34;重大失误：&#34;&gt;&lt;/a&gt;重大失误：&lt;/h3&gt;&lt;p&gt;上面的代码其实没考虑，如果有多对子串相同，要找出最长的……&lt;br&gt;不过感觉测试案例比较拉，所以显示还是ac了的。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/a8a3d56fb3c843adb83a73a53cb36285.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATUFD44CB5YeJ5qKm,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/CCPP/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</guid>
            <title>学生成绩管理系统</title>
            <link>https://www.liangmeng.xyz/CCPP/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</link>
            <category term="C/CPP语言" scheme="https://www.liangmeng.xyz/categories/CCPP/" />
            <category term="学生成绩管理系统" scheme="https://www.liangmeng.xyz/categories/CCPP/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" />
            <category term="C语言" scheme="https://www.liangmeng.xyz/tags/C%E8%AF%AD%E8%A8%80/" />
            <category term="实验" scheme="https://www.liangmeng.xyz/tags/%E5%AE%9E%E9%AA%8C/" />
            <pubDate>Thu, 07 Apr 2022 14:43:36 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;相信很多同仁在大学学习编程的时候都会被老师要求动手敲出一个学生成绩管理系统或图书馆管理系统之类的程序吧。&lt;br&gt;&lt;strong&gt;不得不说，这个程序简直就是大多数初学者的恶梦，毕竟它的内容涉及到了整一个学期学到的所有知识。&lt;/strong&gt;&lt;br&gt;&lt;del&gt;况且，对于像我这种在大学前从来没接触过编程，也不知道代码是啥的绝对萌新来说，更是一次史诗级的灾难。&lt;/del&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你见过凌晨四点的教学楼吗？&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;我见过，那时候我刚从里面出来。&lt;/strong&gt;&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210325191305561.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;&lt;strong&gt;话不多说，说多了都是泪。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实验要求我就不赘述了吧，无非就是录成绩、各种方式查成绩、名次排序、计算均分等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还是直接上代码吧，大家都是爽快人！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#define N 30
#define M 10
#define X 6

/*学生信息结构体，包括学号，姓名，各学科分数，总分，均分*/
typedef struct student
&amp;#123;
  long number;
  char name[M];
  int score[X];
  int stutotal;
  float stuaverage;
&amp;#125;STUDENT;/*对学生信息结构体取别名“STUDENT”*/

/*实现两个结构体的交换，注意，结构体是可以直接赋值的*/
void Swap(STUDENT *a,STUDENT *b)
&amp;#123;
  STUDENT temp;
  temp=*a;
  *a=*b;
  *b=temp;
&amp;#125;

/*由用户用键盘依次输入学生信息*/
void Input(STUDENT stu[],int n,int x)
&amp;#123;
    printf(&amp;quot;\n\n&amp;quot;);
    int i,j;
    for(i=0;i&amp;lt;n;i++)
    &amp;#123;
        printf(&amp;quot;Number:\t&amp;quot;);
        scanf(&amp;quot;%ld&amp;quot;,&amp;amp;stu[i].number);
        getchar();/*清除缓冲区中的回车字符，防止被读入学生姓名*/
        printf(&amp;quot;Name:\t&amp;quot;);
        gets(stu[i].name);
        for(j=0;j&amp;lt;x;j++)
        &amp;#123;
            do&amp;#123;
                printf(&amp;quot;Score %d:&amp;quot;,j+1);
                scanf(&amp;quot;%d&amp;quot;,&amp;amp;stu[i].score[j]);
            &amp;#125;while(stu[i].score[j]&amp;lt;0||stu[i].score[j]&amp;gt;100);/*防止录入异常成绩*/
        &amp;#125;
    &amp;#125;
&amp;#125;

/*计算各学科的总分和均分*/
void SubCalculate(STUDENT stu[],int subtotal[],float subaverage[],int n,int x)
&amp;#123;
    int i,j;
    for(j=0;j&amp;lt;x;j++)
    &amp;#123;
        subtotal[j]=0;/*学科总成绩初始化为0*/
        for(i=0;i&amp;lt;n;i++)
        &amp;#123;
            subtotal[j]=subtotal[j]+stu[i].score[j];
        &amp;#125;
        subaverage[j]=(float)subtotal[j]/n;/*将整型数强转为浮点数后进行浮点数运算，确保数据的准确性*/
        printf(&amp;quot;(subject %d)Total:%d\t\tAverage:%6.2f\n&amp;quot;,j+1,subtotal[j],subaverage[j]);
    &amp;#125;
 &amp;#125;

/*计算每个学生的总分和均分*/
void StuCalculate(STUDENT stu[],int n,int x)
&amp;#123;
    int i,j;
    for(i=0;i&amp;lt;n;i++)
    &amp;#123;
        stu[i].stutotal=0;/*学生总成绩初始化为0*/
        for(j=0;j&amp;lt;x;j++)
        &amp;#123;
            stu[i].stutotal=stu[i].stutotal+stu[i].score[j];
        &amp;#125;
        stu[i].stuaverage=(float)stu[i].stutotal/x;/*将整型数强转为浮点数后进行浮点数运算，确保数据的准确性*/
        printf(&amp;quot;(student %d)Total:%d\t\tAverage:%6.2f\n&amp;quot;,i+1,stu[i].stutotal,stu[i].stuaverage);
    &amp;#125;
&amp;#125;

/*将学生成绩按从高到低的顺序排列*/
void SortStuScoreUpdown(STUDENT stu[],int n)
&amp;#123;
    for (int i = 0; i &amp;lt; n - 1; ++i)
    &amp;#123;
        for (int j = i + 1; j &amp;lt; n; ++j)
        &amp;#123;
            if (stu[i].stutotal &amp;lt; stu[j].stutotal) Swap(&amp;amp;stu[i], &amp;amp;stu[j]);/*如果前面的学生的总成绩小于后面的学生的总成绩，则交换两个学生信息结构体位置*/
        &amp;#125;
      &amp;#125;
&amp;#125;

/*将学生成绩按从低到高的顺序排列*/
void SortStuScoreDownup(STUDENT stu[],int n)
&amp;#123;
        for (int i = 0; i &amp;lt; n - 1; ++i)
    &amp;#123;
        for (int j = i + 1; j &amp;lt; n; ++j)
        &amp;#123;
            if (stu[i].stutotal &amp;gt; stu[j].stutotal) Swap(&amp;amp;stu[i], &amp;amp;stu[j]);/*如果前面的学生的总成绩大于后面的学生的总成绩，则交换两个学生信息结构体位置*/
        &amp;#125;
      &amp;#125;
&amp;#125;

/*将学生学号按从小到大排列*/
void SortNumberDownup(STUDENT stu[],int n)
&amp;#123;
        for (int i = 0; i &amp;lt; n - 1; ++i)
    &amp;#123;
        for (int j = i + 1; j &amp;lt; n; ++j)
        &amp;#123;
            if (stu[i].number &amp;gt; stu[j].number) Swap(&amp;amp;stu[i], &amp;amp;stu[j]);/*如果前面的学生的学号大于后面的学生的学号，则交换两个学生信息结构体位置*/
        &amp;#125;
      &amp;#125;
&amp;#125;

/*将学生姓名按字典顺序排列*/
void SortName(STUDENT stu[],int n)
&amp;#123;
    for (int i = 0; i &amp;lt; n - 1; ++i)
    &amp;#123;
        for (int j = i + 1; j &amp;lt; n; ++j)
        &amp;#123;
            if (strcmp(stu[i].name,stu[j].name)&amp;gt;0) Swap(&amp;amp;stu[i], &amp;amp;stu[j]);/*如果前面的学生的字母序位大于后面的学生的字母序位，则交换两个学生信息结构体位置*/
        &amp;#125;
      &amp;#125;
&amp;#125;

/*按学号查找学生并输出学生信息*/
void SearchNumber(STUDENT stu[],int n,int x)
&amp;#123;
    int i,j,flag=0;/*未找到学生时flag初始化为0*/
    long temp;
    printf(&amp;quot;Input the number:\t&amp;quot;);
    scanf(&amp;quot;%ld&amp;quot;,&amp;amp;temp);
    getchar();
    SortStuScoreUpdown(stu,n);/*将学生按照成绩从高到低排序以获得学生的排名情况*/
    for(i=0;i&amp;lt;n;i++)/*将录入的学生学号与待查学号进行一一比对*/
    &amp;#123;
        if(stu[i].number==temp)/*找到与待查学号一致的学号*/
        &amp;#123;
            flag=1;/*找到学号对应的学生时，flag被赋值为1*/
            printf(&amp;quot;Name:     \tNumber:      \tPosition:\tTotalscore:\tAveragescore:\t  Subjectscores:\n&amp;quot;);
            printf(&amp;quot;%-10s\t%-13ld\t%9d\t%11d\t%13.2f\t&amp;quot;,stu[i].name,stu[i].number,i+1,stu[i].stutotal,stu[i].stuaverage);
            for(j=0;j&amp;lt;x;j++)
            &amp;#123;
                printf(&amp;quot;%4d&amp;quot;,stu[i].score[j]);
            &amp;#125;
            printf(&amp;quot;\n&amp;quot;);
            break;
        &amp;#125;
    &amp;#125;
    if(flag==0)/*未找到学号对应学生时，flag的值仍为0*/
    &amp;#123;
        printf(&amp;quot;\nNot find!\n&amp;quot;);
    &amp;#125;
&amp;#125;

/*按姓名查找学生并输出学生信息*/
void SearchName(STUDENT stu[],int n,int x)
&amp;#123;
    int i,j,flag=0;/*未找到学生时flag初始化为0*/
    char tep[M];
    printf(&amp;quot;Input the name:\t&amp;quot;);
  scanf(&amp;quot; %s&amp;quot;,tep);
    SortStuScoreUpdown(stu,n);/*将学生按照成绩从高到低排序以获得学生的排名情况*/
    for(i=0;i&amp;lt;n;i++)/*将录入的学生姓名与待查姓名进行一一比对*/
    &amp;#123;
        if(strcmp(stu[i].name,tep)==0)/*找到与待查姓名字母顺序完全一致的姓名*/
        &amp;#123;
            flag=1;/*找到学号对应的学生时，flag被赋值为1*/
            printf(&amp;quot;Name:     \tNumber:      \tPosition:\tTotalscore:\tAveragescore:\t  Subjectscores:\n&amp;quot;);
            printf(&amp;quot;%-10s\t%-13ld\t%9d\t%11d\t%13.2f\t&amp;quot;,stu[i].name,stu[i].number,i+1,stu[i].stutotal,stu[i].stuaverage);
            for(j=0;j&amp;lt;x;j++)
            &amp;#123;
                printf(&amp;quot;%4d&amp;quot;,stu[i].score[j]);
            &amp;#125;
            printf(&amp;quot;\n&amp;quot;);
            break;
        &amp;#125;
    &amp;#125;
    if(flag==0)/*未找到学号对应学生时，flag的值仍为0*/
    &amp;#123;
        printf(&amp;quot;\nNot find!\n&amp;quot;);
    &amp;#125;
&amp;#125;

/*统计并打印出各学科各阶段人数及占比*/
void Analysis(STUDENT stu[],int n,int x)
&amp;#123;
    int a[N]=&amp;#123;0&amp;#125;,b[N]=&amp;#123;0&amp;#125;,c[N]=&amp;#123;0&amp;#125;,d[N]=&amp;#123;0&amp;#125;,e[N]=&amp;#123;0&amp;#125;;
    int i,j;
    for(j=0;j&amp;lt;x;j++)
    &amp;#123;
        for(i=0;i&amp;lt;n;i++)
        &amp;#123;
            if    (100&amp;gt;=stu[i].score[j]&amp;amp;&amp;amp;90&amp;lt;=stu[i].score[j])    a[j]++;
            else if(89&amp;gt;=stu[i].score[j]&amp;amp;&amp;amp;80&amp;lt;=stu[i].score[j])    b[j]++;
            else if(79&amp;gt;=stu[i].score[j]&amp;amp;&amp;amp;70&amp;lt;=stu[i].score[j])    c[j]++;
            else if(69&amp;gt;=stu[i].score[j]&amp;amp;&amp;amp;60&amp;lt;=stu[i].score[j])    d[j]++;
            else                                                           e[j]++;
        &amp;#125;
    &amp;#125;
    for(j=0;j&amp;lt;x;j++)
    &amp;#123;
        printf(&amp;quot;Subject No.%d:\n&amp;quot;,j+1);
        printf(&amp;quot;Excellent:%d\tpercent:%.2f%%\n&amp;quot;,a[j],(float)100*a[j]/n);
        printf(&amp;quot;Good:     %d\tpercent:%.2f%%\n&amp;quot;,b[j],(float)100*b[j]/n);
        printf(&amp;quot;Medium:   %d\tpercent:%.2f%%\n&amp;quot;,c[j],(float)100*c[j]/n);
        printf(&amp;quot;Pass:     %d\tpercent:%.2f%%\n&amp;quot;,d[j],(float)100*d[j]/n);
        printf(&amp;quot;Failed:   %d\tpercent:%.2f%%\n&amp;quot;,e[j],(float)100*e[j]/n);
        printf(&amp;quot;\n&amp;quot;);
    &amp;#125;
    printf(&amp;quot;\n&amp;quot;);
&amp;#125;

/*输出各学生的学生信息及各课程的总分和均分*/
void List(STUDENT stu[],int subtotal[],float subaverage[],int n,int x)
&amp;#123;
    int i,j;
    printf(&amp;quot;Name:     \tNumber:      \tTotalscore:\tAveragescore:\tSub 1:Sub 2:Sub 3:Sub 4:Sub 5:Sub 6:\n&amp;quot;);
    for(i=0;i&amp;lt;n;i++)
    &amp;#123;
        printf(&amp;quot;%-10s\t%-13ld\t%11d\t%13.2f\t&amp;quot;,stu[i].name,stu[i].number,stu[i].stutotal,stu[i].stuaverage);
        for(j=0;j&amp;lt;x;j++)
        &amp;#123;
            printf(&amp;quot;%6d&amp;quot;,stu[i].score[j]);
        &amp;#125;
        printf(&amp;quot;\n&amp;quot;);
    &amp;#125;
     printf(&amp;quot;          \t             \t           \t           \t&amp;quot;);
     for(j=0;j&amp;lt;x;j++)
     &amp;#123;
      printf(&amp;quot;%6d&amp;quot;,subtotal[j]);
     &amp;#125;
      printf(&amp;quot;\n&amp;quot;);
      printf(&amp;quot;         \t             \t           \t          \t&amp;quot;);
      for(j=0;j&amp;lt;x;j++)
      &amp;#123;
          printf(&amp;quot;%6.2f&amp;quot;,subaverage[j]);
      &amp;#125;
&amp;#125;

/*打印姓名，学号，总分，均分及各学科的分数*/
void Print1(STUDENT stu[],int n,int x)
&amp;#123;
    int i,j;
    printf(&amp;quot;Name:     \tNumber:\t      Totalscore:\tAveragescore:\tSubjectscore:\n&amp;quot;);
    for(i=0;i&amp;lt;n;i++)
    &amp;#123;
        printf(&amp;quot;%-10s\t%-13ld\t%9d\t%13.2f\t&amp;quot;,stu[i].name,stu[i].number,stu[i].stutotal,stu[i].stuaverage);
        for(j=0;j&amp;lt;x;j++)
        &amp;#123;
            printf(&amp;quot;%-6d&amp;quot;,stu[i].score[j]);
        &amp;#125;
        printf(&amp;quot;\n&amp;quot;);
    &amp;#125;
&amp;#125;

/*打印各课程的总分和均分*/
void Print2(int subtotal[],float subaverage[],int x)
&amp;#123;
  int i;
  for(i=0;i&amp;lt;x;i++)
  &amp;#123;
    printf(&amp;quot;subtotal No.%d: %-6d\tsubaverage No.%d: %-6.2f\n&amp;quot;,i+1,subtotal[i],i+1,subaverage[i]);
  &amp;#125;
&amp;#125;

/*将信息写入文件并保存*/
void WritetoFile(STUDENT stu[],int subtotal[],float subaverage[],int n,int x)
&amp;#123;
  FILE *fp;
  int i,j;
  if((fp=fopen(&amp;quot;score.txt&amp;quot;,&amp;quot;w&amp;quot;))==NULL)/*检验文件是否打开成功*/
  &amp;#123;
    printf(&amp;quot;Failure to open score.txt!\n&amp;quot;);
    exit(0);
  &amp;#125;
  fprintf(fp,&amp;quot;%d\t%d\n&amp;quot;,n,x);
  for(i=0;i&amp;lt;n;i++)
  &amp;#123;
    fprintf(fp,&amp;quot;%-10s\t%-13ld\t%11d\t%13.2f\t&amp;quot;,stu[i].name,stu[i].number,stu[i].stutotal,stu[i].stuaverage);
     for(j=0;j&amp;lt;x;j++)
        &amp;#123;
            fprintf(fp,&amp;quot;%-6d\n&amp;quot;,stu[i].score[j]);
        &amp;#125;
  &amp;#125;
  for(j=0;j&amp;lt;x;j++)
  &amp;#123;
      fprintf(fp,&amp;quot;%d\t%f\n&amp;quot;,subtotal[j],subaverage[j]);
  &amp;#125;
  fclose(fp);
&amp;#125;

/*从文件中读取出信息*/
void ReadfromFile(STUDENT stu[],int subtotal[],float subaverage[],int *n,int *x)
&amp;#123;
  FILE *fp;
  int i,j;
  if((fp=fopen(&amp;quot;score.txt&amp;quot;,&amp;quot;r&amp;quot;))==NULL)/*检验文件是否打开成功*/
  &amp;#123;
    printf(&amp;quot;Failure to open score.txt!\n&amp;quot;);
    exit(0);
  &amp;#125;
   fscanf(fp,&amp;quot;%d\t%d\n&amp;quot;,n,x);
  for(i=0;i&amp;lt;*n;i++)
    &amp;#123;
      fscanf(fp,&amp;quot;%10s&amp;quot;,stu[i].name);
      fscanf(fp,&amp;quot;%13ld&amp;quot;,&amp;amp;stu[i].number);
      fscanf(fp,&amp;quot;%11d&amp;quot;,&amp;amp;stu[i].stutotal);
      fscanf(fp,&amp;quot;%f&amp;quot;,&amp;amp;stu[i].stuaverage);
      for(j=0;j&amp;lt;*x;j++)
      &amp;#123;
        fscanf(fp,&amp;quot;%6d&amp;quot;,&amp;amp;stu[i].score[j]);
      &amp;#125;
    &amp;#125;
    for(j=0;j&amp;lt;*x;j++)
    &amp;#123;
        fscanf(fp,&amp;quot;%d\t%f&amp;quot;,&amp;amp;subtotal[j],&amp;amp;subaverage[j]);
    &amp;#125;
    fclose(fp);
&amp;#125;

int main()
&amp;#123;
    int m,n,x;
    int subtotal[X];
    float subaverage[X];
    STUDENT stu[N];
    do&amp;#123;
        printf(&amp;quot;Input the total number of students:&amp;quot;);
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
        printf(&amp;quot;Input the total number of subjects:&amp;quot;);
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
    &amp;#125;while(n&amp;lt;=0||n&amp;gt;30||x&amp;lt;1||x&amp;gt;6);/*检测学生总人数及学科总数是否符合要求*/
 KG:printf(&amp;quot;\n\n1.Input record\n2.Calculate total and average score of every course\n3.Calculate total and average score of every student\n&amp;quot;);
      printf(&amp;quot;4.Sort in descending order by total score of every student\n5.Sort in ascending order by total score of every student\n&amp;quot;);
      printf(&amp;quot;6.Sort in ascending order by number\n7.Sort in dictionary order by name\n8.Search by number\n&amp;quot;);
      printf(&amp;quot;9.Search by name\n10.Statistic analysis for every course\n11.List record\n&amp;quot;);
      printf(&amp;quot;12.Write to a file\n13.Read from a file\n0.Exit\n\nPlease enter your choice:&amp;quot;);
      scanf(&amp;quot;%d&amp;quot;,&amp;amp;m);/*打印出菜单栏以供用户选择操作*/
    switch(m)/*利用switch语句实现菜单中的各个功能*/
    &amp;#123;
      case 1: Input(stu,n,x);
               break;
      case 2: SubCalculate(stu,subtotal,subaverage,n,x);
               break;
      case 3:StuCalculate(stu,n,x);
               break;
      case 4: SortStuScoreUpdown(stu,n);
               Print1(stu,n,x);
              break;
      case 5: SortStuScoreDownup(stu,n);
              Print1(stu,n,x);
             break;
      case 6: SortNumberDownup(stu,n);
              Print1(stu,n,x);
            break;
      case 7: SortName(stu,n);
              Print1(stu,n,x);
            break;
      case 8: SearchNumber(stu,n,x);
            break;
      case 9: SearchName(stu,n,x);
            break;
      case 10: Analysis(stu,n,x);
            break;
      case 11: List(stu,subtotal,subaverage,n,x);
            break;
      case 12:WritetoFile(stu,subtotal,subaverage,n,x);
            break;
      case 13:ReadfromFile(stu,subtotal,subaverage,&amp;amp;n,&amp;amp;x);
                Print1(stu,n,x);
                Print2(subtotal,subaverage,x);
            break;
      case 0: exit(0);
    &amp;#125;
   if(m!=0||m&amp;lt;0||m&amp;gt;13) goto KG;/*检测用户选择是否出错，并利用goto语句实现跳转*/
   return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上就是该实验的全部代码。（&lt;del&gt;毫无保留，直接裸奔！！！&lt;/del&gt; ）&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210325193106921.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;实验数据我就不给了吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本人王者荣耀迷和KPL迷，实验数据全是英雄名和选手名（说实话，选手们的ID确实好听），估计助教在看实验的时候都笑出猪叫了。（&lt;del&gt;助教笑出猪叫？？？&lt;/del&gt; 啪，又来套娃！）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有相同兴趣的小伙伴们可以找我一起观赛掉分。&lt;del&gt;本人厨艺精湛，饭多管饱！！！&lt;/del&gt; &lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210325194414574.jpg#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;敲黑板！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果大佬们不幸看了我的代码，欢迎指导！！！（毕竟这时大一刚学的时候写的，估计bug一堆，很多代码也不是最优的）&lt;br&gt;如果萌新们不幸看了我的代码，欢迎交流！！！（如果你也备受这个实验困扰，希望这篇文章能够帮助到你）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后，有被学生成绩管理系统和图书馆管理系统折磨过的同仁，举个爪子示意一下，让我知道我并不孤单！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/2021032519443410.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/Hello-MyWorld/hello-world/</guid>
            <title>欢迎来到我的世界</title>
            <link>https://www.liangmeng.xyz/Hello-MyWorld/hello-world/</link>
            <category term="我的世界" scheme="https://www.liangmeng.xyz/categories/Hello-MyWorld/" />
            <category term="欢迎来到我的世界" scheme="https://www.liangmeng.xyz/categories/Hello-MyWorld/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C/" />
            <category term="helloWorld" scheme="https://www.liangmeng.xyz/tags/helloWorld/" />
            <pubDate>Wed, 06 Apr 2022 22:56:44 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;Welcome to &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvLw==&#34;&gt;Hexo&lt;/span&gt;! This is your very first post. Check &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv&#34;&gt;documentation&lt;/span&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=&#34;&gt;troubleshooting&lt;/span&gt; or you can ask me on &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==&#34;&gt;GitHub&lt;/span&gt;.&lt;/p&gt;
&lt;h2 id=&#34;Quick-Start&#34;&gt;&lt;a href=&#34;#Quick-Start&#34; class=&#34;headerlink&#34; title=&#34;Quick Start&#34;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&#34;Create-a-new-post&#34;&gt;&lt;a href=&#34;#Create-a-new-post&#34; class=&#34;headerlink&#34; title=&#34;Create a new post&#34;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;$ hexo new &amp;quot;My New Post&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;More info: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s&#34;&gt;Writing&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;Run-server&#34;&gt;&lt;a href=&#34;#Run-server&#34; class=&#34;headerlink&#34; title=&#34;Run server&#34;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;$ hexo server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;More info: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=&#34;&gt;Server&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;Generate-static-files&#34;&gt;&lt;a href=&#34;#Generate-static-files&#34; class=&#34;headerlink&#34; title=&#34;Generate static files&#34;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;$ hexo generate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;More info: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s&#34;&gt;Generating&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;Deploy-to-remote-sites&#34;&gt;&lt;a href=&#34;#Deploy-to-remote-sites&#34; class=&#34;headerlink&#34; title=&#34;Deploy to remote sites&#34;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;$ hexo deploy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;More info: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s&#34;&gt;Deployment&lt;/span&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/LeetCode/%E5%89%91%E6%8C%87Offer/53-II/</guid>
            <title>53-II</title>
            <link>https://www.liangmeng.xyz/LeetCode/%E5%89%91%E6%8C%87Offer/53-II/</link>
            <category term="力扣题库" scheme="https://www.liangmeng.xyz/categories/LeetCode/" />
            <category term="剑指0ffer" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E5%89%91%E6%8C%870ffer/" />
            <category term="53-II" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E5%89%91%E6%8C%870ffer/53-II/" />
            <pubDate>Mon, 07 Jun 2021 21:15:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;题目简述&#34;&gt;&lt;a href=&#34;#题目简述&#34; class=&#34;headerlink&#34; title=&#34;题目简述&#34;&gt;&lt;/a&gt;题目简述&lt;/h2&gt;&lt;p&gt;一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。&lt;/p&gt;
&lt;h2 id=&#34;题解示例&#34;&gt;&lt;a href=&#34;#题解示例&#34; class=&#34;headerlink&#34; title=&#34;题解示例&#34;&gt;&lt;/a&gt;题解示例&lt;/h2&gt;&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: [0,1,3]&lt;br&gt;输出: 2&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: [0,1,2,3,4,5,6,7,9]&lt;br&gt;输出: 8&lt;/p&gt;
&lt;h2 id=&#34;数据范围&#34;&gt;&lt;a href=&#34;#数据范围&#34; class=&#34;headerlink&#34; title=&#34;数据范围&#34;&gt;&lt;/a&gt;数据范围&lt;/h2&gt;&lt;p&gt;1 &amp;lt;&amp;#x3D; 数组长度 &amp;lt;&amp;#x3D; 10000&lt;/p&gt;
&lt;h2 id=&#34;标记难度&#34;&gt;&lt;a href=&#34;#标记难度&#34; class=&#34;headerlink&#34; title=&#34;标记难度&#34;&gt;&lt;/a&gt;标记难度&lt;/h2&gt;&lt;p&gt;通过次数：126,612&lt;br&gt;提交次数：284,562&lt;br&gt;通过率：44.5%&lt;/p&gt;
&lt;h2 id=&#34;问题简析&#34;&gt;&lt;a href=&#34;#问题简析&#34; class=&#34;headerlink&#34; title=&#34;问题简析&#34;&gt;&lt;/a&gt;问题简析&lt;/h2&gt;&lt;p&gt;对该数组进行&lt;strong&gt;二分查找&lt;/strong&gt;即可。&lt;br&gt;若计算得到的中值与数组中值相等，则缺失的数字在右区间中；&lt;br&gt;若计算得到的中值与数组中值不相等，则缺失的数字在左区间中；&lt;/p&gt;
&lt;p&gt;最简单的方法便是遍历数组，如此则未能将&lt;strong&gt;数组有序&lt;/strong&gt;的条件合理利用，其时间复杂度也相对较大。&lt;/p&gt;
&lt;h2 id=&#34;python3代码&#34;&gt;&lt;a href=&#34;#python3代码&#34; class=&#34;headerlink&#34; title=&#34;python3代码&#34;&gt;&lt;/a&gt;python3代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class Solution:
    def missingNumber(self, nums: List[int]) -&amp;gt; int:
        i, j = 0, len(nums)-1     
        while i &amp;lt;= j:
            mid = (i+j) // 2
            if nums[mid] == mid:
                i = mid+1
            else:
                j = mid-1
        return i
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;C语言代码&#34;&gt;&lt;a href=&#34;#C语言代码&#34; class=&#34;headerlink&#34; title=&#34;C语言代码&#34;&gt;&lt;/a&gt;C语言代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;int missingNumber(int* nums, int numsSize)&amp;#123;
    int left = 0, right = numsSize-1, mid;
    while (left &amp;lt;= right) 
    &amp;#123;
        mid = left + (right - left) / 2;
        if (nums[mid] != mid) 
        &amp;#123;
            right = mid - 1;
        &amp;#125; 
        else
        &amp;#123;
            left = mid + 1;
        &amp;#125;
    &amp;#125;
    return left;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;C-代码（Copy）&#34;&gt;&lt;a href=&#34;#C-代码（Copy）&#34; class=&#34;headerlink&#34; title=&#34;C++代码（Copy）&#34;&gt;&lt;/a&gt;C++代码（Copy）&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;class Solution &amp;#123;
public:
    int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
        int left = 0, right = nums.size() - 1;

        while (left &amp;lt;= right)
        &amp;#123;
            int mid = (left + right) &amp;gt;&amp;gt; 1;
            if (nums[mid] == mid) left = mid + 1;
            else right = mid - 1;
        &amp;#125;

        return left;    //注意最后left不等于right，只能返回left
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;大佬专属代码&#34;&gt;&lt;a href=&#34;#大佬专属代码&#34; class=&#34;headerlink&#34; title=&#34;大佬专属代码&#34;&gt;&lt;/a&gt;大佬专属代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;return (len(nums)+1)*len(nums)/2 -sum(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;敲黑板！！！&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;有序数组二分法！！！有序数组二分法！！！有序数组二分法！！！（重要的事情说三遍）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210607210749915.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/11-%E6%9C%9F%E6%9C%9B%E4%B8%AA%E6%95%B0%E7%BB%9F%E8%AE%A1/</guid>
            <title>11-期望个数统计</title>
            <link>https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/11-%E6%9C%9F%E6%9C%9B%E4%B8%AA%E6%95%B0%E7%BB%9F%E8%AE%A1/</link>
            <category term="力扣题库" scheme="https://www.liangmeng.xyz/categories/LeetCode/" />
            <category term="难度简单" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/" />
            <category term="期望个数统计" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/%E6%9C%9F%E6%9C%9B%E4%B8%AA%E6%95%B0%E7%BB%9F%E8%AE%A1/" />
            <pubDate>Sun, 06 Jun 2021 17:16:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;题目简述&#34;&gt;&lt;a href=&#34;#题目简述&#34; class=&#34;headerlink&#34; title=&#34;题目简述&#34;&gt;&lt;/a&gt;题目简述&lt;/h2&gt;&lt;p&gt;某互联网公司一年一度的春招开始了，一共有 n 名面试者入选。每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。&lt;/p&gt;
&lt;p&gt;小 A 和小 B 负责审核面试者，他们均有所有面试者的简历，并且将各自根据面试者能力值从大到小的顺序浏览。由于简历事先被打乱过，能力值相同的简历的出现顺序是从它们的全排列中等可能地取一个。现在给定 n 名面试者的能力值 scores，设 X 代表小 A 和小 B 的浏览顺序中出现在同一位置的简历数，求 X 的期望。&lt;/p&gt;
&lt;p&gt;提示：离散的非负随机变量的期望计算公式为   E(X) &amp;#x3D; Σ(k&amp;#x3D;1, ∞) kPr(X &amp;#x3D; k)。在本题中，由于 X 的取值为 0 到 n 之间，期望计算公式可以是E(X) &amp;#x3D; Σ(k&amp;#x3D;1, n) kPr(X &amp;#x3D; k)。&lt;/p&gt;
&lt;h2 id=&#34;题解示例&#34;&gt;&lt;a href=&#34;#题解示例&#34; class=&#34;headerlink&#34; title=&#34;题解示例&#34;&gt;&lt;/a&gt;题解示例&lt;/h2&gt;&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：scores &amp;#x3D; [1,2,3]&lt;/p&gt;
&lt;p&gt;输出：3&lt;/p&gt;
&lt;p&gt;解释：由于面试者能力值互不相同，小 A 和小 B 的浏览顺序一定是相同的。X的期望是 3 。&lt;/p&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入：scores &amp;#x3D; [1,1]&lt;/p&gt;
&lt;p&gt;输出：1&lt;/p&gt;
&lt;p&gt;解释：设两位面试者的编号为 0, 1。由于他们的能力值都是 1，小 A 和小 B 的浏览顺序都为从全排列 [[0,1],[1,0]] 中等可能地取一个。如果小 A 和小 B 的浏览顺序都是 [0,1] 或者 [1,0] ，那么出现在同一位置的简历数为 2 ，否则是 0 。所以 X 的期望是 (2+0+2+0) * 1&amp;#x2F;4 &amp;#x3D; 1&lt;/p&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;p&gt;输入：scores &amp;#x3D; [1,1,2]&lt;/p&gt;
&lt;p&gt;输出：2&lt;/p&gt;
&lt;h2 id=&#34;数据范围&#34;&gt;&lt;a href=&#34;#数据范围&#34; class=&#34;headerlink&#34; title=&#34;数据范围&#34;&gt;&lt;/a&gt;数据范围&lt;/h2&gt;&lt;p&gt;1 &amp;lt;&amp;#x3D; scores.length &amp;lt;&amp;#x3D; 10^5&lt;br&gt;0 &amp;lt;&amp;#x3D; scores[i] &amp;lt;&amp;#x3D; 10^6&lt;/p&gt;
&lt;h2 id=&#34;标记难度&#34;&gt;&lt;a href=&#34;#标记难度&#34; class=&#34;headerlink&#34; title=&#34;标记难度&#34;&gt;&lt;/a&gt;标记难度&lt;/h2&gt;&lt;p&gt;难度：简单&lt;br&gt;通过次数：6051&lt;br&gt;提交次数：8963&lt;br&gt;通过率：67.5%&lt;/p&gt;
&lt;h2 id=&#34;问题解析&#34;&gt;&lt;a href=&#34;#问题解析&#34; class=&#34;headerlink&#34; title=&#34;问题解析&#34;&gt;&lt;/a&gt;问题解析&lt;/h2&gt;&lt;p&gt;数组中的元素可以分为两种：单元素和多元素。&lt;/p&gt;
&lt;p&gt;对于单元素，由于两位面试官都是根据能力值从大到小的顺序浏览，假设数组元素按数值非递c增的顺序排列，那么其在数组中的顺序一定是相同的，即单元素在两位面试官的浏览顺序中一定是出现在同一位置的，则单元素的数学期望为1。&lt;/p&gt;
&lt;p&gt;对于多元素，假设该元素出现m次，编号为0，1，2，…，m-1。假设m &amp;#x3D; 3，则全排列有如下6种情况：（0,1,2），（0,2,1），（1,0,2），（1,2,0），（2,0,1），（2,1,0），现两个面试官分别从六种顺序里挑选一种，易知每个位置编号相同的概率均为1&amp;#x2F;3，那么可以得出两位面试官在同一位置选取同一元素的概率为1&amp;#x2F;n，则多元素的数学期望为1&amp;#x2F;n × n &amp;#x3D; 1。&lt;/p&gt;
&lt;p&gt;可以得出，无论是单元素还是多元素，其数学期望均为1，即整个数组的数学期望等于数组中数值不同的元素的个数和。&lt;/p&gt;
&lt;h2 id=&#34;python3代码&#34;&gt;&lt;a href=&#34;#python3代码&#34; class=&#34;headerlink&#34; title=&#34;python3代码&#34;&gt;&lt;/a&gt;python3代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class Solution:
    def expectNumber(self, scores: List[int]) -&amp;gt; int:
        return len(set(scores))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;C语言代码&#34;&gt;&lt;a href=&#34;#C语言代码&#34; class=&#34;headerlink&#34; title=&#34;C语言代码&#34;&gt;&lt;/a&gt;C语言代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;int expectNumber(int* scores, int scoresSize)&amp;#123;
    int hash[1000000] = &amp;#123;0&amp;#125;;
    int result = 0;
    for (int i = 0; i &amp;lt; scoresSize; ++i) &amp;#123;
        if (hash[scores[i]] == 0) &amp;#123;
            hash[scores[i]]++;
            result++;
        &amp;#125;
    &amp;#125;
    return result;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;C-代码&#34;&gt;&lt;a href=&#34;#C-代码&#34; class=&#34;headerlink&#34; title=&#34;C++代码&#34;&gt;&lt;/a&gt;C++代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;class Solution &amp;#123;
public:
    int expectNumber(vector&amp;lt;int&amp;gt;&amp;amp; scores) &amp;#123;
        return set&amp;lt;int&amp;gt;(scores.begin(), scores.end()).size();
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;大佬专属代码&#34;&gt;&lt;a href=&#34;#大佬专属代码&#34; class=&#34;headerlink&#34; title=&#34;大佬专属代码&#34;&gt;&lt;/a&gt;大佬专属代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 暂时没看到任何“出类拔萃”的代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;敲黑板！！！&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;这道题关键在于看懂题目，只能说：概率论yyds！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210606171417228.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E4%B8%AD%E7%AD%89/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</guid>
            <title>54-螺旋矩阵</title>
            <link>https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E4%B8%AD%E7%AD%89/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</link>
            <category term="力扣题库" scheme="https://www.liangmeng.xyz/categories/LeetCode/" />
            <category term="难度中等" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E9%9A%BE%E5%BA%A6%E4%B8%AD%E7%AD%89/" />
            <category term="螺旋矩阵" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E9%9A%BE%E5%BA%A6%E4%B8%AD%E7%AD%89/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/" />
            <pubDate>Fri, 04 Jun 2021 17:34:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;题目简述&#34;&gt;&lt;a href=&#34;#题目简述&#34; class=&#34;headerlink&#34; title=&#34;题目简述&#34;&gt;&lt;/a&gt;题目简述&lt;/h2&gt;&lt;p&gt;给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。&lt;/p&gt;
&lt;h2 id=&#34;题解示例&#34;&gt;&lt;a href=&#34;#题解示例&#34; class=&#34;headerlink&#34; title=&#34;题解示例&#34;&gt;&lt;/a&gt;题解示例&lt;/h2&gt;&lt;p&gt;示例 1：&lt;br&gt;输入：matrix &amp;#x3D; [[1,2,3],[4,5,6],[7,8,9]]&lt;br&gt;输出：[1,2,3,6,9,8,7,4,5]&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210604152606550.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;示例 2：&lt;br&gt;输入：matrix &amp;#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]&lt;br&gt;输出：[1,2,3,4,8,12,11,10,9,5,6,7]&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210604152628828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据范围&#34;&gt;&lt;a href=&#34;#数据范围&#34; class=&#34;headerlink&#34; title=&#34;数据范围&#34;&gt;&lt;/a&gt;数据范围&lt;/h2&gt;&lt;p&gt;m &amp;#x3D; matrix.length&lt;br&gt;n &amp;#x3D; matrix[i].length&lt;br&gt;1 &amp;lt;&amp;#x3D; m, n &amp;lt;&amp;#x3D; 10&lt;br&gt;-100 &amp;lt;&amp;#x3D; matrix[i][j] &amp;lt;&amp;#x3D; 100&lt;/p&gt;
&lt;h2 id=&#34;标记难度&#34;&gt;&lt;a href=&#34;#标记难度&#34; class=&#34;headerlink&#34; title=&#34;标记难度&#34;&gt;&lt;/a&gt;标记难度&lt;/h2&gt;&lt;p&gt;难度：中等&lt;br&gt;通过次数：158025&lt;br&gt;提交次数：335,777&lt;br&gt;通过率：47.1%&lt;/p&gt;
&lt;h2 id=&#34;问题解析&#34;&gt;&lt;a href=&#34;#问题解析&#34; class=&#34;headerlink&#34; title=&#34;问题解析&#34;&gt;&lt;/a&gt;问题解析&lt;/h2&gt;&lt;p&gt;本题主要考察矩阵的遍历，还涉及到递归、矩阵转置等知识。&lt;/p&gt;
&lt;p&gt;最直观的方法就是按圈遍历矩阵，从外到里一圈一圈遍历，即先遍历矩阵的最外圈，然后递归地遍历其子矩阵的最外圈。要注意的是，单行或单列需要特殊处理。&lt;/p&gt;
&lt;h2 id=&#34;python3代码&#34;&gt;&lt;a href=&#34;#python3代码&#34; class=&#34;headerlink&#34; title=&#34;python3代码&#34;&gt;&lt;/a&gt;python3代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class Solution(object):
    def spiralOrder(self, matrix: List[List[int]]) -&amp;gt; List[int]: 
        row, col = len(matrix), len(matrix[0])
        def getOutermostCircle(row_start, row_end, col_start, col_end): 
            if row_start &amp;gt; row_end or col_start &amp;gt; col_end:# 防错
                return []
            elif row_start == row_end: #单行
                circle = []
                for j in range(col_start, col_end+1): # 上边
                    circle.append(matrix[row_start][j])
                return circle
                # return matrix[row_start][col_start:col_end+1]
            elif col_start == col_end: #单列
                circle = []
                for i in range(row_start, row_end+1):
                    circle.append(matrix[i][col_start])
                return circle
            else: # 多行多列
                circle = []
                for j in range(col_start, col_end+1): # 上边
                    circle.append(matrix[row_start][j])
                    # circle.extend(matrix[row_start][col_start:col_end+1])
                for i in range(row_start+1, row_end): # 右边
                    circle.append(matrix[i][col_end])
                for j in range(col_end, col_start-1, -1): # 下边
                    circle.append(matrix[row_end][j])
                    # circle.extend(reversed(matrix[row_end][col_start:col_end+1]))
                for i in range(row_end-1, row_start, -1): # 左边
                    circle.append(matrix[i][col_start])
                return circle + getOutermostCircle(row_start+1, row_end-1, col_start+1, col_end-1) # 拼接

        return getOutermostCircle(0, row-1, 0, col-1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;C语言代码（官方）&#34;&gt;&lt;a href=&#34;#C语言代码（官方）&#34; class=&#34;headerlink&#34; title=&#34;C语言代码（官方）&#34;&gt;&lt;/a&gt;C语言代码（官方）&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) &amp;#123;
    if (matrixSize == 0 || matrixColSize[0] == 0) &amp;#123;
        *returnSize = 0;
        return NULL;
    &amp;#125;

    int rows = matrixSize, columns = matrixColSize[0];
    int total = rows * columns;
    int* order = malloc(sizeof(int) * total);
    *returnSize = 0;

    int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
    while (left &amp;lt;= right &amp;amp;&amp;amp; top &amp;lt;= bottom) &amp;#123;
        for (int column = left; column &amp;lt;= right; column++) &amp;#123;
            order[(*returnSize)++] = matrix[top][column];
        &amp;#125;
        for (int row = top + 1; row &amp;lt;= bottom; row++) &amp;#123;
            order[(*returnSize)++] = matrix[row][right];
        &amp;#125;
        if (left &amp;lt; right &amp;amp;&amp;amp; top &amp;lt; bottom) &amp;#123;
            for (int column = right - 1; column &amp;gt; left; column--) &amp;#123;
                order[(*returnSize)++] = matrix[bottom][column];
            &amp;#125;
            for (int row = bottom; row &amp;gt; top; row--) &amp;#123;
                order[(*returnSize)++] = matrix[row][left];
            &amp;#125;
        &amp;#125;
        left++;
        right--;
        top++;
        bottom--;
    &amp;#125;
    return order;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;C-（官方）&#34;&gt;&lt;a href=&#34;#C-（官方）&#34; class=&#34;headerlink&#34; title=&#34;C++（官方）&#34;&gt;&lt;/a&gt;C++（官方）&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;class Solution &amp;#123;
public:
    vector&amp;lt;int&amp;gt; spiralOrder(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) &amp;#123;
        if (matrix.size() == 0 || matrix[0].size() == 0) &amp;#123;
            return &amp;#123;&amp;#125;;
        &amp;#125;

        int rows = matrix.size(), columns = matrix[0].size();
        vector&amp;lt;int&amp;gt; order;
        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left &amp;lt;= right &amp;amp;&amp;amp; top &amp;lt;= bottom) &amp;#123;
            for (int column = left; column &amp;lt;= right; column++) &amp;#123;
                order.push_back(matrix[top][column]);
            &amp;#125;
            for (int row = top + 1; row &amp;lt;= bottom; row++) &amp;#123;
                order.push_back(matrix[row][right]);
            &amp;#125;
            if (left &amp;lt; right &amp;amp;&amp;amp; top &amp;lt; bottom) &amp;#123;
                for (int column = right - 1; column &amp;gt; left; column--) &amp;#123;
                    order.push_back(matrix[bottom][column]);
                &amp;#125;
                for (int row = bottom; row &amp;gt; top; row--) &amp;#123;
                    order.push_back(matrix[row][left]);
                &amp;#125;
            &amp;#125;
            left++;
            right--;
            top++;
            bottom--;
        &amp;#125;
        return order;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;大佬专属代码&#34;&gt;&lt;a href=&#34;#大佬专属代码&#34; class=&#34;headerlink&#34; title=&#34;大佬专属代码&#34;&gt;&lt;/a&gt;大佬专属代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;def spiralOrder(self, matrix: List[List[int]]) -&amp;gt; List[int]:
        res = []
        while matrix:
            res += matrix.pop(0)
            matrix = list(zip(*matrix))[::-1]
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;敲黑板！！！&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;熟练掌握矩阵、列表的各种函数或方法！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210604172806704.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/22-%E9%BB%91%E7%99%BD%E6%96%B9%E6%A0%BC%E7%94%BB/</guid>
            <title>22-黑白方格画</title>
            <link>https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/22-%E9%BB%91%E7%99%BD%E6%96%B9%E6%A0%BC%E7%94%BB/</link>
            <category term="力扣题库" scheme="https://www.liangmeng.xyz/categories/LeetCode/" />
            <category term="难度简单" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/" />
            <category term="黑白方格画" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/%E9%BB%91%E7%99%BD%E6%96%B9%E6%A0%BC%E7%94%BB/" />
            <pubDate>Wed, 02 Jun 2021 21:40:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;题目简述&#34;&gt;&lt;a href=&#34;#题目简述&#34; class=&#34;headerlink&#34; title=&#34;题目简述&#34;&gt;&lt;/a&gt;题目简述&lt;/h2&gt;&lt;p&gt;小扣注意到秋日市集上有一个创作黑白方格画的摊位。摊主给每个顾客提供一个固定在墙上的白色画板，画板不能转动。画板上有 n * n 的网格。绘画规则为，小扣可以选择任意多行以及任意多列的格子涂成黑色（&lt;strong&gt;选择的整行、整列均需涂成黑色&lt;/strong&gt;），&lt;strong&gt;所选行数、列数均可为 0&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;小扣希望最终的成品上需要有 k 个黑色格子，请返回小扣共有多少种涂色方案。&lt;/p&gt;
&lt;p&gt;注意：两个方案中任意一个相同位置的格子颜色不同，就视为不同的方案。&lt;/p&gt;
&lt;h2 id=&#34;题解示例&#34;&gt;&lt;a href=&#34;#题解示例&#34; class=&#34;headerlink&#34; title=&#34;题解示例&#34;&gt;&lt;/a&gt;题解示例&lt;/h2&gt;&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：n &amp;#x3D; 2, k &amp;#x3D; 2&lt;/p&gt;
&lt;p&gt;输出：4&lt;/p&gt;
&lt;p&gt;解释：一共有四种不同的方案：&lt;br&gt;第一种方案：涂第一列；&lt;br&gt;第二种方案：涂第二列；&lt;br&gt;第三种方案：涂第一行；&lt;br&gt;第四种方案：涂第二行。&lt;/p&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入：n &amp;#x3D; 2, k &amp;#x3D; 1&lt;/p&gt;
&lt;p&gt;输出：0&lt;/p&gt;
&lt;p&gt;解释：不可行，因为第一次涂色至少会涂两个黑格。&lt;/p&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;p&gt;输入：n &amp;#x3D; 2, k &amp;#x3D; 4&lt;/p&gt;
&lt;p&gt;输出：1&lt;/p&gt;
&lt;p&gt;解释：共有 2*2&amp;#x3D;4 个格子，仅有一种涂色方案。&lt;/p&gt;
&lt;h2 id=&#34;数据范围&#34;&gt;&lt;a href=&#34;#数据范围&#34; class=&#34;headerlink&#34; title=&#34;数据范围&#34;&gt;&lt;/a&gt;数据范围&lt;/h2&gt;&lt;p&gt;1 &amp;lt;&amp;#x3D; n &amp;lt;&amp;#x3D; 6&lt;br&gt;0 &amp;lt;&amp;#x3D; k &amp;lt;&amp;#x3D; n * n&lt;/p&gt;
&lt;h2 id=&#34;标记难度&#34;&gt;&lt;a href=&#34;#标记难度&#34; class=&#34;headerlink&#34; title=&#34;标记难度&#34;&gt;&lt;/a&gt;标记难度&lt;/h2&gt;&lt;p&gt;难度：简单&lt;br&gt;通过次数：8065&lt;br&gt;提交次数：24485&lt;br&gt;通过率：32.9%&lt;/p&gt;
&lt;h2 id=&#34;问题解析&#34;&gt;&lt;a href=&#34;#问题解析&#34; class=&#34;headerlink&#34; title=&#34;问题解析&#34;&gt;&lt;/a&gt;问题解析&lt;/h2&gt;&lt;p&gt;本题主要考察组合和阶乘。&lt;/p&gt;
&lt;p&gt;假设选择涂黑i行、j列，那么此时黑色方块共有 &lt;strong&gt;i*n + j*n - i*j&lt;/strong&gt; 块，其中 &lt;strong&gt;i*j&lt;/strong&gt; 为行和列重合的块数。&lt;/p&gt;
&lt;p&gt;而在n行中取i行、在n列中取j列，即数学中的组合数，其值可以分别为 &lt;strong&gt;n! &amp;#x2F; (i!(n-i)!)&lt;/strong&gt;  、 &lt;strong&gt;n! &amp;#x2F; (j!(n-j)!)&lt;/strong&gt; ，这便涉及到阶乘的计算了。&lt;/p&gt;
&lt;p&gt;要注意的是，当不涂或者涂满时，方法都只有一种。&lt;/p&gt;
&lt;h2 id=&#34;python3代码&#34;&gt;&lt;a href=&#34;#python3代码&#34; class=&#34;headerlink&#34; title=&#34;python3代码&#34;&gt;&lt;/a&gt;python3代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class Solution:
    def paintingPlan(self, n: int, k: int) -&amp;gt; int:
        if k == 0 or k == n*n:
            return 1
        result = 0
        for i in range(1, n):
            for j in range(1, n):
                if n*i + n*j - i*j == k:
                    result += math.factorial(n)/(math.factorial(i) * math.factorial(n-i))*math.factorial(n)/(math.factorial(j) * math.factorial(n-j))           
        return int(result)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，阶乘的求解可以用递归，也可以用循环，或者直接用库函数，可以分别运行来比较其时间复杂度和空间复杂度。&lt;/p&gt;
&lt;p&gt;另外，组合的求解方式也非常多样化，可以利用阶乘函数计算，也可以直接进行数值计算。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 递归
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)

# 循环
def factorial(n):
    fact = 1
    for i in range(2, n+1):
        fact *= i
    return fact

# 利用阶乘
def C(n, a):
    return factorial(n)/(factorial(a) * factorial(n-a))
    
# 直接计算
def C(n, a):
    result = 1
    for i in range(n, n-a, -1):
           result *= i
    for j in range(1, a+1):
        result /= j
    return result

# 防溢出防除不尽
def C(n, a):
    result = 1
    for i in range(1, a+1):
        result *= (n+1-i)/i
    return result    
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;C语言代码&#34;&gt;&lt;a href=&#34;#C语言代码&#34; class=&#34;headerlink&#34; title=&#34;C语言代码&#34;&gt;&lt;/a&gt;C语言代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;int factorial(int n)
&amp;#123;
       if(n == 1) 
    &amp;#123; 	
        return 1;
    &amp;#125;
       return n * factorial(n-1);
&amp;#125;
int C(int n, int a)
&amp;#123;
       return factorial(n) / (factorial(a) * factorial(n-a));
&amp;#125;
int paintingPlan(int n, int k)&amp;#123;
    int result = 0, i, j;
    if(k == 0 || k == n*n)
    &amp;#123;
        return 1;
      &amp;#125;
    for(i = 1; i &amp;lt;= n; ++i)
    &amp;#123;
        for&amp;#123;j = 1; j &amp;lt;= n; ++j)
        &amp;#123;
            if((n*i + n*j - i*j) == k)
            &amp;#123;
                result += C(n, i) * C(n, j);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return result;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;C-代码（Copy）&#34;&gt;&lt;a href=&#34;#C-代码（Copy）&#34; class=&#34;headerlink&#34; title=&#34;C++代码（Copy）&#34;&gt;&lt;/a&gt;C++代码（Copy）&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;class Solution &amp;#123;
public:
    //预处理组合数
    int C[10][10];
    void Init()&amp;#123;
        for(int i = 0; i &amp;lt; 10; i++)&amp;#123;
            for(int j = 0; j &amp;lt;= i; j++)&amp;#123;
                if(!j) C[i][j] = 1;
                else C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
            &amp;#125;
        &amp;#125;
    &amp;#125;
    int paintingPlan(int n, int k) &amp;#123;
        if(k == 0) return 1;
        if(k &amp;lt; n) return 0;
        if(k == n * n) return 1;
        Init();
        int ans = 0;
        for(int i = 0 ; i &amp;lt;= n; i++)&amp;#123;
            for(int j = 0; j &amp;lt;= n; j++)&amp;#123;
                if(n * i + n * j - i * j == k)&amp;#123;
                    ans += C[n][i] * C[n][j];
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;大佬专属代码&#34;&gt;&lt;a href=&#34;#大佬专属代码&#34; class=&#34;headerlink&#34; title=&#34;大佬专属代码&#34;&gt;&lt;/a&gt;大佬专属代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;int paintingPlan(int n, int k)
&amp;#123;
    int p=0;
    if(k==0)
        p=1;
    if(n==1)
    &amp;#123;
        if(k==1)
            p=1;
    &amp;#125;
    if(n==2)
    &amp;#123;
        if(k==2)
            p=4;
        if(k==3)
            p=4;
        if(k==4)
            p=1;
    &amp;#125;
    if(n==3)
    &amp;#123;
        if(k==3)
            p=6;
        if(k==5)
            p=9;
        if(k==6)
            p=6;
        if(k==7)
           p=18;
        if(k==8)
            p=9;
        if(k==9)
            p=1;
    &amp;#125;
    if(n==4)
    &amp;#123;
        if(k==4)
            p=8;
        if(k==7)
            p=16;
        if(k==8)
            p=12;
        if(k==10)
            p=48;
        if(k==12)
            p=44;
        if(k==13)
            p=32;
        if(k==14)
            p=48;
        if(k==15)
            p=16;
        if(k==16)
            p=1;
    &amp;#125;
    if(n==5)
    &amp;#123;
        if(k==5)
            p=10;
        if(k==9)
            p=25;
        if(k==10)
            p=20;
        if(k==13)
            p=100;
        if(k==15)
            p=20;
        if(k==16)
            p=100;
        if(k==17)
            p=200;
        if(k==21)
            p=150;
        if(k==19)
            p=200;
        if(k==20)
            p=10;
        if(k==25)
            p=1;
        if(k==24)
            p=25;
        if(k==23)
            p=100;
        if(k==22)
            p=100;
    &amp;#125;
    if(n==6)
    &amp;#123;
        if(k==36)
            p=1;
        if(k==35)
            p=36;
        if(k==34)
            p=180;
        if(k==33)
            p=240;
        if(k==32)
            p=405;
        if(k==31)
            p=72;
        if(k==30)
            p=612;
        if(k==28)
            p=450;
        if(k==27)
            p=400;
        if(k==26)
            p=180;
        if(k==24)
            p=630;
        if(k==21)
            p=240;
        if(k==20)
            p=225;
        if(k==18)
            p=40;
        if(k==16)
            p=180;
        if(k==12)
            p=30;
        if(k==11)
            p=36;
        if(k==6)
            p=12;
    &amp;#125;
    return p;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;敲黑板！！！&lt;br&gt;排列、组合、阶乘的各种实现代码必须做到信手拈来，还要考虑其时间复杂度、空间复杂度、是否溢出、是否除不尽等！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210602213721831.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/833-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E6%8A%95%E5%BD%B1%E9%9D%A2%E7%A7%AF/</guid>
            <title>833-三维形体投影面积</title>
            <link>https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/833-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E6%8A%95%E5%BD%B1%E9%9D%A2%E7%A7%AF/</link>
            <category term="力扣题库" scheme="https://www.liangmeng.xyz/categories/LeetCode/" />
            <category term="难度简单" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/" />
            <category term="三维形体投影面积" scheme="https://www.liangmeng.xyz/categories/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E6%8A%95%E5%BD%B1%E9%9D%A2%E7%A7%AF/" />
            <pubDate>Wed, 02 Jun 2021 21:40:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;题目描述&#34;&gt;&lt;a href=&#34;#题目描述&#34; class=&#34;headerlink&#34; title=&#34;题目描述&#34;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;在 n x n 的网格 grid 中，我们放置了一些与 x，y，z 三轴对齐的 1 x 1 x 1 立方体。每个值 v &amp;#x3D; grid[i] [j] 表示 v 个正方体叠放在单元格 (i, j) 上。现在，我们查看这些立方体在 xy 、yz 和 zx 平面上的投影。投影就像影子，将三维形体映射到一个二维平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。返回所有三个投影的总面积 。&lt;/p&gt;
&lt;p&gt;输入示例1：&lt;/p&gt;
&lt;p&gt;[[1, 2], [3, 4]]&lt;/p&gt;
&lt;p&gt;输出示例1：&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;p&gt;该立体图形的俯视图如下，数字代表该处有多少块立方体。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;投影面积 &amp;#x3D; 4（俯视图） + 7（主视图） + 6（左视图）&amp;#x3D; 17&lt;/p&gt;
&lt;p&gt;输入示例2：&lt;/p&gt;
&lt;p&gt;[[2]]&lt;/p&gt;
&lt;p&gt;输出示例2：&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;输入示例3：&lt;/p&gt;
&lt;p&gt;[[1, 0], [0, 2]]&lt;/p&gt;
&lt;p&gt;输出示例3：&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;限制条件：&lt;/p&gt;
&lt;p&gt;n &amp;#x3D;&amp;#x3D; grid.length &amp;#x3D;&amp;#x3D; grid[i].length&lt;/p&gt;
&lt;p&gt;1 &amp;lt;&amp;#x3D; n &amp;lt;&amp;#x3D; 50&lt;/p&gt;
&lt;p&gt;0 &amp;lt;&amp;#x3D; grid[i] [j] &amp;lt;&amp;#x3D; 50&lt;/p&gt;
&lt;h1 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h1&gt;&lt;p&gt;S（俯视图） &amp;#x3D; sum(grid[i] [j] &amp;gt; 0)，即矩阵中非零数值的个数。&lt;/p&gt;
&lt;p&gt;S（主视图） &amp;#x3D; sum(max(grid[j]))，即矩阵中每一列最大值的和。&lt;/p&gt;
&lt;p&gt;S（左视图） &amp;#x3D; sum(max(grid[i]))，即矩阵中每一行最大值的和。&lt;/p&gt;
&lt;h1 id=&#34;个人代码&#34;&gt;&lt;a href=&#34;#个人代码&#34; class=&#34;headerlink&#34; title=&#34;个人代码&#34;&gt;&lt;/a&gt;个人代码&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class Solution:
    def projectionArea(self, grid: List[List[int]]) -&amp;gt; int:
        xy, xz, yz = 0, 0, 0
        for i in range(len(grid)):
            maxr, maxc = 0, 0
            for j in range(len(grid[i])):
                if grid[i][j] &amp;gt; 0:
                    xy += 1
                maxr = max(maxr, grid[i][j])
                maxc = max(maxc, grid[j][i])

            xz += maxr
            yz += maxc     
        return (xy+xz+yz)  
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;官方代码&#34;&gt;&lt;a href=&#34;#官方代码&#34; class=&#34;headerlink&#34; title=&#34;官方代码&#34;&gt;&lt;/a&gt;官方代码&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class Solution:
    def projectionArea(self, grid: List[List[int]]) -&amp;gt; int:
        xyArea = sum(v &amp;gt; 0 for row in grid for v in row)
        # 注意这里为 O(n) 空间复杂度，改为下标枚举则可以 O(1)
        yzArea = sum(map(max, zip(*grid)))  
        zxArea = sum(map(max, grid))
        return xyArea + yzArea + zxArea
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;class Solution &amp;#123;
public:
    int projectionArea(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid) &amp;#123;
        int n = grid.size();
        int xyArea = 0, yzArea = 0, zxArea = 0;
        for (int i = 0; i &amp;lt; n; i++) &amp;#123;
            int yzHeight = 0, zxHeight = 0;
            for (int j = 0; j &amp;lt; n; j++) &amp;#123;
                xyArea += grid[i][j] &amp;gt; 0 ? 1 : 0;
                yzHeight = max(yzHeight, grid[j][i]);
                zxHeight = max(zxHeight, grid[i][j]);
            &amp;#125;
            yzArea += yzHeight;
            zxArea += zxHeight;
        &amp;#125;
        return xyArea + yzArea + zxArea;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;#define MAX(a, b) ((a) &amp;gt; (b) ? (a) : (b))

int projectionArea(int** grid, int gridSize, int* gridColSize) &amp;#123;
    int xyArea = 0, yzArea = 0, zxArea = 0;
    for (int i = 0; i &amp;lt; gridSize; i++) &amp;#123;
        int yzHeight = 0, zxHeight = 0;
        for (int j = 0; j &amp;lt; gridSize; j++) &amp;#123;
            xyArea += grid[i][j] &amp;gt; 0 ? 1 : 0;
            yzHeight = MAX(yzHeight, grid[j][i]);
            zxHeight = MAX(zxHeight, grid[i][j]);
        &amp;#125;
        yzArea += yzHeight;
        zxArea += zxHeight;
    &amp;#125;
    return xyArea + yzArea + zxArea;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/187e682d741b47389088c8f74f117822.png#pic_center&#34; alt=&#34;wolf&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/GameDevelopment/%E8%B4%AA%E5%90%83%E8%9B%87-Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</guid>
            <title>贪吃蛇-Python语言实现</title>
            <link>https://www.liangmeng.xyz/GameDevelopment/%E8%B4%AA%E5%90%83%E8%9B%87-Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</link>
            <category term="游戏开发" scheme="https://www.liangmeng.xyz/categories/GameDevelopment/" />
            <category term="贪吃蛇-Python语言实现" scheme="https://www.liangmeng.xyz/categories/GameDevelopment/%E8%B4%AA%E5%90%83%E8%9B%87-Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/" />
            <category term="Python" scheme="https://www.liangmeng.xyz/tags/Python/" />
            <category term="游戏" scheme="https://www.liangmeng.xyz/tags/%E6%B8%B8%E6%88%8F/" />
            <category term="贪吃蛇" scheme="https://www.liangmeng.xyz/tags/%E8%B4%AA%E5%90%83%E8%9B%87/" />
            <pubDate>Wed, 02 Jun 2021 11:05:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a href=&#34;#前言&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;贪吃蛇（也叫做贪食蛇）游戏是一款休闲益智类游戏，既简单又耐玩，唯一的目标就是&lt;strong&gt;做这条gai上最长（pang）的蛇（zhu）&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;玩贪吃蛇最考验的就是走位（&lt;strong&gt;简称蛇皮走位&lt;/strong&gt;），各种漂移过人，唉，就是玩儿！&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601204813403.gif#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;基本设置&#34;&gt;&lt;a href=&#34;#基本设置&#34; class=&#34;headerlink&#34; title=&#34;基本设置&#34;&gt;&lt;/a&gt;基本设置&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 基本设置
lattice_wh = 20
snake_color = (84, 255, 159)
snake_head_color = (123, 104, 238)
food_color = (255, 64, 64)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;绘制屏幕&#34;&gt;&lt;a href=&#34;#绘制屏幕&#34; class=&#34;headerlink&#34; title=&#34;绘制屏幕&#34;&gt;&lt;/a&gt;绘制屏幕&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;# 绘制屏幕
pygame.init()
screen = pygame.display.set_mode((25*lattice_wh, 25*lattice_wh))
pygame.display.set_caption(&amp;quot;贪吃蛇&amp;quot;)

# 帧率，每秒刷新屏幕次数
FPS = 10
# 帧率变化系数
level = 1.5
# 时间对象
FPSCLOCK = pygame.time.Clock()
# 游戏结束标志
game_over = 0
# 前进方向
direction = 0
# 进食数量
num = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;蛇类&#34;&gt;&lt;a href=&#34;#蛇类&#34; class=&#34;headerlink&#34; title=&#34;蛇类&#34;&gt;&lt;/a&gt;蛇类&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 蛇
class Snake():
    def __init__(self, snake_color, snake_head_color, x, y, lattice_wh):
        self.color = snake_color
        self.head_color = snake_head_color
        # 左上顶点坐标
        self.pos = (x, y)
        self.lattice_wh = lattice_wh
          # 绘制蛇体
        self.rect = pygame.rect.Rect(x, y, self.lattice_wh, self.lattice_wh)
        # 左上顶点坐标变化
        self.pos_change = &amp;#123;
            # 上移
            1:(0, -self.lattice_wh),
            # 下移
            2:(0, self.lattice_wh),
            # 左移
            3:(-self.lattice_wh, 0),
            # 右移
            4:(self.lattice_wh, 0)
        &amp;#125;
    
    def move(self, direction):
        self.rect.x += self.pos_change[direction][0]
        self.rect.y += self.pos_change[direction][1]

    def forecast(self, direction):
        return (self.rect.x+self.pos_change[direction][0], self.rect.y+self.pos_change[direction][1])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;食物类&#34;&gt;&lt;a href=&#34;#食物类&#34; class=&#34;headerlink&#34; title=&#34;食物类&#34;&gt;&lt;/a&gt;食物类&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 食物
class Food():
    def __init__(self, food_color, screen, lattice_wh, x, y):
        self.screen = screen
        self.color = food_color
        self.lattice_wh = lattice_wh
        # 半径
        self.radius = lattice_wh/2
        self.x, self.y = x, y

    def draw(self):
        # 圆心
        pos = (self.x+self.lattice_wh/2, self.y+self.lattice_wh/2)
        # 绘制食物
        pygame.draw.circle(self.screen, self.color, pos, self.radius, int(self.radius))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;初始状态&#34;&gt;&lt;a href=&#34;#初始状态&#34; class=&#34;headerlink&#34; title=&#34;初始状态&#34;&gt;&lt;/a&gt;初始状态&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 贪吃蛇
snakes = list()
snakes.append(Snake(snake_color, snake_head_color, lattice_wh, 24*lattice_wh, lattice_wh))
snakes.append(Snake(snake_color, snake_head_color, 0, 24*lattice_wh, lattice_wh))

# 食物
food = create_food(food_color, screen, lattice_wh, snakes)

# 游戏状态
game_stats = [game_over, direction, num, food]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;生成食物&#34;&gt;&lt;a href=&#34;#生成食物&#34; class=&#34;headerlink&#34; title=&#34;生成食物&#34;&gt;&lt;/a&gt;生成食物&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 生成食物
def create_food(food_color, screen, lattice_wh, snakes):
    # 食物是否生成成功
    create_success = 0
    # 食物位置坐标
    food_x, food_y = 0, 0
    while not create_success:
        food_x, food_y = randint(0, 24), randint(0, 24)
        food_x *= lattice_wh
        food_y *= lattice_wh
        # 检查食物位置是否与贪吃蛇位置重合
        for snake in snakes:
            if (food_x, food_y) != (snake.rect.x, snake.rect.y):
                create_success = 1
                break
    # 在指定位置生成食物
    food = Food(food_color, screen, lattice_wh, food_x, food_y)
    return food
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;响应键鼠&#34;&gt;&lt;a href=&#34;#响应键鼠&#34; class=&#34;headerlink&#34; title=&#34;响应键鼠&#34;&gt;&lt;/a&gt;响应键鼠&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 响应键鼠
def check_events(game_stats):
    for event in pygame.event.get():
        # 退出游戏
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        # 控制移动方向，注意不能直接反向移动
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_UP and game_stats[1] != 2:
                game_stats[1] = 1
            elif event.key == pygame.K_DOWN and game_stats[1] != 1:
                game_stats[1] = 2
            elif event.key == pygame.K_LEFT and game_stats[1] != 4:
                game_stats[1] = 3
            elif event.key == pygame.K_RIGHT and game_stats[1] != 3:
                game_stats[1] = 4
            else:
                game_stats[1] = game_stats[1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;更新屏幕&#34;&gt;&lt;a href=&#34;#更新屏幕&#34; class=&#34;headerlink&#34; title=&#34;更新屏幕&#34;&gt;&lt;/a&gt;更新屏幕&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 更新屏幕
def update(screen, lattice_wh, snakes, game_stats):
    screen.fill((255, 255, 255))
    # 绘制蛇头
    pygame.draw.rect(screen, snakes[0].head_color, snakes[0].rect)
    # 绘制蛇身
    for i in range(1, len(snakes)):
        pygame.draw.rect(screen, snakes[i].color, snakes[i].rect)
    # 绘制横线
    for i in range(25):
        pygame.draw.line(screen, (105, 105, 105), (0, lattice_wh*i), (500, lattice_wh*i))
    # 绘制竖线
    for i in range(25):
        pygame.draw.line(screen, (105, 105, 105), (lattice_wh*i, 0), (lattice_wh*i, 500))
    # 绘制食物
    game_stats[3].draw()
    # 更新屏幕
    pygame.display.flip()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;移动进食&#34;&gt;&lt;a href=&#34;#移动进食&#34; class=&#34;headerlink&#34; title=&#34;移动进食&#34;&gt;&lt;/a&gt;移动进食&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 移动进食
def going(screen, game_stats, snakes, snake_head_color, snake_color, food_color, lattice_wh):
    if not game_stats[1]:
        return
    # 蛇头下一前进位置
    (x, y) = snakes[0].forecast(game_stats[1])
    # 检查是否触碰边界
    if x == -lattice_wh or x == 25*lattice_wh or y == -lattice_wh or y == 25*lattice_wh:
        game_stats[0] = 1
        return
    # 检查是否触碰食物
    if (x, y) == (game_stats[3].x, game_stats[3].y):
        # 更新蛇头
        new_head = Snake(snake_color, snake_head_color, x, y, lattice_wh)
        snakes.insert(0, new_head)
        # 更新分数
        game_stats[2] += 1
        # 重新生成食物
        game_stats[3] = create_food(food_color, screen, lattice_wh, snakes)
        return
    # 检查是否触碰蛇身
    for snake in snakes:
        if (x, y) == (snake.rect.x, snake.rect.y):
            game_stats[0] = 1
            return
    # 更新所有蛇身位置
    for i in range(len(snakes)-1, 0, -1):
        snakes[i].rect.x = snakes[i-1].rect.x
        snakes[i].rect.y = snakes[i-1].rect.y
    # 更新蛇头位置
    snakes[0].move(game_stats[1])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;游戏入口&#34;&gt;&lt;a href=&#34;#游戏入口&#34; class=&#34;headerlink&#34; title=&#34;游戏入口&#34;&gt;&lt;/a&gt;游戏入口&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 游戏入口
while not game_stats[0]:
    update(screen, lattice_wh, snakes, game_stats)
    check_events(game_stats)
    going(screen, game_stats, snakes, snake_head_color, snake_color, food_color, lattice_wh)
    FPSCLOCK.tick(FPS * level ** num if FPS * level ** num &amp;lt; 60 else 60)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;snake-py&#34;&gt;&lt;a href=&#34;#snake-py&#34; class=&#34;headerlink&#34; title=&#34;snake.py&#34;&gt;&lt;/a&gt;snake.py&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;import pygame

# 蛇
class Snake():
    def __init__(self, snake_color, snake_head_color, x, y, lattice_wh):
        self.color = snake_color
        self.head_color = snake_head_color
        # 左上顶点坐标
        self.pos = (x, y)
        self.lattice_wh = lattice_wh
        # 绘制蛇体
        self.rect = pygame.rect.Rect(x, y, self.lattice_wh, self.lattice_wh)
        # 左上顶点坐标变化
        self.pos_change = &amp;#123;
            # 上移
            1:(0, -self.lattice_wh),
            # 下移
            2:(0, self.lattice_wh),
            # 左移
            3:(-self.lattice_wh, 0),
            # 右移
            4:(self.lattice_wh, 0)
        &amp;#125;

    # 移动
    def move(self, direction):
        self.rect.x += self.pos_change[direction][0]
        self.rect.y += self.pos_change[direction][1]

    # 下一前进位置
    def forecast(self, direction):
        return (self.rect.x+self.pos_change[direction][0], self.rect.y+self.pos_change[direction][1])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;food-py&#34;&gt;&lt;a href=&#34;#food-py&#34; class=&#34;headerlink&#34; title=&#34;food.py&#34;&gt;&lt;/a&gt;food.py&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;import pygame

# 食物
class Food():
    def __init__(self, food_color, screen, lattice_wh, x, y):
        self.screen = screen
        self.color = food_color
        self.lattice_wh = lattice_wh
        # 半径
        self.radius = lattice_wh/2
        self.x, self.y = x, y

    def draw(self):
        # 圆心
        pos = (self.x+self.lattice_wh/2, self.y+self.lattice_wh/2)
        # 绘制食物
        pygame.draw.circle(self.screen, self.color, pos, self.radius, int(self.radius))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;function-py&#34;&gt;&lt;a href=&#34;#function-py&#34; class=&#34;headerlink&#34; title=&#34;function.py&#34;&gt;&lt;/a&gt;function.py&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;import pygame
import sys
from random import randint
from food import Food
from snake import Snake

# 生成食物
def create_food(food_color, screen, lattice_wh, snakes):
    # 食物是否生成成功
    create_success = 0
    # 食物位置坐标
    food_x, food_y = 0, 0
    while not create_success:
        food_x, food_y = randint(0, 24), randint(0, 24)
        food_x *= lattice_wh
        food_y *= lattice_wh
        # 检查食物位置是否与贪吃蛇位置重合
        for snake in snakes:
            if (food_x, food_y) != (snake.rect.x, snake.rect.y):
                create_success = 1
                break
    # 在指定位置生成食物
    food = Food(food_color, screen, lattice_wh, food_x, food_y)
    return food

# 响应事件
def check_events(game_stats):
    for event in pygame.event.get():
        # 退出游戏
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        # 控制移动方向，注意不能直接反向移动
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_UP and game_stats[1] != 2:
                game_stats[1] = 1
            elif event.key == pygame.K_DOWN and game_stats[1] != 1:
                game_stats[1] = 2
            elif event.key == pygame.K_LEFT and game_stats[1] != 4:
                game_stats[1] = 3
            elif event.key == pygame.K_RIGHT and game_stats[1] != 3:
                game_stats[1] = 4
            else:
                game_stats[1] = game_stats[1]

# 更新屏幕
def update(screen, lattice_wh, snakes, game_stats):
    screen.fill((255, 255, 255))
    # 绘制蛇头
    pygame.draw.rect(screen, snakes[0].head_color, snakes[0].rect)
    # 绘制蛇身
    for i in range(1, len(snakes)):
        pygame.draw.rect(screen, snakes[i].color, snakes[i].rect)
    # 绘制横线
    for i in range(25):
        pygame.draw.line(screen, (105, 105, 105), (0, lattice_wh*i), (500, lattice_wh*i))
    # 绘制竖线
    for i in range(25):
        pygame.draw.line(screen, (105, 105, 105), (lattice_wh*i, 0), (lattice_wh*i, 500))
    # 绘制食物
    game_stats[3].draw()
    # 更新屏幕
    pygame.display.flip()

# 移动进食
def going(screen, game_stats, snakes, snake_head_color, snake_color, food_color, lattice_wh):
    if not game_stats[1]:
        return
    # 蛇头下一前进位置
    (x, y) = snakes[0].forecast(game_stats[1])
    # 检查是否触碰边界
    if x == -lattice_wh or x == 25*lattice_wh or y == -lattice_wh or y == 25*lattice_wh:
        game_stats[0] = 1
        return
    # 检查是否触碰食物
    if (x, y) == (game_stats[3].x, game_stats[3].y):
        # 更新蛇头
        new_head = Snake(snake_color, snake_head_color, x, y, lattice_wh)
        snakes.insert(0, new_head)
        # 更新分数
        game_stats[2] += 1
        # 重新生成食物
        game_stats[3] = create_food(food_color, screen, lattice_wh, snakes)
        return
    # 检查是否触碰蛇身
    for snake in snakes:
        if (x, y) == (snake.rect.x, snake.rect.y):
            game_stats[0] = 1
            return
    # 更新所有蛇身位置
    for i in range(len(snakes)-1, 0, -1):
        snakes[i].rect.x = snakes[i-1].rect.x
        snakes[i].rect.y = snakes[i-1].rect.y
    # 更新蛇头位置
    snakes[0].move(game_stats[1])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;main-py&#34;&gt;&lt;a href=&#34;#main-py&#34; class=&#34;headerlink&#34; title=&#34;main.py&#34;&gt;&lt;/a&gt;main.py&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;import pygame
from function import *
from snake import Snake

# 基本设置
lattice_wh = 20
snake_color = (84, 255, 159)
snake_head_color = (123, 104, 238)
food_color = (255, 64, 64)

# 绘制屏幕
pygame.init()
screen = pygame.display.set_mode((25*lattice_wh, 25*lattice_wh))
pygame.display.set_caption(&amp;quot;贪吃蛇&amp;quot;)

# 帧率，每秒刷新屏幕次数
FPS = 10
# 帧率变化系数
level = 1.5
# 时间对象
FPSCLOCK = pygame.time.Clock()

# 游戏结束标志
game_over = 0

# 前进方向
direction = 0
# 进食数量
num = 0

# 贪吃蛇
snakes = list()
snakes.append(Snake(snake_color, snake_head_color, lattice_wh, 24*lattice_wh, lattice_wh))
snakes.append(Snake(snake_color, snake_head_color, 0, 24*lattice_wh, lattice_wh))

# 食物
food = create_food(food_color, screen, lattice_wh, snakes)

# 游戏状态
game_stats = [game_over, direction, num, food]

# 游戏入口
while not game_stats[0]:
    update(screen, lattice_wh, snakes, game_stats)
    check_events(game_stats)
    going(screen, game_stats, snakes, snake_head_color, snake_color, food_color, lattice_wh)
    FPSCLOCK.tick(FPS * level ** num if FPS * level ** num &amp;lt; 60 else 60)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;敲黑板！！！在控制蛇的移动方向时，易忽略蛇不能直接反向移动这一问题；另外，在生成食物时，要检查食物的位置与蛇的位置是否重合，如果两者位置重合，此时需要生成新的食物。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601212016193.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;wolf&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/Electrotechnics/%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
            <title>集成运算放大器的应用</title>
            <link>https://www.liangmeng.xyz/Electrotechnics/%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/</link>
            <category term="电工与电子技术" scheme="https://www.liangmeng.xyz/categories/Electrotechnics/" />
            <category term="集成运算放大器的应用" scheme="https://www.liangmeng.xyz/categories/Electrotechnics/%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/" />
            <category term="实验" scheme="https://www.liangmeng.xyz/tags/%E5%AE%9E%E9%AA%8C/" />
            <category term="电工与电子技术" scheme="https://www.liangmeng.xyz/tags/%E7%94%B5%E5%B7%A5%E4%B8%8E%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/" />
            <pubDate>Tue, 01 Jun 2021 22:30:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;实验目的&#34;&gt;&lt;a href=&#34;#实验目的&#34; class=&#34;headerlink&#34; title=&#34;实验目的&#34;&gt;&lt;/a&gt;实验目的&lt;/h2&gt;&lt;p&gt;(1)	掌握集成运算放大器的基本运算功能及正确使用。&lt;br&gt;(2)	掌握集成运算放大器常用单元电路的设计和调试方法。&lt;br&gt;(3)	掌握在仿真实验平台中导入和调试新元件的方法。&lt;/p&gt;
&lt;h2 id=&#34;实验原理&#34;&gt;&lt;a href=&#34;#实验原理&#34; class=&#34;headerlink&#34; title=&#34;实验原理&#34;&gt;&lt;/a&gt;实验原理&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;实验原理
&lt;/code&gt;&lt;/pre&gt;
集成运算放大器是由高开环电压放大倍数的多级直接耦合放大器组成。从工作原理上，集成运算放大器可分为线性应用和非线性应用两个方面。在线性工作区内，其输出电压uo与输入电压ui的线性放大的关系为uo&amp;#x3D;Auo（u+-u-）&amp;#x3D;Auoui，由于集成运算放大器的放大倍数Auo高达104~107，若使uo为有限值，必须引入深度负反馈，使线性区加宽，构成集成运算放大器的线性运算电路。&lt;br&gt;  在工程应用情况下，将集成运放视为理想运放，就是将集成运放的各项技术指标理想化，满足下列条件的运算放大器称为理想运放，即&lt;br&gt;  (1)开环电压放大倍数Auo&amp;#x3D;∞&lt;br&gt;  (2)输入阻抗ri&amp;#x3D;∞&lt;br&gt;  (3)输出阻抗ro&amp;#x3D;0&lt;br&gt;  (4)带宽fBW&amp;#x3D;∞&lt;br&gt;  (5)失调与漂移均为零&lt;br&gt;  理想运放工作在线性区的分析依据是，输入端的虚短（u+&amp;#x3D;u-），输入端的虚断（i+&amp;#x3D;i-&amp;#x3D;0）和输入端的虚地（同相端接地时，u-&amp;#x3D;0）。&lt;br&gt;理想运放工作在非线性区的分析依据是：&lt;br&gt;u+&amp;gt;u-, uo&amp;#x3D;+UOM          u-&amp;gt;u+, uo&amp;#x3D;-UOM&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;原理图
&lt;/code&gt;&lt;/pre&gt;
(1)	电压跟随器，原理图如下：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221504560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;(2)	反向比例运算电路，原理图如下：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221520539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(3)	同向比例运算电路，原理图如下：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221537472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;(4)	减法器的设计，原理图如下：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221601987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;(5)	电压比较器，原理图如下：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221621297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;(6)	矩形波发生器，原理图如下：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221637847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;实验过程与原始数据&#34;&gt;&lt;a href=&#34;#实验过程与原始数据&#34; class=&#34;headerlink&#34; title=&#34;实验过程与原始数据&#34;&gt;&lt;/a&gt;实验过程与原始数据&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;电压跟随器
&lt;/code&gt;&lt;/pre&gt;
(1)	实验过程：在画布中插入三个电压源和一个理想运放，将输入电压ui设置为直流1V，然后按照原理图将各元件连接起来。运行电路图并测量输出电压uo。&lt;br&gt;(2)	原始数据：ui&amp;#x3D;1V&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221710662.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;反向比例运算电路
&lt;/code&gt;&lt;/pre&gt;
(1)	实验过程：在画布中插入三个电压源、一个理想运放和三个电阻，将R1赋为20kΩ，R2赋为16.667kΩ，RF赋为100kΩ，然后按照原理图将各元件连接起来。不断改变输入电压ui，运行电路图并测量输出电压uo。&lt;br&gt;(2)	原始数据：R1&amp;#x3D;20kΩ，R2&amp;#x3D;16.667kΩ，RF&amp;#x3D;100kΩ&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221728721.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;同向比例运算电路
&lt;/code&gt;&lt;/pre&gt;
(1)	实验过程：在画布中插入三个电压源、一个理想运放和三个电阻，将&lt;br&gt;R1赋为20kΩ，R2赋为16.667kΩ，RF赋为100kΩ，然后按照原理图将各元件连接起来。不断改变输入电压ui，运行电路图并测量输出电压uo。&lt;br&gt;(2)	原始数据：R1&amp;#x3D;20kΩ，R2&amp;#x3D;16.667kΩ，RF&amp;#x3D;100kΩ&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221744385.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;减法器的设计
&lt;/code&gt;&lt;/pre&gt;
(1)	实验过程：在画布中插入四个电压源、一个理想运放和四个电阻，将R1赋为10kΩ，R2赋为10kΩ，R3赋为100kΩ，RF赋为100kΩ，然后按照原理图将各元件连接起来。不断改变输入电压ui1和ui2，运行电路图并测量输出电压uo。该减法器可实现关系式uo&amp;#x3D;10（ui2-ui1）。&lt;br&gt;(2)	原始数据：R1&amp;#x3D;10kΩ，R2&amp;#x3D;10kΩ，R3&amp;#x3D;100Kω,RF&amp;#x3D;100kΩ&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/2021060122180757.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;电压比较器
&lt;/code&gt;&lt;/pre&gt;
(1)	实验过程：在画布中插入三个电源、一个理想运放和两个电阻，将R1赋为10kΩ，R2赋为10kΩ，ui赋为交流1V，频率为1kHz，然后按照原理图将各元件连接起来。运行电路图，画出输出电压uo的波形和传输特性。&lt;br&gt;(2)	原始数据：R1&amp;#x3D;10kΩ,R2&amp;#x3D;10kΩ,ui&amp;#x3D;1V，频率为1kHz&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221824228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;矩形波发生器
&lt;/code&gt;&lt;/pre&gt;
(1)	实验过程：在画布中插入两个电源、一个理想运放、一个电容和四个电阻，按照原理图将各元件连接起来。不断改变R1、R2、R3、RF的阻值和C的容抗，运行电路并测量输出电压的周期、频率和幅度。&lt;br&gt;(2)	原始数据：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221842497.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;h2 id=&#34;实验结果及分析&#34;&gt;&lt;a href=&#34;#实验结果及分析&#34; class=&#34;headerlink&#34; title=&#34;实验结果及分析&#34;&gt;&lt;/a&gt;实验结果及分析&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;电压跟随器
&lt;/code&gt;&lt;/pre&gt;
(1)	实验结果：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221904795.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;(2)	分析：输出电压uo等于输入电压ui，即电压跟随器不具有放大效应。&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;反向比例运算电路
&lt;/code&gt;&lt;/pre&gt;
(1)	实验结果：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221918182.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;(2)	分析：在一定范围内，输出电压和输入电压满足uo&amp;#x3D;-5ui，即输出电压与输入电压成正比，且其相位相反。当ui超过某一定值时，uo不再增大。&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;同向比例运算电路
&lt;/code&gt;&lt;/pre&gt;
(1)	实验结果：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221938255.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;(2)	分析：在一定范围内，输出电压与输入电压满足uo&amp;#x3D;6ui，即输出电压与输入电压成正比，且其相位相同。当ui超过一定值时，uo不再增大。&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;减法器的设计
&lt;/code&gt;&lt;/pre&gt;
(1)	实验结果：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221953204.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;(2)	分析：在一定范围内，输出电压与输入电压满足uo&amp;#x3D;10（ui2-ui1），即输出电压与输入电压的差值成正比。当差值超过一定值时，uo不再增大。&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;电压比较器
&lt;/code&gt;&lt;/pre&gt;
(1)	实验结果：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601222004269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601222009349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;矩形波发生器
&lt;/code&gt;&lt;/pre&gt;
(1)	实验结果&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601222021793.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;h2 id=&#34;思考题&#34;&gt;&lt;a href=&#34;#思考题&#34; class=&#34;headerlink&#34; title=&#34;思考题&#34;&gt;&lt;/a&gt;思考题&lt;/h2&gt;(1)	不能。因为输出电压的幅值受到供能直流电源电压的限制，即输出电压的最大值不超过供能直流电源的电压。&lt;br&gt;(2)	可将两个二极管串联在运放的正、负电源电路中，如果正接负、负接正，则二极管不导通，运放不工作，从而保护运放。电路图如下：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601222039316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;h2 id=&#34;实验体会与建议&#34;&gt;&lt;a href=&#34;#实验体会与建议&#34; class=&#34;headerlink&#34; title=&#34;实验体会与建议&#34;&gt;&lt;/a&gt;实验体会与建议&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;体会：在本次实验中我掌握了多种集成运算放大电路的原理和常用单元电路的设计和调试方法，且能够利用仿真实验平台分析输出电压的波形和传输特性。另外，通过这次实验，我对集成运算放大电路的理论分析更加清晰准确，进一步提高了我对电路各项参数进行理论计算的能力。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;本次实验难度中等偏易，且其对电路分析的能力要求不够高，可以适当提升实验难度。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;敲黑板！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;叠加定理与戴维南定理&amp;#x2F;RLC串联谐振电路&amp;#x2F;单管交流电压放大电路&amp;#x2F;集成放大器的应用完整实验报告&lt;/strong&gt;&lt;br&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9LaXNzTW9vbl8vMTkzMjI4OTY=&#34;&gt;https://download.csdn.net/download/KissMoon_&amp;#x2F;19322896&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601222244974.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.liangmeng.xyz/Electrotechnics/%E5%8D%95%E7%AE%A1%E4%BA%A4%E6%B5%81%E7%94%B5%E5%8E%8B%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF/</guid>
            <title>单管交流电压放大电路</title>
            <link>https://www.liangmeng.xyz/Electrotechnics/%E5%8D%95%E7%AE%A1%E4%BA%A4%E6%B5%81%E7%94%B5%E5%8E%8B%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF/</link>
            <category term="电工与电子技术" scheme="https://www.liangmeng.xyz/categories/Electrotechnics/" />
            <category term="单管交流电压放大电路" scheme="https://www.liangmeng.xyz/categories/Electrotechnics/%E5%8D%95%E7%AE%A1%E4%BA%A4%E6%B5%81%E7%94%B5%E5%8E%8B%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF/" />
            <category term="实验" scheme="https://www.liangmeng.xyz/tags/%E5%AE%9E%E9%AA%8C/" />
            <category term="电工与电子技术" scheme="https://www.liangmeng.xyz/tags/%E7%94%B5%E5%B7%A5%E4%B8%8E%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/" />
            <pubDate>Tue, 01 Jun 2021 22:29:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;实验目的&#34;&gt;&lt;a href=&#34;#实验目的&#34; class=&#34;headerlink&#34; title=&#34;实验目的&#34;&gt;&lt;/a&gt;实验目的&lt;/h2&gt;&lt;p&gt;(1)	掌握晶体管放大电路静态工作点的调试方法。&lt;br&gt;(2)	了解静态工作点的改变对放大电路性能的影响。&lt;br&gt;(3)	了解饱和失真和截止失真对放大电路输出电压波形的影响。&lt;br&gt;(4)	进一步熟悉仿真实验平台的各种基本操作。&lt;/p&gt;
&lt;h2 id=&#34;实验原理&#34;&gt;&lt;a href=&#34;#实验原理&#34; class=&#34;headerlink&#34; title=&#34;实验原理&#34;&gt;&lt;/a&gt;实验原理&lt;/h2&gt;&lt;p&gt;(1)	实验原理：单管交流电压放大电路的最典型电路是共发射极分压偏置式交流电压放大电路，原理图如下。在原理图中，晶体管为非线性元件，要使放大器不产生非线性失真，就必须建立一个合适的静态工作点，使晶体管工作在放大区。若Q点过低（IB小，则IC小，UCE大），晶体管进入截止区，产生截止失真；Q点过高（IB、IC大，UCE小），晶体管将进入饱和区，产生饱和失真。调节基极电阻RP即可调整静态工作点。电压放大倍数为&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601220449802.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;(2)	原理图：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/2021060122051847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;实验过程与原始数据&#34;&gt;&lt;a href=&#34;#实验过程与原始数据&#34; class=&#34;headerlink&#34; title=&#34;实验过程与原始数据&#34;&gt;&lt;/a&gt;实验过程与原始数据&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;调整静态工作点
&lt;/code&gt;&lt;/pre&gt;
(1)	实验过程：先根据UCE&amp;#x3D;1&amp;#x2F;2VCC计算出电阻RP阻值的大致范围，然后将电阻RP进行赋值，运行电路图，不断对电阻RP的阻值进行微小调整，直至出现符合要求的静态工作点。&lt;br&gt;(2)	原始数据：&lt;br&gt;RB1&amp;#x3D;20kΩ，RB2&amp;#x3D;20kΩ，RC&amp;#x3D;2.4kΩ，RE&amp;#x3D;1kΩ，C1&amp;#x3D;10μF，C2&amp;#x3D;10μF，CE&amp;#x3D;47μF，VCC&amp;#x3D;12V，Ui&amp;#x3D;10mV（有效值），频率f&amp;#x3D;1kHz&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601220558523.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;测量电压放大倍数
&lt;/code&gt;&lt;/pre&gt;
(1)	实验过程：当静态工作点测量完毕之后，保持静态工作点不变，接通信号源。在画布中插入一个电阻RL，开始时RL无需接入电路，即RL&amp;#x3D;∞，运行电路图，测量UO并计算Au；然后将RL接入电路，其阻值分别赋为10kΩ和1k欧姆，重复上述过程。&lt;br&gt;(2)	原始数据：&lt;br&gt;RB1&amp;#x3D;20kΩ，RB2&amp;#x3D;20kΩ，RC&amp;#x3D;2.4kΩ，RE&amp;#x3D;1kΩ，RP&amp;#x3D;44.67kΩ，C1&amp;#x3D;10μF，C2&amp;#x3D;10μF，CE&amp;#x3D;47μF，VCC&amp;#x3D;12V，Ui&amp;#x3D;10mV（幅值），频率f&amp;#x3D;1kHz&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/2021060122062057.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;观测静态工作点对输出电压波形的影响
&lt;/code&gt;&lt;/pre&gt;
(1)	实验过程：&lt;br&gt;①	最佳静态工作点的情况：调节RP，使静态工作点在最佳位置时，观察输出电压波形；然后断开信号源，测量UBE、UCE、VB的电压值以及IB、IC的电流值。&lt;br&gt;②	饱和失真的情况：将RP的阻值逐渐减小，输入信号保持不变，观察输出电压波形，使波形出现饱和失真。然后断开信号源，测量UBE、UCE、VB的电压值以及IB、IC的电流值。&lt;br&gt;③	输入信号增大的情况：输入信号Ui&amp;#x3D;10mV，频率f&amp;#x3D;1kHz，调节RP，使之达到最佳静态工作点。然后逐渐增大Ui，观察输出电压波形，使输出电压波形同时出现饱和失真和截止失真，测量UBE、UCE、VB的电压值以及IB、IC的电流值。&lt;br&gt;(2)	原始数据：&lt;br&gt;RB1&amp;#x3D;20kΩ，RB2&amp;#x3D;20kΩ，RC&amp;#x3D;2.4kΩ，RE&amp;#x3D;1kΩ，C1&amp;#x3D;10μF，C2&amp;#x3D;10μF，CE&amp;#x3D;47μF，VCC&amp;#x3D;12V&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601220741694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;四、实验结果及分析&lt;br&gt;1.	调整静态工作点&lt;br&gt;(1)	实验结果：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601220810184.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;2.	测量电压放大倍数&lt;br&gt;(1)	实验结果：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601220830736.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;(2)	分析：电压放大倍数Au随着负载阻值RL的减小而减小。&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601220842469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;3.	观测静态工作点对输出电压波形的影响&lt;br&gt;(1)	实验结果：&lt;br&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601220908135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;(2)	分析：输入信号合适时，如果静态工作点过高，会出现饱和失真，如果静态工作点过低，会出现截止失真；静态工作点合适时，如果输入信号的幅值过大，则会导致电路同时出现饱和失真和截止失真。&lt;/p&gt;
&lt;h2 id=&#34;思考题&#34;&gt;&lt;a href=&#34;#思考题&#34; class=&#34;headerlink&#34; title=&#34;思考题&#34;&gt;&lt;/a&gt;思考题&lt;/h2&gt;&lt;p&gt;(1)	晶体管的静态工作点不合适。Q点过低时会导致截止失真，Q点过高时会导致饱和失真。可以通过调整RB的阻值来获得最佳静态工作点。&lt;br&gt;(2)	增大负载RL的阻值。&lt;/p&gt;
&lt;h2 id=&#34;实验体会与建议&#34;&gt;&lt;a href=&#34;#实验体会与建议&#34; class=&#34;headerlink&#34; title=&#34;实验体会与建议&#34;&gt;&lt;/a&gt;实验体会与建议&lt;/h2&gt;&lt;p&gt;(1)	体会：在本次实验中，我学会了如何寻找放大电路的最佳静态工作点，并测量和计算最佳静态工作点时电路的各项参数；另外，我还学会了测量并分析电压放大倍数随着负载阻值的改变时产生的变化情况；最后，我还进一步理解了产生饱和失真和截止失真的条件以及两种失真对电路输出电压波形的影响。本次实验是对放大电路的综合考量，极大地增强了我对放大电路的原理及原理图、失真产生条件、输出电压特性、电压电流放大倍数等方面的理解。&lt;br&gt;(2)	建议：在本次实验中，一些原理和步骤较难理解，而且在操作上不易实现，希望能够在正式实验之前能够对实验过程中可能出现的重点难点问题进行相应的提示和指导。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;敲黑板！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;叠加定理与戴维南定理&amp;#x2F;RLC串联谐振电路&amp;#x2F;单管交流电压放大电路&amp;#x2F;集成放大器的应用完整实验报告&lt;/strong&gt;&lt;br&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9LaXNzTW9vbl8vMTkzMjI4OTY=&#34;&gt;https://download.csdn.net/download/KissMoon_&amp;#x2F;19322896&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20210601221106858.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
