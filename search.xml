<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学生成绩管理系统</title>
    <url>/CCPP/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>相信很多同仁在大学学习编程的时候都会被老师要求动手敲出一个学生成绩管理系统或图书馆管理系统之类的程序吧。<br><strong>不得不说，这个程序简直就是大多数初学者的恶梦，毕竟它的内容涉及到了整一个学期学到的所有知识。</strong><br><del>况且，对于像我这种在大学前从来没接触过编程，也不知道代码是啥的绝对萌新来说，更是一次史诗级的灾难。</del> </p>
<p><strong>你见过凌晨四点的教学楼吗？</strong><br><strong>我见过，那时候我刚从里面出来。</strong><br><img data-src="https://img-blog.csdnimg.cn/20210325191305561.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>话不多说，说多了都是泪。</strong></p>
<p>实验要求我就不赘述了吧，无非就是录成绩、各种方式查成绩、名次排序、计算均分等。</p>
<p><strong>还是直接上代码吧，大家都是爽快人！</strong></p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define N 30
#define M 10
#define X 6

/*学生信息结构体，包括学号，姓名，各学科分数，总分，均分*/
typedef struct student
&#123;
  long number;
  char name[M];
  int score[X];
  int stutotal;
  float stuaverage;
&#125;STUDENT;/*对学生信息结构体取别名“STUDENT”*/

/*实现两个结构体的交换，注意，结构体是可以直接赋值的*/
void Swap(STUDENT *a,STUDENT *b)
&#123;
  STUDENT temp;
  temp=*a;
  *a=*b;
  *b=temp;
&#125;

/*由用户用键盘依次输入学生信息*/
void Input(STUDENT stu[],int n,int x)
&#123;
    printf(&quot;\n\n&quot;);
    int i,j;
    for(i=0;i&lt;n;i++)
    &#123;
        printf(&quot;Number:\t&quot;);
        scanf(&quot;%ld&quot;,&amp;stu[i].number);
        getchar();/*清除缓冲区中的回车字符，防止被读入学生姓名*/
        printf(&quot;Name:\t&quot;);
        gets(stu[i].name);
        for(j=0;j&lt;x;j++)
        &#123;
            do&#123;
                printf(&quot;Score %d:&quot;,j+1);
                scanf(&quot;%d&quot;,&amp;stu[i].score[j]);
            &#125;while(stu[i].score[j]&lt;0||stu[i].score[j]&gt;100);/*防止录入异常成绩*/
        &#125;
    &#125;
&#125;

/*计算各学科的总分和均分*/
void SubCalculate(STUDENT stu[],int subtotal[],float subaverage[],int n,int x)
&#123;
    int i,j;
    for(j=0;j&lt;x;j++)
    &#123;
        subtotal[j]=0;/*学科总成绩初始化为0*/
        for(i=0;i&lt;n;i++)
        &#123;
            subtotal[j]=subtotal[j]+stu[i].score[j];
        &#125;
        subaverage[j]=(float)subtotal[j]/n;/*将整型数强转为浮点数后进行浮点数运算，确保数据的准确性*/
        printf(&quot;(subject %d)Total:%d\t\tAverage:%6.2f\n&quot;,j+1,subtotal[j],subaverage[j]);
    &#125;
 &#125;

/*计算每个学生的总分和均分*/
void StuCalculate(STUDENT stu[],int n,int x)
&#123;
    int i,j;
    for(i=0;i&lt;n;i++)
    &#123;
        stu[i].stutotal=0;/*学生总成绩初始化为0*/
        for(j=0;j&lt;x;j++)
        &#123;
            stu[i].stutotal=stu[i].stutotal+stu[i].score[j];
        &#125;
        stu[i].stuaverage=(float)stu[i].stutotal/x;/*将整型数强转为浮点数后进行浮点数运算，确保数据的准确性*/
        printf(&quot;(student %d)Total:%d\t\tAverage:%6.2f\n&quot;,i+1,stu[i].stutotal,stu[i].stuaverage);
    &#125;
&#125;

/*将学生成绩按从高到低的顺序排列*/
void SortStuScoreUpdown(STUDENT stu[],int n)
&#123;
    for (int i = 0; i &lt; n - 1; ++i)
    &#123;
        for (int j = i + 1; j &lt; n; ++j)
        &#123;
            if (stu[i].stutotal &lt; stu[j].stutotal) Swap(&amp;stu[i], &amp;stu[j]);/*如果前面的学生的总成绩小于后面的学生的总成绩，则交换两个学生信息结构体位置*/
        &#125;
      &#125;
&#125;

/*将学生成绩按从低到高的顺序排列*/
void SortStuScoreDownup(STUDENT stu[],int n)
&#123;
        for (int i = 0; i &lt; n - 1; ++i)
    &#123;
        for (int j = i + 1; j &lt; n; ++j)
        &#123;
            if (stu[i].stutotal &gt; stu[j].stutotal) Swap(&amp;stu[i], &amp;stu[j]);/*如果前面的学生的总成绩大于后面的学生的总成绩，则交换两个学生信息结构体位置*/
        &#125;
      &#125;
&#125;

/*将学生学号按从小到大排列*/
void SortNumberDownup(STUDENT stu[],int n)
&#123;
        for (int i = 0; i &lt; n - 1; ++i)
    &#123;
        for (int j = i + 1; j &lt; n; ++j)
        &#123;
            if (stu[i].number &gt; stu[j].number) Swap(&amp;stu[i], &amp;stu[j]);/*如果前面的学生的学号大于后面的学生的学号，则交换两个学生信息结构体位置*/
        &#125;
      &#125;
&#125;

/*将学生姓名按字典顺序排列*/
void SortName(STUDENT stu[],int n)
&#123;
    for (int i = 0; i &lt; n - 1; ++i)
    &#123;
        for (int j = i + 1; j &lt; n; ++j)
        &#123;
            if (strcmp(stu[i].name,stu[j].name)&gt;0) Swap(&amp;stu[i], &amp;stu[j]);/*如果前面的学生的字母序位大于后面的学生的字母序位，则交换两个学生信息结构体位置*/
        &#125;
      &#125;
&#125;

/*按学号查找学生并输出学生信息*/
void SearchNumber(STUDENT stu[],int n,int x)
&#123;
    int i,j,flag=0;/*未找到学生时flag初始化为0*/
    long temp;
    printf(&quot;Input the number:\t&quot;);
    scanf(&quot;%ld&quot;,&amp;temp);
    getchar();
    SortStuScoreUpdown(stu,n);/*将学生按照成绩从高到低排序以获得学生的排名情况*/
    for(i=0;i&lt;n;i++)/*将录入的学生学号与待查学号进行一一比对*/
    &#123;
        if(stu[i].number==temp)/*找到与待查学号一致的学号*/
        &#123;
            flag=1;/*找到学号对应的学生时，flag被赋值为1*/
            printf(&quot;Name:     \tNumber:      \tPosition:\tTotalscore:\tAveragescore:\t  Subjectscores:\n&quot;);
            printf(&quot;%-10s\t%-13ld\t%9d\t%11d\t%13.2f\t&quot;,stu[i].name,stu[i].number,i+1,stu[i].stutotal,stu[i].stuaverage);
            for(j=0;j&lt;x;j++)
            &#123;
                printf(&quot;%4d&quot;,stu[i].score[j]);
            &#125;
            printf(&quot;\n&quot;);
            break;
        &#125;
    &#125;
    if(flag==0)/*未找到学号对应学生时，flag的值仍为0*/
    &#123;
        printf(&quot;\nNot find!\n&quot;);
    &#125;
&#125;

/*按姓名查找学生并输出学生信息*/
void SearchName(STUDENT stu[],int n,int x)
&#123;
    int i,j,flag=0;/*未找到学生时flag初始化为0*/
    char tep[M];
    printf(&quot;Input the name:\t&quot;);
  scanf(&quot; %s&quot;,tep);
    SortStuScoreUpdown(stu,n);/*将学生按照成绩从高到低排序以获得学生的排名情况*/
    for(i=0;i&lt;n;i++)/*将录入的学生姓名与待查姓名进行一一比对*/
    &#123;
        if(strcmp(stu[i].name,tep)==0)/*找到与待查姓名字母顺序完全一致的姓名*/
        &#123;
            flag=1;/*找到学号对应的学生时，flag被赋值为1*/
            printf(&quot;Name:     \tNumber:      \tPosition:\tTotalscore:\tAveragescore:\t  Subjectscores:\n&quot;);
            printf(&quot;%-10s\t%-13ld\t%9d\t%11d\t%13.2f\t&quot;,stu[i].name,stu[i].number,i+1,stu[i].stutotal,stu[i].stuaverage);
            for(j=0;j&lt;x;j++)
            &#123;
                printf(&quot;%4d&quot;,stu[i].score[j]);
            &#125;
            printf(&quot;\n&quot;);
            break;
        &#125;
    &#125;
    if(flag==0)/*未找到学号对应学生时，flag的值仍为0*/
    &#123;
        printf(&quot;\nNot find!\n&quot;);
    &#125;
&#125;

/*统计并打印出各学科各阶段人数及占比*/
void Analysis(STUDENT stu[],int n,int x)
&#123;
    int a[N]=&#123;0&#125;,b[N]=&#123;0&#125;,c[N]=&#123;0&#125;,d[N]=&#123;0&#125;,e[N]=&#123;0&#125;;
    int i,j;
    for(j=0;j&lt;x;j++)
    &#123;
        for(i=0;i&lt;n;i++)
        &#123;
            if    (100&gt;=stu[i].score[j]&amp;&amp;90&lt;=stu[i].score[j])    a[j]++;
            else if(89&gt;=stu[i].score[j]&amp;&amp;80&lt;=stu[i].score[j])    b[j]++;
            else if(79&gt;=stu[i].score[j]&amp;&amp;70&lt;=stu[i].score[j])    c[j]++;
            else if(69&gt;=stu[i].score[j]&amp;&amp;60&lt;=stu[i].score[j])    d[j]++;
            else                                                           e[j]++;
        &#125;
    &#125;
    for(j=0;j&lt;x;j++)
    &#123;
        printf(&quot;Subject No.%d:\n&quot;,j+1);
        printf(&quot;Excellent:%d\tpercent:%.2f%%\n&quot;,a[j],(float)100*a[j]/n);
        printf(&quot;Good:     %d\tpercent:%.2f%%\n&quot;,b[j],(float)100*b[j]/n);
        printf(&quot;Medium:   %d\tpercent:%.2f%%\n&quot;,c[j],(float)100*c[j]/n);
        printf(&quot;Pass:     %d\tpercent:%.2f%%\n&quot;,d[j],(float)100*d[j]/n);
        printf(&quot;Failed:   %d\tpercent:%.2f%%\n&quot;,e[j],(float)100*e[j]/n);
        printf(&quot;\n&quot;);
    &#125;
    printf(&quot;\n&quot;);
&#125;

/*输出各学生的学生信息及各课程的总分和均分*/
void List(STUDENT stu[],int subtotal[],float subaverage[],int n,int x)
&#123;
    int i,j;
    printf(&quot;Name:     \tNumber:      \tTotalscore:\tAveragescore:\tSub 1:Sub 2:Sub 3:Sub 4:Sub 5:Sub 6:\n&quot;);
    for(i=0;i&lt;n;i++)
    &#123;
        printf(&quot;%-10s\t%-13ld\t%11d\t%13.2f\t&quot;,stu[i].name,stu[i].number,stu[i].stutotal,stu[i].stuaverage);
        for(j=0;j&lt;x;j++)
        &#123;
            printf(&quot;%6d&quot;,stu[i].score[j]);
        &#125;
        printf(&quot;\n&quot;);
    &#125;
     printf(&quot;          \t             \t           \t           \t&quot;);
     for(j=0;j&lt;x;j++)
     &#123;
      printf(&quot;%6d&quot;,subtotal[j]);
     &#125;
      printf(&quot;\n&quot;);
      printf(&quot;         \t             \t           \t          \t&quot;);
      for(j=0;j&lt;x;j++)
      &#123;
          printf(&quot;%6.2f&quot;,subaverage[j]);
      &#125;
&#125;

/*打印姓名，学号，总分，均分及各学科的分数*/
void Print1(STUDENT stu[],int n,int x)
&#123;
    int i,j;
    printf(&quot;Name:     \tNumber:\t      Totalscore:\tAveragescore:\tSubjectscore:\n&quot;);
    for(i=0;i&lt;n;i++)
    &#123;
        printf(&quot;%-10s\t%-13ld\t%9d\t%13.2f\t&quot;,stu[i].name,stu[i].number,stu[i].stutotal,stu[i].stuaverage);
        for(j=0;j&lt;x;j++)
        &#123;
            printf(&quot;%-6d&quot;,stu[i].score[j]);
        &#125;
        printf(&quot;\n&quot;);
    &#125;
&#125;

/*打印各课程的总分和均分*/
void Print2(int subtotal[],float subaverage[],int x)
&#123;
  int i;
  for(i=0;i&lt;x;i++)
  &#123;
    printf(&quot;subtotal No.%d: %-6d\tsubaverage No.%d: %-6.2f\n&quot;,i+1,subtotal[i],i+1,subaverage[i]);
  &#125;
&#125;

/*将信息写入文件并保存*/
void WritetoFile(STUDENT stu[],int subtotal[],float subaverage[],int n,int x)
&#123;
  FILE *fp;
  int i,j;
  if((fp=fopen(&quot;score.txt&quot;,&quot;w&quot;))==NULL)/*检验文件是否打开成功*/
  &#123;
    printf(&quot;Failure to open score.txt!\n&quot;);
    exit(0);
  &#125;
  fprintf(fp,&quot;%d\t%d\n&quot;,n,x);
  for(i=0;i&lt;n;i++)
  &#123;
    fprintf(fp,&quot;%-10s\t%-13ld\t%11d\t%13.2f\t&quot;,stu[i].name,stu[i].number,stu[i].stutotal,stu[i].stuaverage);
     for(j=0;j&lt;x;j++)
        &#123;
            fprintf(fp,&quot;%-6d\n&quot;,stu[i].score[j]);
        &#125;
  &#125;
  for(j=0;j&lt;x;j++)
  &#123;
      fprintf(fp,&quot;%d\t%f\n&quot;,subtotal[j],subaverage[j]);
  &#125;
  fclose(fp);
&#125;

/*从文件中读取出信息*/
void ReadfromFile(STUDENT stu[],int subtotal[],float subaverage[],int *n,int *x)
&#123;
  FILE *fp;
  int i,j;
  if((fp=fopen(&quot;score.txt&quot;,&quot;r&quot;))==NULL)/*检验文件是否打开成功*/
  &#123;
    printf(&quot;Failure to open score.txt!\n&quot;);
    exit(0);
  &#125;
   fscanf(fp,&quot;%d\t%d\n&quot;,n,x);
  for(i=0;i&lt;*n;i++)
    &#123;
      fscanf(fp,&quot;%10s&quot;,stu[i].name);
      fscanf(fp,&quot;%13ld&quot;,&amp;stu[i].number);
      fscanf(fp,&quot;%11d&quot;,&amp;stu[i].stutotal);
      fscanf(fp,&quot;%f&quot;,&amp;stu[i].stuaverage);
      for(j=0;j&lt;*x;j++)
      &#123;
        fscanf(fp,&quot;%6d&quot;,&amp;stu[i].score[j]);
      &#125;
    &#125;
    for(j=0;j&lt;*x;j++)
    &#123;
        fscanf(fp,&quot;%d\t%f&quot;,&amp;subtotal[j],&amp;subaverage[j]);
    &#125;
    fclose(fp);
&#125;

int main()
&#123;
    int m,n,x;
    int subtotal[X];
    float subaverage[X];
    STUDENT stu[N];
    do&#123;
        printf(&quot;Input the total number of students:&quot;);
        scanf(&quot;%d&quot;,&amp;n);
        printf(&quot;Input the total number of subjects:&quot;);
        scanf(&quot;%d&quot;,&amp;x);
    &#125;while(n&lt;=0||n&gt;30||x&lt;1||x&gt;6);/*检测学生总人数及学科总数是否符合要求*/
 KG:printf(&quot;\n\n1.Input record\n2.Calculate total and average score of every course\n3.Calculate total and average score of every student\n&quot;);
      printf(&quot;4.Sort in descending order by total score of every student\n5.Sort in ascending order by total score of every student\n&quot;);
      printf(&quot;6.Sort in ascending order by number\n7.Sort in dictionary order by name\n8.Search by number\n&quot;);
      printf(&quot;9.Search by name\n10.Statistic analysis for every course\n11.List record\n&quot;);
      printf(&quot;12.Write to a file\n13.Read from a file\n0.Exit\n\nPlease enter your choice:&quot;);
      scanf(&quot;%d&quot;,&amp;m);/*打印出菜单栏以供用户选择操作*/
    switch(m)/*利用switch语句实现菜单中的各个功能*/
    &#123;
      case 1: Input(stu,n,x);
               break;
      case 2: SubCalculate(stu,subtotal,subaverage,n,x);
               break;
      case 3:StuCalculate(stu,n,x);
               break;
      case 4: SortStuScoreUpdown(stu,n);
               Print1(stu,n,x);
              break;
      case 5: SortStuScoreDownup(stu,n);
              Print1(stu,n,x);
             break;
      case 6: SortNumberDownup(stu,n);
              Print1(stu,n,x);
            break;
      case 7: SortName(stu,n);
              Print1(stu,n,x);
            break;
      case 8: SearchNumber(stu,n,x);
            break;
      case 9: SearchName(stu,n,x);
            break;
      case 10: Analysis(stu,n,x);
            break;
      case 11: List(stu,subtotal,subaverage,n,x);
            break;
      case 12:WritetoFile(stu,subtotal,subaverage,n,x);
            break;
      case 13:ReadfromFile(stu,subtotal,subaverage,&amp;n,&amp;x);
                Print1(stu,n,x);
                Print2(subtotal,subaverage,x);
            break;
      case 0: exit(0);
    &#125;
   if(m!=0||m&lt;0||m&gt;13) goto KG;/*检测用户选择是否出错，并利用goto语句实现跳转*/
   return 0;
&#125;
</code></pre>
<p>以上就是该实验的全部代码。（<del>毫无保留，直接裸奔！！！</del> ）</p>
<p><img data-src="https://img-blog.csdnimg.cn/20210325193106921.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>实验数据我就不给了吧。</p>
<p><strong>本人王者荣耀迷和KPL迷，实验数据全是英雄名和选手名（说实话，选手们的ID确实好听），估计助教在看实验的时候都笑出猪叫了。（<del>助教笑出猪叫？？？</del> 啪，又来套娃！）</strong></p>
<p>有相同兴趣的小伙伴们可以找我一起观赛掉分。<del>本人厨艺精湛，饭多管饱！！！</del> </p>
<p><img data-src="https://img-blog.csdnimg.cn/20210325194414574.jpg#pic_center" alt="在这里插入图片描述"></p>
<p><strong>敲黑板！！！</strong></p>
<p><strong>如果大佬们不幸看了我的代码，欢迎指导！！！（毕竟这时大一刚学的时候写的，估计bug一堆，很多代码也不是最优的）<br>如果萌新们不幸看了我的代码，欢迎交流！！！（如果你也备受这个实验困扰，希望这篇文章能够帮助到你）</strong></p>
<p><strong>最后，有被学生成绩管理系统和图书馆管理系统折磨过的同仁，举个爪子示意一下，让我知道我并不孤单！</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/2021032519443410.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>C/CPP语言</category>
        <category>学生成绩管理系统</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP语言基础</title>
    <url>/CCPP/CPP%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C/CPP语言</category>
        <category>CPP语言基础</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络的基本概念</title>
    <url>/ComputerNetwork/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机网络</category>
        <category>计算机网络的基本概念</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>排序查找及其应用</title>
    <url>/DataStructure/%E6%8E%92%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="题目一：邮局兴建问题"><a href="#题目一：邮局兴建问题" class="headerlink" title="题目一：邮局兴建问题"></a>题目一：邮局兴建问题</h2><p><strong>题目简述：</strong><br>在一个小镇上准备要兴建邮局，需要把邮局建立在合适的位置，从而使得所有小镇居民去寄件和收取快递时行走的总路途最短。<br>（1）距离计算采用曼哈顿距离公式<br>distance(p1, p2) &#x3D; |p2.x − p1.x| + |p2.y − p1.y|<br>（2）为了简化问题，允许邮局坐标和住户坐标重合</p>
<p><strong>输入格式：</strong><br>第一行为住户数目，第二行开始为每个住户的坐标</p>
<p><strong>输出格式：</strong><br>最短总距离</p>
<p><strong>输入示例1：</strong><br>3<br>0 0<br>0 4<br>2 2</p>
<p><strong>输出示例1：</strong><br>6</p>
<p><strong>解释：</strong><br>三个住户分别住在(0, 0), (0, 4), (2, 2)，如图中的‘1’所标示的地方。<br>当把邮局建在点(0, 2)时，如图中的‘X’所标示的地方<br>最短的距离之和为2+2+2&#x3D;6。</p>
<p><img data-src="https://img-blog.csdnimg.cn/202107012015402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>输入示例2：</strong><br>6<br>0 2<br>0 4<br>1 0<br>1 2<br>1 4<br>2 2</p>
<p><strong>输出示例2：</strong><br>9</p>
<p><strong>解释：</strong><br>六个住户分别住在(0, 2), (0, 4), (1, 0),(1, 2), (1, 4), (2, 2)。<br>当把邮局建在点(1, 2)时，最短的距离之和为1+3+2+0+2+1&#x3D;9。<br><img data-src="https://img-blog.csdnimg.cn/20210701201654985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="题目二：邮递员年龄间隔"><a href="#题目二：邮递员年龄间隔" class="headerlink" title="题目二：邮递员年龄间隔"></a>题目二：邮递员年龄间隔</h2><p><strong>题目简述：</strong><br>邮局建立后，准备招收若干邮递员。邮递员年龄在18岁到65岁之间。<br>现给出未排序的邮递员年龄的数组，求相邻年龄间隔的最大值。<br>Tips: 邮递员数量小于等于1000<br>Tips: 要求时间复杂度和空间复杂度都为O(n)</p>
<p><strong>输入示例：</strong><br>4<br>23 46 29 41</p>
<p><strong>输出示例：</strong><br>12</p>
<p><strong>解释：</strong><br>排序后为[23, 29, 41, 46]，最大间隔值为41-29&#x3D;12。</p>
<h2 id="题目三：街道归属问题"><a href="#题目三：街道归属问题" class="headerlink" title="题目三：街道归属问题"></a>题目三：街道归属问题</h2><p><strong>题目简述：</strong><br>一个邮递员负责一个街道的派送，一个街道由一个或一个以上的邮递员负责。<br>现在向邮递员提问，邮递员不清楚其他街道的情况，只能回答有多少个邮递员和他负责同一条街道。不一定所有邮递员都会回答。根据邮递员的回答推断邮局最少有多少名邮递员。<br>Tips: 邮递员数量小于等于1000</p>
<p><strong>输入格式：</strong><br>第一行为参与回答的邮递员数目n，第二行为n个正整数，空格间隔。</p>
<p><strong>输出格式：</strong><br>正整数，表示最少的邮递员数目。</p>
<p><strong>输入示例1：</strong><br>3<br>1 1 2</p>
<p><strong>输出示例1：</strong><br>5</p>
<p><strong>解释：</strong><br>两个邮递员说有1名同事和自己负责同一个街道，可以认为这两个邮递员属于同一个街道；<br>第三名邮递员说有两名同事和自己负责同一个街道，说明他和前两名邮递员不负责同一条；<br>所以邮局至少有5名邮递员。</p>
<p><strong>输入示例2：</strong><br>4<br>1 1 2 2</p>
<p><strong>输出示例2：</strong><br>5</p>
<p><strong>解释：</strong><br>两个邮递员说有1名同事和自己负责同一个街道，可以认为这两个邮递员属于同一个街道;<br>后面两名邮递员说有两名同事和自己负责同一个街道，说明他们和前两名邮递员不负责同一条;<br>所以邮局至少有5名邮递员。</p>
<h2 id="简要解析"><a href="#简要解析" class="headerlink" title="简要解析"></a>简要解析</h2><p>第一题考察的主要知识点就是排序。只需分别对所有的x坐标和y坐标进行排序，然后根据住户的数量为奇数还是偶数选择有序数组相应的中间值即可。</p>
<p>第二题考察的主要知识点也是排序，只需将邮递员的年龄进行排序，然后依次计算相邻快递员年龄的差并取最大值即可。</p>
<p>第三题考察的主要知识点也是排序，解题难度稍大。可以将快递员同事数量按照非递减的顺序排列，之后可以分为以下三种情况：<br>①连续n+1个快递员都说自己有n个同事，那么这n+1个快递员属于同一街道。<br>比如2	2	 2，那么这三个快递员可以分配在同一街道。<br>②连续k个快递员都说自己有n个同事（k＜n+1），那么这k个快递员属于同一街道，并且需要补上没有回答的n-k+1个快递员。<br>比如2	2，那么这两个快递员可以分配在同一街道，并且该街道有1名快递员没有参与回答。</p>
<p>③连续k个快递员都说自己有n个同事（k＞n+1），那么可以每次把连续的n+1个快递员按第一种方式处理，把最后剩下的s个快递员按第二种方式处理（s＜n+1）。</p>
<h2 id="求解代码"><a href="#求解代码" class="headerlink" title="求解代码"></a>求解代码</h2><pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MaxNum 1000//邮递员数量、住户数量的最大值
#define MinNum 0//邮递员数量、住户数量的最小值
#define MaxAge 65//邮递员年龄的最大值
#define MinAge 18//邮递员年龄的最小值
#define MAX(a,b) ((a&gt;b) ? a : b)//返回a、b中的较大值
#define MIN(a,b) ((a&lt;b) ? a : b)//返回a、b中的较小值

//交换数组中相应区段元素的位置，使枢轴元素到位，并返回其所在位置，此时在它前(后)面的元素均不大(小)于它
int Partition(int nums[], int low, int high)
&#123;
    int pivotkey;//枢轴
    pivotkey = nums[low];
    while(low &lt; high)
    &#123;
        while((low &lt; high) &amp;&amp; (nums[high] &gt;= pivotkey))high--;//找到比枢轴元素小的元素
        nums[low] = nums[high];//将小的元素换到低端
        while((low &lt; high) &amp;&amp; (nums[low] &lt;= pivotkey))low++;//找到比枢轴元素大的元素
        nums[high] = nums[low];//将大的元素换到高端
    &#125;
    nums[low] = pivotkey;//枢轴元素到位
    return low;//返回枢轴元素所在位置
&#125;

//快速排序的递归形式，将数组中相应区段的元素按非递减的顺序排列
void QSort(int nums[], int low, int high)
&#123;
    int pivotkey;//枢轴
    if(low &lt; high)
    &#123;
        pivotkey = Partition(nums, low, high);//枢轴元素的位置
        QSort(nums, low, pivotkey-1);//对子数组进行快速排序
        QSort(nums, pivotkey+1, high);//对子数组进行快速排序
    &#125;
&#125;

//快速排序算法
void QuickSort(int nums[], int numsSize)
&#123;
    QSort(nums, 0, numsSize-1);//调用函数对数组进行排序
&#125;

//求解邮局与所有住户之间的最小总距离
int MinTotalDistance(int X[], int Y[], int n)
&#123;
    int distance = 0;//初始最小总距离为0
    int i, temp;
    if(!n)//住户数量为0
        return -1;
    QuickSort(X, n);//将x坐标数组按非递减顺序排列
    QuickSort(Y, n);//将y坐标数组按非递减顺序排列
    if(n%2)
        temp = (n-1)/2;//n为奇数时有序数组中间值的下标，即满足取得最小距离的邮局的位置的x坐标和y坐标在数组中的下标
    else
        temp = n/2;//n为偶数是有序数组中间值的下标，即满足取得最小距离的邮局的位置的x坐标和y坐标在数组中的下标
    for(i = 0; i &lt; n; i++)
    &#123;
        distance += (abs(X[temp] - X[i]) + abs(Y[temp] - Y[i]));//最小总距离等于邮局和所有住户之间x坐标及y坐标的差值的绝对值之和
    &#125;
    return distance;
&#125;

//求解按年龄排列的相邻两个邮递员之间的最大年龄差
int MaximumGap(int nums[], int numsSize)
&#123;
    int i, Max = 0;//初始最大年龄差为0
    if(numsSize == 0)//邮递员数量为0
        return -2;
    if(numsSize == 1)//当只有一个邮递员时，最大年龄差为-1
        return -1;
    QuickSort(nums, numsSize);//将年龄数组按非递减顺序排列
    for(i = 0; i &lt; numsSize-1; i++)
    &#123;
        Max = MAX((nums[i+1] - nums[i]), Max);//不断更新最大年龄差
    &#125;
    return Max;
&#125;

//求解邮局中邮递员数量的最小值
int GetMinPostman(int nums[],int n)
&#123;
    int pNumber=0;//初始数量为0
    int i, j, temp, flag;//flag标志能否将邮递员安排在同一街道
    if(!n)//参与回答的邮递员的数量为0
        return -2;
    QuickSort(nums, n);//将同事数量数组按非递减顺序排列
    for(i = 0; i &lt; n; )//遍历同事数量数组
    &#123;
        flag = 1;
        temp = nums[i];//同事数量
        if(temp)//同事数量大于0
        &#123;
            for(j = 1; j &lt;= temp; j++)//遍历当前元素之后的temp个元素，判断能否将其安排在同一街道
            &#123;
                if(nums[i+j] != temp)//存在同事数量不等的元素
                &#123;
                    flag = 0;//不能将其安排在同一街道
                    break;//停止遍历
                &#125;
            &#125;
        &#125;
        if(flag)//邮递员可以安排在同一街道
        &#123;
            pNumber += (temp + 1);//邮递员数量增加temp+1个，即该街道有temp+1个邮递员
            i += (temp + 1);//下一遍历位置 = 当前遍历位置 + temp + 1，即跨过同一街道中的temp+1个邮递员
        &#125;
        else//邮递员不能安排在同一街道
        &#123;
            pNumber += (j * (temp + 1));//j表示邮递员数量相等的街道的个数，且每个街道有temp+1个邮递员
            i += j;//下一遍历位置 = 当前遍历位置 + j，即跨过j个含有相同数量的邮递员的街道
        &#125;
    &#125;
    return (pNumber &gt; MinNum &amp;&amp; pNumber &lt;= MaxNum)? pNumber : -1;
&#125;

//输入数据方式
void Input(char *choice)
&#123;
    while(getchar() != &#39;\n&#39;)continue;
    printf(&quot;\n1.Manual input  2.File input  else.Quit\n&quot;);
    printf(&quot;Input your choice:  &quot;);
    scanf(&quot;%c&quot;, choice);
&#125;

//重新选择功能
void Continue(char *order)
&#123;
    while(getchar() != &#39;\n&#39;)continue;
    printf(&quot;\nDo you want to reselect a function(Y/N)?  &quot;);
    scanf(&quot;%c&quot;, order);
    while(getchar() != &#39;\n&#39;)continue;
    printf(&quot;\n&quot;);
&#125;

//邮局与所有居民之间的最小总距离
char Task_one()
&#123;
    int n, count = 1;//n表示住户的数量
    char choice, order = &#39;N&#39;;
    Input(&amp;choice);//选择输入数据的方式
    switch (choice)
    &#123;
        case &#39;1&#39;:
            while(getchar() != &#39;\n&#39;)continue;
            printf(&quot;\nInput the number of households(%d-%d,else to quit):  &quot;, MinNum, MaxNum);
            while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n &gt;= MinNum &amp;&amp; n &lt;= MaxNum)
            &#123;
                count = 1;
                int X[n], Y[n];//坐标数组,用于保存住户的x坐标和y坐标
                for(int i = 0; i &lt; n; i++)
                &#123;
                    while(getchar() != &#39;\n&#39;)continue;
                    printf(&quot;Input the No.%02d household coordinates(x,y):  &quot;, count++);
                    scanf(&quot;%d,%d&quot;, &amp;X[i], &amp;Y[i]);
                &#125;
                printf(&quot;The minimum total distance is %d.\n&quot;, MinTotalDistance(X, Y, n));//调用函数求解最小总距离
                printf(&quot;\nInput the number of households(%d-%d,else to quit):  &quot;, MinNum, MaxNum);
            &#125;
            Continue(&amp;order);
            break;
        case &#39;2&#39;:
            printf(&quot;\n(Filename: 5_1_input.in)\nThe results are as follows:\n&quot;);//同步修改文件名
            freopen(&quot;5_1_input.in&quot;, &quot;r&quot;, stdin);
            while(scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n &gt;= MinNum &amp;&amp; n &lt;= MaxNum)
            &#123;
                int X[n], Y[n];//坐标数组,用于保存住户的x坐标和y坐标
                for (int i = 0; i &lt; n; i++)
                &#123;
                    if(scanf(&quot;%d%d&quot;, &amp;X[i], &amp;Y[i]) == EOF)//文件数据不足
                    &#123;
                        printf(&quot;Insufficient data.Please check the data in the file.\n&quot;);
                        exit(0);
                    &#125;
                &#125;
                printf(&quot;Case %02d: The minimum total distance is %d.\n&quot;, count++, MinTotalDistance(X, Y, n));//调用函数求解最小总距离
            &#125;
            fclose(stdin);
            break;
        default:
            Continue(&amp;order);
            break;
    &#125;
    return order;
&#125;

//按年龄排列的相邻两个邮递员之间的最大年龄差MinAge 18//邮递员年龄的最小值
char Task_two()
&#123;
    int n;//邮递员数量
    int count = 1;
    char choice, order = &#39;N&#39;;
    Input(&amp;choice);//选择输入数据的方式
    switch (choice)
    &#123;
        case &#39;1&#39;:
            while(getchar() != &#39;\n&#39;)continue;
            printf(&quot;\nInput the number of postmen(%d-%d,else to quit):  &quot;, MinNum, MaxNum);
            while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n &gt;= MinNum &amp;&amp; n &lt;= MaxNum)
            &#123;
                count = 1;
                int nums[n];//年龄数组，用于保存邮递员的年龄
                for(int i = 0; i &lt; n; i++)
                &#123;
                    while(getchar() != &#39;\n&#39;)continue;
                    printf(&quot;Input the age of the No.%02d postman(%d-%d):  &quot;, count++, MinAge, MaxAge);
                    while(!scanf(&quot;%d&quot;, &amp;nums[i]) || nums[i] &lt; MinAge || nums[i] &gt; MaxAge)
                    &#123;
                        while(getchar() != &#39;\n&#39;)continue;
                        printf(&quot;Out of range.Input again:  &quot;);
                    &#125;
                &#125;
                printf(&quot;The maximum age difference is %d.\n&quot;, MaximumGap(nums, n));//调用函数求解最大年龄差
                printf(&quot;\nInput the number of postmen(%d-%d,else to quit):  &quot;, MinNum, MaxNum);
            &#125;
            Continue(&amp;order);
            break;
        case &#39;2&#39;:
            printf(&quot;\n(Filename: 5_2_input.in)The results are as follows:\n&quot;);//同步修改文件名
            freopen(&quot;5_2_input.in&quot;, &quot;r&quot;, stdin);
            while(scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n &gt;= MinNum &amp;&amp; n &lt;= MaxNum)
            &#123;
                int nums[n];  //快递员年龄数组
                for(int i = 0;i &lt; n;i++)
                &#123;
                    while(scanf(&quot;%d&quot;, &amp;nums[i]) == EOF || nums[i] &lt; MinAge || nums[i] &gt; MaxAge)
                    &#123;
                        if(scanf(&quot;%d&quot;, &amp;nums[i]) == EOF)//文件数据不足
                        &#123;
                            printf(&quot;Insufficient data.Please check the data in the file.\n&quot;);//文件数据不足
                            exit(0);
                        &#125;
                    &#125;
                &#125;
                printf(&quot;Case %02d: The maximum age difference is %d.\n&quot;, count++, MaximumGap(nums, n));//调用函数求解最大年龄差
            &#125;
            fclose(stdin);
            break;
        default:
            Continue(&amp;order);
            break;
    &#125;
    return order;
&#125;

//邮局中邮递员数量的最小值
char Task_three()
&#123;
    int n, i, count = 1;//n表示参与回答的邮递员的数量
    char choice, order = &#39;N&#39;;
    Input(&amp;choice);//选择输入数据的方式
    switch (choice)
    &#123;
        case &#39;1&#39;:
            while(getchar() != &#39;\n&#39;)continue;
            printf(&quot;\nInput the number of the answering postmen(&gt;0,else to quit):  &quot;);
            while(scanf(&quot;%d&quot;, &amp;n))
            &#123;
                count = 1;
                int nums[n];//同事数量数组，用于保存邮递员所在街道内的同事数量
                for(i = 0; i &lt; n; i++)
                &#123;
                    while(getchar() != &#39;\n&#39;)continue;
                    printf(&quot;Input the answer of the NO.%02d postman:  &quot;, count++);
                    while(!scanf(&quot;%d&quot;, &amp;nums[i]) || nums[i] &lt; MinNum || nums[i] &gt;= MaxNum)
                    &#123;
                        while(getchar() != &#39;\n&#39;)continue;
                        printf(&quot;Out of range.Input again:  &quot;);
                    &#125;
                &#125;
                printf(&quot;(Effective range: %d-%d)The minimum number of postmen is %d.\n&quot;, MinNum, MaxNum, GetMinPostman(nums, n));//调用函数求解邮递员的最小数量
                printf(&quot;\nInput the number of the answering postmen(&gt;0,else to quit):  &quot;);
            &#125;
            Continue(&amp;order);
            break;
        case &#39;2&#39;:
            printf(&quot;\n(Filename: 5_3_input.in)The results are as follows:\n&quot;);//同步修改文件名
            freopen(&quot;5_3_input.in&quot;, &quot;r&quot;, stdin);
            while(scanf(&quot;%d&quot;, &amp;n) != EOF)
            &#123;
                int nums[n];//同事数量数组，用于保存邮递员所在街道内的同事数量
                for(i = 0; i &lt; n; i++)
                &#123;
                    if(scanf(&quot;%d&quot;, &amp;nums[i]) == EOF || nums[i] &lt; MinNum || nums[i] &gt;= MaxNum)
                    &#123;
                        if(scanf(&quot;%d&quot;, &amp;nums[i]) == EOF)//文件数据不足
                        &#123;
                            printf(&quot;Insufficient data.Please check the data in the file.\n&quot;);//文件数据不足
                            exit(0);
                        &#125;
                    &#125;
                &#125;
                printf(&quot;Case %02d: (Effective range: %d-%d)The minimum number of postmen is %d.\n&quot;, count++, MinNum, MaxNum, GetMinPostman(nums, n));//调用函数求解邮递员的最小数量
            &#125;
            fclose(stdin);
            break;
        default:
            Continue(&amp;order);
            break;
    &#125;
    return order;
&#125;

int main()
&#123;
    char choice, order;
    do&#123;
        printf(&quot;1.Get the minimum total distance between the post office and all residents\n&quot;);
        printf(&quot;2.Get the maximum age difference between two adjacent postmen arranged by age\n&quot;);
        printf(&quot;3.Get the minimum number of postmen in the post office           else.Quit\n&quot;);
        printf(&quot;Input your choice:  &quot;);
        scanf(&quot;%c&quot;, &amp;choice);//选择功能
        switch (choice)
        &#123;
            case &#39;1&#39;:
                    order = Task_one();
                    break;
            case &#39;2&#39;:
                    order = Task_two();
                    break;
            case &#39;3&#39;:
                    order = Task_three();
                    break;
            default:
                exit(0);
        &#125;
    &#125;while(order == &#39;Y&#39; || order == &#39;y&#39;);//Y或y表示重新选择功能
    return 0;
&#125;
</code></pre>
<p><strong>敲黑板！！！排序和搜索非常常用，需要清楚地知道每一种排序方法和搜索方法的逻辑、代码、时间复杂度、空间复杂度等。</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210702150108347.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序查找及其应用</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章-人工智能的概述</title>
    <url>/ArtificialIntelligence/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="人工智能概述"><a href="#人工智能概述" class="headerlink" title="人工智能概述"></a>人工智能概述</h1><h2 id="人工智能的定义"><a href="#人工智能的定义" class="headerlink" title="人工智能的定义"></a>人工智能的定义</h2><h3 id="什么是智能"><a href="#什么是智能" class="headerlink" title="什么是智能"></a>什么是智能</h3><ul>
<li>自然智能：指人类和一些动物所具有的智力和行为能力。</li>
<li>人类的自然智能（简称智能）：指人类在认识客观世界中，由思维过程和脑力活动所表现出的综合能力。</li>
</ul>
<h3 id="智能的不同观点"><a href="#智能的不同观点" class="headerlink" title="智能的不同观点"></a>智能的不同观点</h3><ul>
<li>思维理论：<strong>智能来源于思维活动，智能的核心是思维，人的一切知识都是思维的产物</strong>。可望通过对思维规律和思维方法的研究来揭示智能的本质。</li>
<li>知识阈值理论：<strong>智能取决于知识的数量及其可运用程度</strong>。一个系统所具有的可运用知识越多，其智能就会越高。</li>
<li>进化理论：智能取决于感知和行为，取决于对外界复杂环境的适应，智能不需要知识、不需要表示、不需要推理，<strong>智能可由逐步进化来实现</strong>。（MIT，Brooks，人造机器虫研究）</li>
</ul>
<h3 id="智能的层次结构"><a href="#智能的层次结构" class="headerlink" title="智能的层次结构"></a>智能的层次结构</h3><ul>
<li>高层智能：以大脑皮层（抑制中枢）为主，主要完成记忆、思维等活动。</li>
<li>中层智能：以丘脑（间脑，感觉中枢）为主，主要完成感知活动。</li>
<li>低层智能：以小脑、脊髓为主，主要完成动作反应活动。</li>
<li><strong>思维理论和知识阈值理论对应高层智能，而进化理论对应中层智能和低层智能</strong>。</li>
</ul>
<h3 id="智能包含的能力"><a href="#智能包含的能力" class="headerlink" title="智能包含的能力"></a>智能包含的能力</h3><ul>
<li><p>感知能力：<strong>人类获得外界信息的基本途径</strong>。</p>
<p>感知–动作方式：对简单、紧急的信息。</p>
<p>感知–思维–动作方式：对复杂的信息。</p>
</li>
<li><p>记忆和思维的能力：</p>
<p>记忆：对感知到的外界信息和由思维产生的内部知识的<strong>存储</strong>过程。</p>
<p>思维：对已存储信息或知识的本质属性、内部规律的<strong>认识</strong>过程。</p>
<p>思维方式：</p>
<ul>
<li>抽象思维（逻辑思维）：根据<strong>逻辑规则</strong>对信息和知识进行处理的理性思维方式。</li>
<li>形象思维（直感思维）：根据<strong>感性形象认识材料</strong>对客观现象进行处理的一种思维方式。</li>
<li>灵感思维（顿悟思维）：是一种显意识和潜意识相互作用的思维方式。</li>
</ul>
</li>
<li><p>学习和自适应能力：</p>
<p>学习：<strong>是一个具有特定目的的知识获取过程，是人的一种本能</strong>。不同人的学习方法、能力不同。</p>
<p>自适应：<strong>是一种通过自我调节适应外界环境的过程，是人的一种本能</strong>。不同人的适应能力不同。</p>
</li>
<li><p>行为能力：<strong>对感知的外界信息做出动作反应的能力</strong>。</p>
<p>信息来源：由感知直接获得的外界信息或经过思维加工后的信息。</p>
<p>实现过程’：通过脊髓来控制，由语言、表情、体姿等来实现。</p>
</li>
</ul>
<h3 id="什么是人工智能"><a href="#什么是人工智能" class="headerlink" title="什么是人工智能"></a>什么是人工智能</h3><ul>
<li>学科的名称。</li>
<li>人工方法实现的智能。</li>
<li>计算机模拟实现的智能。</li>
<li>人造的智能机器或系统。</li>
<li>模仿、延伸以及扩展人的智能。</li>
</ul>
<h3 id="人工智能典型的4种定义方法"><a href="#人工智能典型的4种定义方法" class="headerlink" title="人工智能典型的4种定义方法"></a>人工智能典型的4种定义方法</h3><ul>
<li>类人思维方法（认知模型方法）：1978年贝尔曼，人工智能是那些与人的思维、决策、问题求解和学习等有关活动的自动化。</li>
<li>类人行为方法（图灵测试方法）：1990年库兹韦勒，人工智能是一种创建机器的技艺，这种机器能够执行需要人的智能才能完成的功能。</li>
<li>理性思维方法（思维法则方法）：1985年查尼艾克、麦克德莫特，人工智能是通过计算模型来进行心智能力研究的。</li>
<li>理性行为方法（理性智能体方法）：1998年尼尔森，人工智能关心的是人工制品种的智能行为，即人工智能就是研究和建造理性智能体。</li>
<li><strong>理性思维方法与理性行为方法的关系：</strong><ul>
<li>前者强调正确思维，后者强调合理行动。</li>
<li>理性行为可以依据理性思维进行。</li>
<li>理性行为不一定要依据理性思维进行。</li>
</ul>
</li>
</ul>
<h3 id="人工智能的一般解释"><a href="#人工智能的一般解释" class="headerlink" title="人工智能的一般解释"></a>人工智能的一般解释</h3><ul>
<li>从能力的角度：人工智能是指<strong>用人工的方法在机器上实现的智能</strong>，是智能机器所执行的通常与人类智能有关的功能，如判断、推理、证明、识别、感知、理解、设计、思考、规划、学习和问题求解等思维活动。</li>
<li>从学科的角度：人工智能是<strong>一门研究如何构造智能机器或智能系统，去模拟、延伸和扩展人类智能的学科</strong>，是计算机科学中涉及研究、设计和应用智能机器的一个分支。</li>
</ul>
<h3 id="人工智能的研究目标"><a href="#人工智能的研究目标" class="headerlink" title="人工智能的研究目标"></a>人工智能的研究目标</h3><ul>
<li><p>1978年斯洛曼，三个主要目标：</p>
<ul>
<li><p>对智能行为有效解释的理论分析。</p>
</li>
<li><p>解释人类智能。</p>
</li>
<li><p>构造具有智能的人工制品。</p>
</li>
</ul>
</li>
<li><p>远期目标：<strong>用自动机重现人类的思维过程和智能行为</strong>。</p>
<p>揭示人类智能的根本机理，用智能机器去模拟、延伸和扩展人类的智能。涉及到脑科学、认知科学、计算机科学、系统科学、控制论等多种学科，并依赖于它们的共同发展。</p>
</li>
<li><p>近期目标：<strong>建造智能计算机代替人类的部分智力劳动</strong>。</p>
<p>研究如何使现有的计算机更聪明，即使它能够运用知识去处理问题，能够模拟人类的智能行为。</p>
</li>
<li><p><strong>远期目标和近期目标的相互关系：</strong></p>
<ul>
<li>远期目标为近期目标指明了方向。</li>
<li>近期目标则为远期目标奠定了理论和技术基础。</li>
</ul>
</li>
</ul>
<h2 id="人工智能的发展简史"><a href="#人工智能的发展简史" class="headerlink" title="人工智能的发展简史"></a>人工智能的发展简史</h2><h3 id="简史总结"><a href="#简史总结" class="headerlink" title="简史总结"></a>简史总结</h3><p><img data-src="/ArtificialIntelligence/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/1.png" alt="1"></p>
<h2 id="人工智能的研究内容"><a href="#人工智能的研究内容" class="headerlink" title="人工智能的研究内容"></a>人工智能的研究内容</h2><h3 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h3><ul>
<li>如何获取知识？</li>
<li>如何将获取的知识以计算机内部代码形式加以合理表示？</li>
<li>如何运用知识进行推理，解决实际问题？</li>
</ul>
<h2 id="人工智能研究方法与途径"><a href="#人工智能研究方法与途径" class="headerlink" title="人工智能研究方法与途径"></a>人工智能研究方法与途径</h2><h3 id="三大学派"><a href="#三大学派" class="headerlink" title="三大学派"></a>三大学派</h3><ul>
<li>符号主义：运用计算机科学的方法（逻辑演绎）。<ul>
<li>智能的基础是<strong>知识</strong>，其核心是<strong>知识表示和知识推理</strong>。</li>
<li><strong>知识可用符号表示，也可用符号进行推理</strong>，因而可以建立基于知识的人类智能和机器智能的统一的理论体系。</li>
<li><strong>功能模拟，构造能够模拟大脑功能的智能系统</strong>。</li>
</ul>
</li>
<li>联结主义：运用仿生学的方法（网络连接机制）。<ul>
<li>智能行为的基元是<strong>神经元</strong>，而不是符号。</li>
<li>思维过程是<strong>神经元的联结活动过程</strong>，而不是符号运算过程，反对符号主义关于物理符号系统的假设。</li>
<li><strong>结构模拟，构造模拟大脑结构的神经网络系统</strong>。</li>
</ul>
</li>
<li>行为主义：运用进化论的思想（控制论和机器学习方法）。<ul>
<li>智能取决于<strong>感知和行动</strong>，即“感知-动作”模型。</li>
<li>智能不需要知识、不需要表示、不需要推理，人工智能可以像人类智能那样<strong>逐步进化</strong>。</li>
<li><strong>行为模拟，构造具有进化能力的智能系统</strong>。</li>
</ul>
</li>
</ul>
<h2 id="人工智能的研究领域"><a href="#人工智能的研究领域" class="headerlink" title="人工智能的研究领域"></a>人工智能的研究领域</h2><h3 id="研究领域"><a href="#研究领域" class="headerlink" title="研究领域"></a>研究领域</h3><ul>
<li>机器思维：<strong>推理（确定性推理、不确定性推理）和搜索（状态空间搜索、与&#x2F;或树搜索、博弈树搜索）</strong>。</li>
<li>机器感知：计算机视觉、模式识别和自然语言处理。</li>
<li>机器行为：智能控制&#x2F;制造。</li>
<li>机器学习：符号学习和神经学习。</li>
<li>计算智能：神经计算、进化计算和模糊计算。</li>
<li>分布智能：并行求解。</li>
<li>智能系统：专家系统和智能决策支持系统。</li>
</ul>
<h2 id="人工智能的研究现状与发展方向"><a href="#人工智能的研究现状与发展方向" class="headerlink" title="人工智能的研究现状与发展方向"></a>人工智能的研究现状与发展方向</h2><h3 id="研究现状"><a href="#研究现状" class="headerlink" title="研究现状"></a>研究现状</h3><ul>
<li>多学科交叉研究</li>
<li>多学派和多技术融合研究</li>
<li>分布智能研究</li>
<li>群体智能研究</li>
<li>社会智能研究</li>
<li>集成智能研究</li>
<li>认知计算与情感计算研究</li>
<li>智能系统与智能服务</li>
</ul>
<h3 id="发展方向"><a href="#发展方向" class="headerlink" title="发展方向"></a>发展方向</h3><ul>
<li>知识 + 数据 + 算法 + 算力。</li>
</ul>
<p><img data-src="/ArtificialIntelligence/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/Wolf.jpg" alt="Wolf"></p>
]]></content>
      <categories>
        <category>人工智能</category>
        <category>第一章-人工智能的概述</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>栈与队列的应用</title>
    <url>/DataStructure/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p><strong>本文中的两道题目都是鄙人数据结构课程里的作业，仅以此博客记录个人的解题过程。</strong></p>
<p><strong>问题一：利用栈来改变火车的行驶顺序。</strong><br><img data-src="https://img-blog.csdnimg.cn/20200419164553496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70"><br>分析这个问题，N列给定顺序的火车在经过火车站后行驶顺序发生了变化，那么可以想到，这些火车在进入火车站后，如果其出站的顺序较后，则可以在火车站中停靠，让行驶顺序较前的火车先出站，来达到更换火车行驶顺序的目的。这就可以联想到一个很重要的存储结构——栈。<strong>栈的特点是“后进先出”，把暂时不需要出站的火车压入栈中保存，把需要出站的火车从栈中弹出。</strong></p>
<p><strong>首先，定义两种数据类型：节点和链栈，分别来表示火车和火车站。</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20200419171002982.png"></p>
<p><strong>问题的核心在于：何时将火车停靠在火车站中，何时停靠在火车站中的火车出站。</strong></p>
<p>如果，当前将要进站的火车刚好是当前需要出站的火车，该火车可以直接出站，不需要进栈保存，可以理解为进站后马上出站；<br>如果当前将要进站的火车不是当前需要出站的火车，那么火车将进站停靠；<br><strong>另外要注意的是，在当前进站的火车匹配到当前需要出站的火车时，当前需要出站的火车将发生变更，此时火车站中停靠最前火车可能是当前将要出站的火车，所以要不断将火车站中停靠最前的火车与当前需要出站的火车进行匹配。</strong><br>当所有匹配结束，即不再有火车满足出站条件时，如果火车站中没有停靠的火车，则火车的出站顺序成立；<br>如果火车站中仍然有停靠的火车，则火车的出站顺序不成立。以下为该算法的代码：</p>
<pre><code>int SeqLegal(int in[], int out[], int num, Stack* S)&#123;
    int *Out_id = out;  //当前将要出站的列车序号
    StackNode* Node;
    Node = S-&gt;top-&gt;next;
    for(int i = 0; i &lt; num; i++)&#123;  //当前将要进站的列车序号与当前将要出站的列车序号相同，可以直接忽略，当前将要出站列车变更
        if(in[i] == *Out_id)&#123;
            Out_id++;
            while(!StackEmpty(S) &amp;&amp; GetTop(S) == *Out_id)&#123;  //如果栈不为空而且栈顶元素序号与当前将要出站列车序号相同，则弹出栈顶元素
                Pop(S);
                Node = S-&gt;top-&gt;Next;
                Out_id++;
            &#125;
        &#125;
        else&#123;
            Push(S, in[i]);  //当前将要进站的列车序号与当前将要出站的列车序号不相同，列车进栈保存，当前将要出站列车不变
        &#125;
    &#125;
    while(Node &amp;&amp; (Node-&gt;ID == *Out_id))&#123;  //比较栈顶元素序号与当前将要出站列车序号是否相同，相同则弹出栈顶元素，继续比较下一对序号，直至栈空或者序号不同
        Pop(S);
        Node = S-&gt;top-&gt;Next;
        Out_id++;
    &#125;
    if(StackEmpty(S))
        return 1;  //栈为空，列车出站序列可以完全匹配
    else
        return 0;  //栈非空，列车出站序列不能完全匹配
&#125;
</code></pre>
<p><img data-src="https://img-blog.csdnimg.cn/20200419172719890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>以示例的火车顺序为例:</p>
<p>火车1进站，其不为当前需要出站的火车，则将其停<br>靠在火车站中。</p>
<p>火车2进站，其刚好为当前需要出站的火车，则火车2出站。<strong>当前需要出站火车变更为火车4，与火车站中的火车1不匹配。</strong></p>
<p>火车3进站，停靠在火车站中。</p>
<p><strong>火车4进站，刚好为当前需要出站火车，则火车4出站，当前需要出站火车变更为3，与火车站中停靠最前的火车3匹配，则火车3出站，当前需要出站的火车变更为1，与火车站中停靠最前的火车1匹配，火车1出站。</strong></p>
<p>此时，火车全部进站和出站，火车站中无停靠火车，那么该出站序列成立。</p>
<p>再来分析另外一个例子：</p>
<p>进站火车序列为1234，出站火车序列为4231。</p>
<p>火车1234依次进站后，当前需要出站火车与停靠最前的火车4匹配，火车4出站。</p>
<p>当前出站需要出站火车变更为火车2，而停靠最前火车为3，两者不能匹配，此时剩余的全部火车都不能出站，那么该出站序列不成立。</p>
<p><strong>问题二：求解能够正确调整火车行驶顺序所需的最少轨道数量。</strong><br><img data-src="https://img-blog.csdnimg.cn/20200419174327928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70"><br>分析这个问题，N列给定顺序的火车在进入缓冲轨道后，其行驶顺序发生了变化。<strong>可以知道，先进入某一条缓冲轨道的火车将优先从出口行驶出来，即对于各缓冲轨道的火车，都满足“先进先出”的规则，那么我们可以联想到队列这一数据结构。</strong>将每一条缓冲轨道看成一个队列，轨道中的火车有序排队。</p>
<p><strong>先定义两种数据类型，节点和链队列，分别表示火车和缓冲轨道。</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20200419175125145.png" alt="在这里插入图片描述"><br><strong>问题的核心在于：</strong></p>
<p><strong>一、要使火车在经过缓冲轨道后按序号从小到大的顺序行驶，再结合队列“先进先出”的要求，就需要在每条缓冲轨道中队前火车的序号小于队后火车的序号，即每条缓冲轨道中的火车序号呈升序排列。</strong></p>
<p><strong>二、再考虑求解轨道的最小数量。要使缓冲轨道数量最少，需要将每条缓冲轨道中的火车数量最大化，那么在选择火车轨道时，就要将火车放入与其序号差值最小的轨道。举个例子：</strong> </p>
<p>如果已有两条轨道，分别有火车4和火车2，又有火车5和火车3先后从入口进入，此时如果将火车5放入火车2的轨道，那么火车3只能进入新的无车轨道，因为在已有的两条轨道中末端火车的序号（分别为火车4和火车5）均大于3，此时缓冲轨道数量为3；而如果将火车5放入火车4的轨道，那么就可以将火车3放入火车2的轨道，此时缓冲轨道数量为2。</p>
<p>寻找最适合轨道的代码如下：</p>
<pre><code>int FindClosestQueue(Queue *RailQueue[],int UsedQueue,int CurTrain)&#123;
    int closestIdx = -1;  //最合适的轨道初始化为-1
    int Rear_Id;  //队尾元素
    int D_value[UsedQueue];  //记录当前火车序号与每个轨道队尾火车序号的差值
       for(int i = 0; i &lt; UsedQueue; i++)  //遍历每个使用过的轨道
        &#123;
            if(CurTrain &gt; GetRear(RailQueue[i]))  //当前火车序号大于队尾火车序号
            &#123;
                   Rear_Id = GetRear(RailQueue[i]);
                    D_value[i] = CurTrain - Rear_Id;  //记录两车的序号差值
            	&#125;
            else&#123;
                     D_value[i] = 0;  //将差值记录为0，便于求得最小差值
            &#125;
        &#125;
        for(int i = 0; i &lt; UsedQueue; i++)  //遍历差值数组，除0外差值记录最小的轨道为最适合轨道
        &#123;
            if(D_value[i] &gt; 0)  //如果差值记录大于0，该轨道为候选轨道
            &#123;
                    if(closestIdx &lt; 0)  //之前未找到最适合轨道
                    &#123;
                        closestIdx = i;  //最适合轨道赋值为当前候选轨道
                    &#125;
                    else&#123;  //之前已找到最适合轨道
                        if(D_value[i] &lt; D_value[closestIdx])  //比较两个轨道的差值记录，如果当前候选轨道差值较小，将最适合轨道赋值为当前候选轨道
                        &#123;
                                closestIdx = i;
                           &#125;
                    &#125;
            &#125;
        &#125;
        return closestIdx;  //返回最适合轨道序号，不存在最适合轨道时返回-1
&#125;
</code></pre>
<p><img data-src="https://img-blog.csdnimg.cn/20200419180649391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70"></p>
<p>然后将火车插入相应轨道，最终使用的轨道数量即为最小缓冲轨道数量：</p>
<pre><code>int MinBufferQueue(int out[], int num)&#123;
        Queue *RailQueue[num]; //指针数组，记录各缓存轨道的火车，有与火车数相等的轨道数时一定可行
        int closestIdx;
        int UsedQueue = 0;  //已使用的队列数
       int ArrangedTrain = 0;  //已安排的火车数
        for(int i = 0; i &lt; num; i++)&#123;
            RailQueue[i] = InitQueue();  //初始化火车队列
        &#125;
        for(int i = 0; i &lt; num; i++)
        &#123;
            closestIdx = FindClosestQueue(RailQueue,UsedQueue,out[i]);  //寻找当前火车的最适合轨道
            if(closestIdx == -1)  //不存在最适合轨道
            &#123;
                    EnQueue(RailQueue[UsedQueue], out[i]);  //当前火车入队新火车轨道
                    UsedQueue++;  //已使用的队列数增加
                    ArrangedTrain++;  //已安排的火车数增加
            &#125;
               else  //存在最适合轨道
            &#123;
                    EnQueue(RailQueue[closestIdx], out[i]);  //当前火车入队最适合轨道
                    ArrangedTrain++;  //已安排的火车数增加，已使用的队列数不变
            &#125;
        &#125;
        return UsedQueue;  //返回已使用的队列数
&#125;
</code></pre>
<p><img data-src="https://img-blog.csdnimg.cn/20200419180827873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70"></p>
<p><strong>敲黑板！！！萌新首次尝试撰写博客，文章内容涉及到的编程知识也非常基础，个人的代码能力也是比较有限，在此欢迎各位大佬交流指正。</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210325183348308.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>栈与队列的应用</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>线性结构及其应用</title>
    <url>/DataStructure/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>结束了大一上C语言的学习，脱离了被学生成绩管理系统支配的恐惧，开始来学习 <strong><del>万恶的</del></strong> 数据结构。</p>
<p>依稀记得当时为了做这个实验，我早早地吃完晚饭，守在电脑前，打开了 <strong>CodeBlocks、百度搜索（<del>懂的都懂！！！</del> ）、QQ和微信（<del>哈哈，信我，真的只是为了与外界取得联系！！！</del> ），面前还摆着C语言课本和数结构课本，</strong> 真的是正襟危坐，紧张刺激。</p>
<p>这里说明一下，去年因为疫情的影响，全部在家上网课，而且数据结构实验课是在晚上。</p>
<p><strong>等等，晚上？这不是变相让我们决战到天亮吗？？？</strong></p>
<p>果然，老师诚不负我。曾天真地以为可以永远告别学生成绩管理系统了，好家伙，它又给我回来了！！！（<strong>原地死亡</strong>）</p>
<p><img data-src="https://img-blog.csdnimg.cn/20210325205121464.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>实验要求如下：<br>学期结束，辅导员需要收集两个班级的同学的C语言课程成绩。请你为辅导员做一个成绩录入统计，帮助辅导员更好地工作。（<del><strong>请问你分钱给我吗？没有凭什么将你的快乐建立在我的痛苦之上？</strong></del> ）</p>
<p><img data-src="https://img-blog.csdnimg.cn/20210325205324686.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>（1）成绩信息录入——线性表的建立与遍历<br>操作1：初始化空表<br>操作2：按成绩降序插入所有同学的学号、班级信息和成绩到各自班级链表<br>操作3：查找&#x2F;删除，若对应班级链表中无该同学信息，则输出无法找到<br>操作4：信息输出，线性表的遍历<br>（2）信息汇总<br>信息统计：将同学们的成绩合并到总表<br>（3）建表翻转<br>将总表中信息翻转到新表中</p>
<p>算了，还是写吧。<br><strong>但请你记住，我不是在帮你，我只是想改变世界！！！</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210325205332494.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>下面奉上鄙人的拙劣的代码：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

//定义学生信息节点
typedef struct node&#123;
    int ID_num;  //学号
    int Class_num;  //班级
    int C_score;  //分数
    struct node *next;
&#125;STUDENTNODE;

//建立学生信息节点,返回指向该节点的指针
STUDENTNODE* StudentListNodeCreat(int Class_num, int ID_num, int C_score)&#123;
    STUDENTNODE *p;
    p = (STUDENTNODE *)malloc(sizeof(STUDENTNODE));   //给新建节点分配存储空间
    if(!p)  exit(0);
    p-&gt;ID_num = ID_num;
    p-&gt;Class_num = Class_num;
    p-&gt;C_score = C_score;
    p-&gt;next = NULL;  //指针初始化为NULL
    return p;
&#125;

//在已有的成绩降序链表中插入新建学生信息节点，并保持链表成绩仍为降序
STUDENTNODE* Insert_Descending(STUDENTNODE *head, STUDENTNODE *node)&#123;
    STUDENTNODE *p, *q;
    p = head;
    q = node;
    while(p-&gt;next)&#123;  //链表下一节点存在
        if((p-&gt;next-&gt;C_score) &gt; q-&gt;C_score)&#123;  //若下一节点的成绩大于插入节点的成绩
            p = p-&gt;next;  //继续向下搜索
        &#125;
        else&#123;
            q-&gt;next = p-&gt;next;  //若下一节点的成绩小于或等于插入节点的成绩
            p-&gt;next = q;
            break;
        &#125;
    &#125;
    if(!(p-&gt;next))&#123;
        q-&gt;next = p-&gt;next;  //搜索至链表末端时，将节点插入末端
        p-&gt;next = q;
    &#125;
    return head;
&#125;

//根据学号搜索学生信息,若有，则输出成绩,若没有，输出没有该学生信息
void SearchByID_num(STUDENTNODE *head, int ID_num)&#123;
    STUDENTNODE *p;
    p = head;
    while(p-&gt;next)&#123;  //下一节点存在
        if((p-&gt;next-&gt;ID_num) != ID_num)&#123;  //若下一节点的学号不等于搜索的学号
            p = p-&gt;next;  //继续向下搜索
        &#125;
        else&#123;
            printf(&quot;It is    &#123; Class_number: %d, ID_number: %d, C_score: %3d &#125;\n&quot;, p-&gt;next-&gt;Class_num, p-&gt;next-&gt;ID_num, p-&gt;next-&gt;C_score);  //匹配到相应学号时
            break;
        &#125;
    &#125;
    if(!(p-&gt;next))&#123;
       printf(&quot;This class has no such student as ID_number = %d\n&quot;, ID_num);  //搜索至链表末端时,返回没有相应学生信息
    &#125;
&#125;

//根据学号删除学生相关信息
STUDENTNODE* DeleteByID_num(STUDENTNODE *head, int ID_num)&#123;
    STUDENTNODE *p, *q;
    p = head;
    while(p-&gt;next)&#123;  //下一节点存在
        if((p-&gt;next-&gt;ID_num) != ID_num)&#123;  //若下一节点的学号不等于搜索的学号
            p = p-&gt;next;  //继续向下搜索
        &#125;
        else&#123;
            q = p-&gt;next;  //匹配到相应学号时
            p-&gt;next = q-&gt;next;  //将p的指针指向下一节点存放的指针所指向的地址
            free(q);  //释放内存
            printf(&quot;Success!\n&quot;);
            break;
        &#125;
    &#125;
    if(!(p-&gt;next))&#123;
       printf(&quot;This class has no such student as ID_number = %d\n&quot;, ID_num);  //搜索至链表末端时,返回没有相应学生信息
    &#125;
    return head;
&#125;


//复制参数节点
STUDENTNODE* NodeCopy(STUDENTNODE *node)&#123;
    STUDENTNODE *newnode;
    newnode = (STUDENTNODE *)malloc(sizeof(STUDENTNODE));  //为新节点分配空间复制各部分的值，指针初始化为NULL
    newnode-&gt;Class_num = node-&gt;Class_num;  //复制各部分的值指针初始化为NULL
    newnode-&gt;ID_num = node-&gt;ID_num;
    newnode-&gt;C_score = node-&gt;C_score;
    newnode-&gt;next = NULL;  //指针初始化为NULL
    return newnode;
&#125;

//将两个班级的成绩表合并为一个新的总表，表中成绩仍按降序处理,同时不破坏原有分表
STUDENTNODE* MergeStudentList(STUDENTNODE* heads[], STUDENTNODE *MergeList)&#123;  //参数为待合并分表和合并总表头结点的指针
    STUDENTNODE *p, *q, *r, *copynode;
    p = heads[0]-&gt;next;
    q = heads[1]-&gt;next;
    r = MergeList;
    while(p &amp;&amp; q)&#123;  //当两个指针指向的节点同时存在时,比较两节点的成绩
        if((p-&gt;C_score) &gt;= (q-&gt;C_score))&#123;  //p指针指向节点的成绩大于或等于q指针指向节点的成绩
            copynode = NodeCopy(p);  //复制p指针指向的节点,该节点为满足条件的待插入节点
            r-&gt;next = copynode;
            r = r-&gt;next;
            p = p-&gt;next;
        &#125;
        else&#123;
            copynode = NodeCopy(q);  //复制q指针指向的节点,该节点为满足条件的待插入节点
            r-&gt;next = copynode;
            r = r-&gt;next;
            q = q-&gt;next;
        &#125;
    &#125;
    while(p)&#123;  //当p指针指向节点存在,即分表还未遍历时,依次插入所有节点
        copynode = NodeCopy(p);
        r-&gt;next = copynode;
        r = r-&gt;next;
        p = p-&gt;next;
    &#125;
    while(q)&#123;  //当q指针指向节点存在,即分表还未遍历时,依次插入所有节点
        copynode = NodeCopy(q);
        r-&gt;next = copynode;
        r = r-&gt;next;
        q = q-&gt;next;
    &#125;
    return MergeList;
&#125;

//将总表逆序排列,即表中成绩按升序处理,同时不破坏原有总表
STUDENTNODE* ReverseStudentList(STUDENTNODE *MergeList,STUDENTNODE *ReverseList)&#123;  //参数为待逆序总表和逆序总表头结点的指针
    STUDENTNODE *p, *q, *newnode;
    p = MergeList-&gt;next;
    q = ReverseList;
    while(p)&#123;  //依次遍历并复制每一个节点,不断将复制形成的节点插入到头结点与第一个节点之间,最终达到逆序的效果
        newnode = NodeCopy(p);  //复制当前节点
        newnode-&gt;next = q-&gt;next;  //将复制形成的节点插入头结点与第一个节点之间
        q-&gt;next = newnode;
        p = p-&gt;next;
    &#125;
    return ReverseList;
&#125;

//打印单个学生节点信息
void PrintStudentNode(STUDENTNODE *node)&#123;
    STUDENTNODE *p;
    p = node;
    printf(&quot;&#123; Class_number: %d, ID_number: %d, C_score: %3d&#125;\n&quot;, p-&gt;Class_num, p-&gt;ID_num, p-&gt;C_score);
&#125;

//打印整个学生信息表
void PrintStudentList(STUDENTNODE *head)&#123;
    STUDENTNODE *p;
    p = head-&gt;next;
    while(p)&#123;
        printf(&quot;&#123; Class_number: %d, ID_number: %d, C_score: %3d &#125;&quot;, p-&gt;Class_num, p-&gt;ID_num, p-&gt;C_score);
        p = p-&gt;next;
        if(p)&#123;
            printf(&quot;-&gt;\n&quot;);  //存在后继节点，则以&quot;-&gt;&quot;来表示
        &#125;
    &#125;
    printf(&quot;\nThat&#39;s all\n&quot;);
&#125;

int main()
&#123;
    int n_student;  //学生个数
    char order;      //用户选择
    int tempClass;
    int tempID;
    int tempScore;
    STUDENTNODE* tempNode;
    STUDENTNODE* MergeList;  //降序总表头指针
    STUDENTNODE* ReverseList;  //升序总表头指针
    STUDENTNODE* Class[2] = &#123;StudentListNodeCreat(0,0,0),StudentListNodeCreat(1,0,0)&#125;;  //为两个班级分表创建头结点
    printf(&quot;\n                  ################################################################                  \n&quot;);
    printf(&quot;1.Insert_Descending  2.Search by ID_number  3.Delete by ID_number  4.Merge  5.Reverse  6.Print  q.Quit\n&quot;);
    printf(&quot;\n                  ################################################################                  \n&quot;);
    printf(&quot;Input your order:    &quot;);
    while(scanf(&quot; %c&quot;, &amp;order))&#123;  //检查是否读取到有效值
        switch (order)&#123;  //查看用户指令
        case &#39;1&#39;:
            printf(&quot;How many student do you want to input?    &quot;);
            while(getchar() != &#39;\n&#39;)&#123;  //清除缓冲区中的所有字符
                continue;
            &#125;
            while(scanf(&quot;%d&quot;, &amp;n_student))&#123;  //检查是否读取到有效值
            while(n_student != 0)&#123;
                printf(&quot;Input the data format as Class_number,ID_number,C_score:    &quot;);
                while(getchar() != &#39;\n&#39;)&#123;  //清除缓冲区中的所有字符
                    continue;
                &#125;
                while((scanf(&quot;%d,%d,%d&quot;, &amp;tempClass, &amp;tempID, &amp;tempScore) != 3))&#123;  //检查是否读取到有效值
                    while(getchar() != &#39;\n&#39;)&#123;  //清除缓冲区中的所有字符
                    continue;
                    &#125;
                    printf(&quot;Error!Please input again!\n&quot;);  //提示错误并要求重新输入
                    printf(&quot;Input the data format as Class_number,ID_number,C_score:    &quot;);
                &#125;
                tempNode = StudentListNodeCreat(tempClass, tempID, tempScore);  //新建学生信息节点
                Class[tempClass] = Insert_Descending(Class[tempClass], tempNode);  //将新建节点按降序插入班级表中
                printf(&quot;This is the node you have inserted:    &quot;);
                PrintStudentNode(tempNode);  //输出插入的学生节点信息
                n_student--;
            &#125;
            break;
        case &#39;2&#39;:
            printf(&quot;Input the data format as:Class_number,ID_number:    &quot;);
            while((scanf(&quot;%d,%d&quot;, &amp;tempClass, &amp;tempID) != 2))&#123;  //检查是否读取到有效值
                    while(getchar() != &#39;\n&#39;)&#123;  //清除缓冲区中的所有字符
                    continue;
                    &#125;
                    printf(&quot;Error!Please input again!\n&quot;);  //提示错误并要求重新输入
                    printf(&quot;Input the data format as:Class_number,ID_number:    &quot;);
                &#125;
            SearchByID_num(Class[tempClass], tempID);
            break;
        case &#39;3&#39;:
            printf(&quot;Input the data format as:Class_number,ID_number:    &quot;);
            while((scanf(&quot;%d,%d&quot;, &amp;tempClass, &amp;tempID) != 2))&#123;  //检查是否读取到有效值
                    while(getchar() != &#39;\n&#39;)&#123;  //清除缓冲区中的所有字符
                    continue;
                    &#125;
                    printf(&quot;Error!Please input again!\n&quot;);  //提示错误并要求重新输入
                    printf(&quot;Input the data format as:Class_number,ID_number:    &quot;);
                &#125;
            Class[tempClass] = DeleteByID_num(Class[tempClass], tempID);
            break;
        case &#39;4&#39;:
            MergeList = StudentListNodeCreat(-1,0,0);  //为降序总表创建一个头结点
            MergeList = MergeStudentList(Class,MergeList);
            printf(&quot;The list merged:\n&quot;);
            PrintStudentList(MergeList);
            break;
        case &#39;5&#39;:
            ReverseList = StudentListNodeCreat(-1,0,0);  //为升序总表创建一个头结点
            ReverseList = ReverseStudentList(MergeList,ReverseList);
            printf(&quot;The list reversed:\n&quot;);
            PrintStudentList(ReverseList);
            break;
        case &#39;6&#39;:
            printf(&quot;\nClass 0:\n&quot;);
            PrintStudentList(Class[0]);
            printf(&quot;\n&quot;);
            printf(&quot;\nClass 1:\n&quot;);
            PrintStudentList(Class[1]);
            break;
        case &#39;q&#39;:
            exit(0);
        default:
            printf(&quot;Error!Please input again!\n&quot;);  //若用户输入选项以外的其他字符,提示输入错误并要求重新输入
            break;
        &#125;
        printf(&quot;\n                  ################################################################                  \n&quot;);
        printf(&quot;1.Insert_Descending  2.Search by ID_number  3.Delete by ID_number  4.Merge  5.Reverse  6.Print  q.Quit\n&quot;);
        printf(&quot;\n                  ################################################################                  \n&quot;);
        printf(&quot;Input your order:    &quot;);
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p><strong>欸，我不就闭关了一会，怎么大家都睡了啊？？？</strong><br><img data-src="https://img-blog.csdnimg.cn/20210325205557863.gif#pic_center" alt="在这里插入图片描述"></p>
<p>除了满足基本要求外，鄙人还作贱自己添加了几个小小的功能：<br>1、程序只会读取输入的第一个字符作为指令，且程序在读到除以上字符外的其他字符时，都会提示用户重新输入，直至输入正确指令。<br>2、程序在读取输入时会通过scanf函数的返回值判断输入是否达到要求，若返回值错误，则会提示用户重新输入，直至输入格式完全正确，来提高程序的健壮性。<br>3、程序在每次读取输入之后都会清空缓冲区中的字符，避免存留字符对下一次的读取造成严重影响，可进一步防止程序崩溃。<br>4、在合并总表及翻转总表时，采用复制节点的方式，保证原表节点的信息不变，因此在合并或翻转后打印原表，也不会出现存放数据错误的现象。<br>5、在插入节点之后都会输出插入的节点信息，便于用户纠错并删除错误节点。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20210325210529490.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>敲黑板！！！数据结构非常非常非常地难，请反复反复反复练习。（<del>自己都做不到凭什么说别人。。。</del> ）</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210325210704926.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性结构及其应用</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>数据结构</tag>
        <tag>数组</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>树形结构及其应用</title>
    <url>/DataStructure/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p><strong>以前，我总以为，树象征着生命，象征的生机；<br>后来，我遇到了那个它，我才知道，树会让你死亡，还是死无全尸的那种。。。</strong></p>
<p><strong>你以为的树：</strong><br><img data-src="https://img-blog.csdnimg.cn/20210328211127278.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>实际中的树：</strong><br><img data-src="https://img-blog.csdnimg.cn/20210328211138237.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>好家伙，先序后序中序，后序先序中序，中序后序先序，绕死一个算一个！！！</strong></p>
<p>话不多说，题来（<del>如果我被绑架了我就眨眨眼</del> ）</p>
<p>题目1：<br>    <strong>按先序序列建立二叉树，并输出该二叉树的中序遍历和后序遍历</strong><br>    输入：<br>        先序序列：ABDH##I##E##CF#J##G##（#表示空）<br>    输出：<br>        中序序列：HDIBEAFJCG<br>        后序序列： HIDEBJFGCA<br>    注意：当只输入一个#时，需返回空二叉树<br>    图解：<br><img data-src="https://img-blog.csdnimg.cn/20210327174243293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>题目2：<br>    <strong>给定一棵二叉树的后序和中序遍历序列，构造该二叉树，并输出该二叉树的前序遍历</strong><br>    输入：<br>        后序序列： 3424321<br>        中序序列： 3241423<br>    输出：<br>        前序序列： 1234243<br>    注意：当输入的后序和中序遍历序列不能够构造出二叉树时，应输出：Unable to build a binary tree，这里的不能构造二叉树包括序列长度不一致、序列所含字符不一致以及不能够构造一棵二叉树等。<br>    图解：<br><img data-src="https://img-blog.csdnimg.cn/20210327174544249.png#pic_center" alt="在这里插入图片描述"><br>题目3：<br>    <strong>给定一棵二叉树，返回该二叉树的叶子节点数和宽度</strong><br>    输入：<br>        二叉树根节点：T<br>    输出：<br>        二叉树的叶子节点数：5<br>        二叉树的宽度：4<br>    图解：<br><img data-src="https://img-blog.csdnimg.cn/20210327175202498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>题目4：<br>    <strong>给定两棵二叉树，判断两棵二叉树是否等价。等价输出1，否则输出0</strong><br>    输入：<br>        二叉树根节点：T<br>    输出：<br>        图1：1<br>        图2：0<br>    图解：<br><img data-src="https://img-blog.csdnimg.cn/20210327175421252.png#pic_center" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210327175429512.png#pic_center" alt="在这里插入图片描述"></p>
<p>想必很多小伙伴们看完题后嗖嗖嗖地就把代码敲出来了吧（<strong>是我不配</strong>），就让我独自承受脱发的痛苦吧。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20210328211919930.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include&lt;string.h&gt;

#define N 21  //后序序列和中序序列字符的最大个数为N-1

int FLAG; //标识能否由后序序列和中序序列建立二叉树,能为1，否为0

typedef struct Node
&#123;
    char data;
    struct Node *lchild, *rchild;
&#125;TreeNode, *BiTree;  //定义树节点的结构体

//函数功能：先序建立二叉树，并返回指向该二叉树的指针
BiTree CreateBiTree(void)
&#123;
    BiTree bt = NULL;
    char data;
    if((data = getchar()) != &#39;\n&#39;)
    &#123;
        if(data == &#39;#&#39;)
        &#123;
            bt = NULL;  //字符#表示节点为空
        &#125;
        else
        &#123;
            bt = (BiTree)malloc(sizeof(TreeNode));
            if(!bt)
            &#123;
                printf(&quot;OVERFLOW\n!&quot;);
                exit(0);
            &#125;
            bt-&gt;data = data;  //树根
            bt-&gt;lchild = CreateBiTree();  //先序建立左子树
            bt-&gt;rchild = CreateBiTree();  //先序建立右子树
        &#125;
    &#125;
    return bt;
&#125;

//函数功能：先序遍历二叉树
void PreOrderTraverse(BiTree T)
&#123;
    if(T)
    &#123;
        printf(&quot;%c&quot;, T-&gt;data);  //访问节点
        PreOrderTraverse(T-&gt;lchild);  //先序遍历左子树
        PreOrderTraverse(T-&gt;rchild);  //先序遍历右子树
    &#125;
    return;
&#125;

//函数功能：中序遍历二叉树
void InOrderTraverse(BiTree T)
&#123;
    if(T)
    &#123;
        InOrderTraverse(T-&gt;lchild);  //中序遍历左子树
        printf(&quot;%c&quot;, T-&gt;data);  //访问节点
        InOrderTraverse(T-&gt;rchild);  //中序遍历右子树
    &#125;
    return;
&#125;

//函数功能：后序遍历二叉树
void PostOrderTraverse(BiTree T)
&#123;
    if(T)
    &#123;
        PostOrderTraverse(T-&gt;lchild);  //后序遍历左子树
        PostOrderTraverse(T-&gt;rchild);  //后序遍历右子树
        printf(&quot;%c&quot;, T-&gt;data);  //访问节点
    &#125;
    return;
&#125;

//判断能否根据后序序列和中序序列构造二叉树，此函数的判定内容为后序序列和中序序列所含的字符是否相同
//说明：如果后序序列和中序序列能构造二叉树，那么其递归的左子树和右子树所含字符始终相同，当有任意一对左右子树含有不同字符时，输入的序列不能构成二叉树
void Judge(char post[], char in[], int num)
&#123;
    for(int i = 0; i &lt; num; i++)
    &#123;
        if(!strchr(in, post[i]))  //后序序列含有中序序列所不含有的字符，不能构成二叉树
        &#123;
            FLAG = 0;
            return;
        &#125;
    &#125;
    for(int i = 0; i &lt; num; i++)  //中序序列含有后序序列所不含有的字符，不能构成二叉树
    &#123;
        if(!strchr(post, in[i]))
        &#123;
            FLAG = 0;
            return;
        &#125;
    &#125;
&#125;

//函数功能：根据后序序列与中序序列构造二叉树，并返回指向该二叉树的指针
//参数说明：post[]为后序序列，in[]为中序序列，num为字符个数
BiTree PostInCreate(char post[], char in[], int num)
&#123;
    BiTree bt = NULL;
    int i, num_left = 0, num_right = 0;
    char post_left[N], in_left[N], post_right[N], in_right[N];
    Judge(post, in, num);  //判断后序序列和前序序列能否构成二叉树
    if(num &gt; 0 &amp;&amp; FLAG)  //序列不为空且能够构成二叉树
    &#123;
        bt = (BiTree)malloc(sizeof(TreeNode));
        bt-&gt;data = post[num-1];  //树根为后序序列的最后一个字符
        for(i = 0; i &lt; num; i++)
        &#123;
            if(in[i] == bt-&gt;data)  //求出树根在中序序列中的位置
                break;
        &#125;
        num_left = i;  //左子树的节点个数
        num_right = num-i-1;  //右子树的节点个数
        for(i = 0; i &lt; num_left; i++)
        &#123;
            post_left[i] = post[i];  //左子树的后序序列
            in_left[i] = in[i];     //左子树的中序序列
        &#125;
        for(i = 0; i &lt; num_right; i++)
        &#123;
            post_right[i] = post[num-num_right-1+i];  //右子树的后序序列
            in_right[i] = in[num-num_right+i];  //右子树的中序序列
        &#125;
        bt-&gt;lchild = PostInCreate(post_left, in_left, num_left);  //根据后序序列与中序序列构造左子树
        bt-&gt;rchild = PostInCreate(post_right, in_right, num_right);  //根据后序序列与中序序列构造右子树
    &#125;
    return bt;
&#125;

//函数功能：计算并返回叶子节点的数量
int CountLeafSum(BiTree T)
&#123;
    if(!T)  //空树
        return 0;
    if(T-&gt;lchild == NULL &amp;&amp; T-&gt;rchild == NULL)  //只含树根节点
        return 1;
    return (CountLeafSum(T-&gt;lchild) + CountLeafSum(T-&gt;rchild));  //叶子节点的数量等于左子树叶子节点的数量+右子树叶子结点的数量
&#125;

//函数功能：计算并返回二叉树的高度
int CountHeight(BiTree T)
&#123;
    int ldepth, rdepth;
    if(!T)  //空树
        return 0;
    if(T-&gt;lchild == NULL &amp;&amp; T-&gt;rchild == NULL)  //只含树根节点
        return 1;
    ldepth = CountHeight(T-&gt;lchild);  //左子树的高度
    rdepth = CountHeight(T-&gt;rchild);  //右子树的高度
    return ((ldepth &gt; rdepth ? ldepth : rdepth) + 1);  //二叉树的高度是其左子树和右子树中较高的一个子树的高度加1
&#125;

//函数功能：求出一个二叉树每一层的节点数量
//参数说明：数组count[]记录每一层的节点数
void GetWidth(BiTree T, int count[], char LEVEL[])
&#123;
    struct Queue&#123;
        BiTree Node;
        int level;
    &#125;Q[N];
    int front = 0, rear = 0;
    if(!T)  //空树，直接返回
        return;
    else
    &#123;
        Q[front].Node = T;  //队头为树根
        Q[front].level = 1;  //树根的层级为1
        while(front &lt;= rear)
        &#123;
            if(Q[front].Node-&gt;lchild)  //队头树根的左子树存在
            &#123;
                Q[++rear].Node = Q[front].Node-&gt;lchild;  //队尾插入左子树的树根
                Q[rear].level = Q[front].level + 1;  //左子树树根的层级为当前树根的层级加1
            &#125;
            if(Q[front].Node-&gt;rchild)  //队头树根的右子树存在
            &#123;
                Q[++rear].Node = Q[front].Node-&gt;rchild;  //队尾插入右子树的树根
                Q[rear].level = Q[front].level + 1;  //右子树树根的层级为当前树根的层级加1
            &#125;
            front++;  //队头指针下移
        &#125;
        for(int i = 0; i &lt;= rear; i++)
        &#123;
            LEVEL[i+1] = Q[i].Node-&gt;data;  //层序遍历
            LEVEL[0]++;  //记录节点个数
            count[Q[i].level-1]++;  //遍历整个队列，统计各层级的节点数
        &#125;
        return;
    &#125;
&#125;

//函数功能：判断两树是否等价，是返回1，否返回0
//参数说明：T1:第一棵二叉树，T2:第二棵二叉树
int IsEquivalent(BiTree T1, BiTree T2)
&#123;
    int x = 0;
    if(!T1 &amp;&amp; !T2)  //两棵树均为空树
    &#123;
        x = 1;
    &#125;
    else if((!T1 &amp;&amp; T2) || (T1 &amp;&amp; !T2))  //一棵为空树，另一棵不为空树
    &#123;
        x = 0;
    &#125;
    else  //两棵树均不为空树
    &#123;
        if(T1-&gt;data == T2-&gt;data)  //节点信息相同
        &#123;
            if(IsEquivalent(T1-&gt;lchild, T2-&gt;lchild))  //左子树等价
            &#123;
                if(IsEquivalent(T1-&gt;rchild, T2-&gt;rchild))  //右子树等价
                &#123;
                    x = 1;
                &#125;
            &#125;
        &#125;
    &#125;
    return x;
&#125;

//任务1：实现二叉树的先序、中序、后序遍历
void Task1(BiTree T)
&#123;
    printf(&quot;\nStart task (1) Create Tree in PreOrder\n&quot;);
    if(T)
    &#123;
        printf(&quot;PreOrderTraverse:  &quot;);
        PreOrderTraverse(T);
        printf(&quot;\n&quot;);
        printf(&quot;InOrderTraverse:  &quot;);
        InOrderTraverse(T);
        printf(&quot;\n&quot;);
        printf(&quot;PostOrderTraverse:  &quot;);
        PostOrderTraverse(T);
        printf(&quot;\n&quot;);
    &#125;
    else  //空树
    &#123;
        printf(&quot;The BiTree is NULL!\n&quot;);
    &#125;
&#125;

//任务2：根据后序序列和中序序列构造二叉树，当这两个序列不能构造二叉树时，输出&quot;Can not build a BiTree!&quot;
BiTree Task2(BiTree *T)
&#123;
    printf(&quot;\nStart task (2) Input the postOrder and inOrder Sequence ,Then build the tree\n&quot;);
    char post[N] = &#123;0&#125;;  //后序序列
    char in[N] = &#123;0&#125;; //中序序列
    int postlen, inlen;
    while(getchar() != &#39;\n&#39;)continue;
    printf(&quot;Please input the postorder sequence(less than %d nodes):  &quot;, N);
    scanf(&quot;%s&quot;,post);
    while(getchar() != &#39;\n&#39;)continue;
    printf(&quot;Please input the inorder sequence(less than %d nodes):  &quot;, N);
    scanf(&quot;%s&quot;,in);
    postlen = strlen(post);
    inlen = strlen(in);
    if(postlen != inlen)  //序列长度不同，不能构造二叉树
    &#123;
        FLAG = 0;
    &#125;
    else
    &#123;
        *T = PostInCreate(post, in, postlen);  //递归构造二叉树
        if(FLAG)  //能够构造二叉树
        &#123;
            printf(&quot;PreOrderTraverse:  &quot;);
            PreOrderTraverse(*T);  //先序遍历二叉树
            printf(&quot;\n&quot;);
        &#125;
    &#125;
    if(!FLAG)  //不能构造二叉树
    &#123;
        *T = NULL;  //空树
        printf(&quot;Can not build a BiTree!\n&quot;);
    &#125;
    return *T;
&#125;

//任务3：计算并打印二叉树的叶子节点个数、高度、宽度
void Task3(BiTree T)
&#123;
    printf(&quot;\nStart task (3) ------------------------------\n&quot;);
    int maxwidth = 0;     //树的宽度，初始化为0
    int height;
    int i;
    int count[N] = &#123;0&#125;;
    char LEVEL[N] = &#123;0&#125;;
    height = CountHeight(T);  //树的高度
    printf(&quot;The number of leaf nodes of the tree is:  &quot;);
    printf(&quot;%d\n&quot;,CountLeafSum(T));  //打印叶子节点的数量
    printf(&quot;The height of the tree is:  &quot;);
    printf(&quot;%d\n&quot;, height);  //打印树的高度
    GetWidth(T, count, LEVEL);
    for(i = 0; i &lt; height; i++)
    &#123;

        if(count[i] &gt; maxwidth)
        &#123;
            maxwidth = count[i];
        &#125;
    &#125;
    printf(&quot;LevelOrderTraverse:  &quot;);
    if(LEVEL[0] == 0)
    &#123;
        printf(&quot;The BiTree is NULL!&quot;);
    &#125;
    for(i = 1; i &lt;= LEVEL[0]; i++)
    &#123;
        printf(&quot;%c&quot;, LEVEL[i]);
    &#125;
    for(i = 0; i &lt; height; i++)
    &#123;
        printf(&quot;\nThe No.%2d level has %d nodes.&quot;, i+1, count[i]);
    &#125;
    printf(&quot;\nThe width of the tree is:  &quot;);
    printf(&quot;%d\n&quot;, maxwidth);  //打印树的宽度
&#125;

//任务4：判断两个二叉树是否等价
void Task4(BiTree T1,BiTree T2)
&#123;
    printf(&quot;\nStart task (4) Are two Bitrees equivalent?&quot;);
    printf(&quot;(Equal: 1    Unequal: 0)\n&quot;);
    printf(&quot;Their relationship is %d.\n\n&quot;,IsEquivalent(T1, T2));
&#125;

int main()
&#123;
    BiTree Bt1, Bt2;
    char order;
    printf(&quot;1.Create BiTree_one with PRE    2.Create BiTree_two with POST and IN\n&quot;);
    printf(&quot;3.Count BiTree_one    4.Count BiTree_two    5.Judge whether they are equal\n&quot;);
    printf(&quot;Input your order(q to quit):  &quot;);
    scanf(&quot;%c&quot;, &amp;order);
    do&#123;
        switch (order)
        &#123;
            case&#39;1&#39;:printf(&quot;Create BiTree_one in PreOrder(less than %d nodes):  &quot;, N);
                    while(getchar() != &#39;\n&#39;)continue;
                    Bt1=CreateBiTree();
                    Task1(Bt1);
                    break;
            case&#39;2&#39;:FLAG = 1;
                    Task2(&amp;Bt2);
                    break;
            case&#39;3&#39;:Task3(Bt1);
                    break;
            case&#39;4&#39;:Task3(Bt2);
                    break;
            case&#39;5&#39;:Task4(Bt1, Bt2);
                    break;
            default:exit(0);
        &#125;
        while(getchar() != &#39;\n&#39;)continue;
        printf(&quot;\nInput your order(q to quit):  &quot;);
    &#125;while(scanf(&quot; %c&quot;, &amp;order));
    return 0;
&#125;
</code></pre>
<p><img data-src="https://img-blog.csdnimg.cn/20210327175926301.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>虽然说这里有4个题目，但还是要把它们封装成一个程序，并且可以通过循环来让程序能够反复实现我们所需的功能（<strong>要是提交4个程序给老师，我怕是不想活了</strong>）</p>
<p><strong>敲黑板！！！</strong><br><strong>可能很多人都觉得我发这些实验有用吗，都没什么干货，题也不分析，知识点也不总结，就给出题干代码来骗赞。。。</strong><br><img data-src="https://img-blog.csdnimg.cn/20210328213802918.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>*<em>你这么说我就不乐意了（<del>还是蛮赞同的</del><em>），发题主要是为了看到这篇文章的小伙伴们能够动脑动手敲一敲，在不懂的地方可以参考一下我的代码（<del>帮我找找bug呀</del> ），里面也有部分解析（<del>我承认确实是部分</del> ），知识点啥的呢以后会分点细讲的（<del>手动单曲循环《后来》</del> ），所以还请大家多多包涵和支持，共同进步啊！！！</em></em><br><img data-src="https://img-blog.csdnimg.cn/20210328214024165.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>​		</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>树形结构及其应用</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>RLC串联谐振电路</title>
    <url>/Electrotechnics/RLC%E4%B8%B2%E8%81%94%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>(1)	通过实验进一步理解RLC串联电路的频率特性；<br>(2)	了解串联谐振的现象，研究电路参数对串联谐振电路的影响；<br>(3)	理解串联谐振电路的选频特性及应用，掌握谐振曲线的测量方法；<br>(4)	学会使用仿真实验平台查看电压和电流在不同频率表下的波形，并且根据波形找到发生串联谐振时的频率。<br>(5)	学会通过仿真实验平台来分析不同频率、不同阻值情况下电压和电流波形的变化情况。</p>
<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>(1)RLC串联谐振原理：在RLC串联电路中，当外加角频率为ω的正弦电压U时，电路中的电流为I，即I&#x3D;U&#x2F;(R^’+j(ωL-1&#x2F;ωC) )，式中，R^’&#x3D;R+r，r为线圈电阻。当ωL&#x3D;1&#x2F;ωC时，电路发生串联谐振，谐振频率为f_0&#x3D;1&#x2F;(2π√LC)，	该式即为产生串联谐振顶点条件。可见，改变L、C或电源频率f都可以实现谐振。本实验通过改变外加电压的频率来使电路达到谐振。<br>(2)原理图如下：<br><img data-src="https://img-blog.csdnimg.cn/20210601214801596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="实验过程与原始数据"><a href="#实验过程与原始数据" class="headerlink" title="实验过程与原始数据"></a>实验过程与原始数据</h2><ol>
<li><pre><code>验证串联谐振电路
</code></pre>
(1)实验过程：在画布中插入一个电阻R、一个电感L、一个电容C、一个电源U，再将电阻赋为51Ω、电感赋为10mH、电容赋为0.022μF、电源赋为交流250mV（幅值）。然后设置仿真频率范围，再查看电阻的电压波形和电流波形在不同频率下的变化情况，找到电压和电流同相位时的所对应的频率，即为该电路的串联谐振频率。之后将电源的频率调整为发生串联谐振时的频率，重新运行电路，测出电压和电流等相关参数，并计算品质因数。<br>(2)原始数据（U &#x3D; 250mV（幅值））：<br><img data-src="https://img-blog.csdnimg.cn/20210601214949213.png" alt="在这里插入图片描述"></li>
<li><pre><code>测量串联谐振曲线
</code></pre>
(1)	实验过程：先将电阻的阻值赋为100Ω，同时将电源的频率设定为某一特定值，然后运行电路图，测量电压和电流等相关参数，并计算品质因数。重复上述过程。之后再讲电阻的阻值赋为510Ω，再重复上述过程。<br>(2)	原始数据：<br><img data-src="https://img-blog.csdnimg.cn/20210601215137285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210601215149575.png" alt="在这里插入图片描述"></li>
<li><pre><code>用示波器观察RLC串联谐振电路的波形
</code></pre>
(1)	实验过程：将电源的频率赋为串联谐振频率，然后运行电路图，查看并记录电压和电流的波形。之后更换电源的频率，重复上述过程。<br>(2)	原始数据：串联谐振频率为10.7kHz，低频为5kHz，高频为20kHz。</li>
</ol>
<h2 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a>实验结果及分析</h2><ol>
<li><pre><code>验证串联谐振电路
</code></pre>
(1)	实验结果：<br><img data-src="https://img-blog.csdnimg.cn/20210601215233796.png" alt="在这里插入图片描述"><br>(2)	分析：当电路发生串联谐振时，电容和电感的电压近似相等，此时电路中的电流达到最大值。</li>
<li><pre><code>测量串联谐振曲线
</code></pre>
(1)	实验结果：<br><img data-src="https://img-blog.csdnimg.cn/20210601215310673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210601215323478.png" alt="在这里插入图片描述"><br>(2)	分析：<br>①无论是电阻的阻值如何变化，电压和电流的波形在不同频率下的变化情况相同，即串联谐振频率的大小与电阻无关，且在发生串联谐振时，电压和电流取得最大值。<br><img data-src="https://img-blog.csdnimg.cn/20210601215344226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210601215349545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>②电路的品质因数随着电阻的增大而减小。<br><img data-src="https://img-blog.csdnimg.cn/20210601215418257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>③Q值越大，通用串联谐振曲线的形状越尖锐，电路的选择性越好。<br><img data-src="https://img-blog.csdnimg.cn/20210601215459941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><pre><code>用示波器观察RLC串联谐振电路的波形
</code></pre>
实验结果：<br><img data-src="https://img-blog.csdnimg.cn/20210601215538222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/2021060121555242.png" alt="在这里插入图片描述"><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2>(1)①电压和电流同相位；<br>②电容和电感的电压大小相等；<br>③电路中电压和电流达到最大值。<h2 id="实验体会与建议"><a href="#实验体会与建议" class="headerlink" title="实验体会与建议"></a>实验体会与建议</h2>(1)	体会：通过这次实验，我学会了如何使用仿真实验平台来查看电压和电流在不同频率下的波形并根据波形找到串联谐振频率，还掌握了通过仿真实验平台来分析不同频率、不通过阻值情况下电压和电流的波形变化情况。而且，这次实验使我对串联谐振的原理以及发生串联谐振时电路具有的特征的理解更加深刻，并熟练掌握了判断电路发生了串联谐振的方法。在此之外，我对串联谐振电路的相关参数的理论计算也变得更加熟练。<br>(2)	建议：课前尽可能明确课程目标及实验要求，以防课上花费较长时间在修改和统一实验操作上。</li>
</ol>
<p><strong>敲黑板！！！</strong></p>
<p><strong>叠加定理与戴维南定理&#x2F;RLC串联谐振电路&#x2F;单管交流电压放大电路&#x2F;集成放大器的应用完整实验报告</strong><br><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9LaXNzTW9vbl8vMTkzMjI4OTY=">https://download.csdn.net/download/KissMoon_&#x2F;19322896</span></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210601215936285.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>电工与电子技术</category>
        <category>RLC串联谐振电路</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>电工与电子技术</tag>
      </tags>
  </entry>
  <entry>
    <title>叠加定理与戴维南定理</title>
    <url>/Electrotechnics/%E5%8F%A0%E5%8A%A0%E5%AE%9A%E7%90%86%E4%B8%8E%E6%88%B4%E7%BB%B4%E5%8D%97%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>(1)	学习和掌握常用电工电子仪器仪表使用方法；<br>(2)	掌握电流、电压参考方向的含义及其应用；<br>(3)	通过实验验证并加深对叠加定理、戴维南定理的理解；<br>(4)	了解戴维南定理是化简复杂电路的一种有效方法；<br>(5)	学习并熟练掌握仿真实验软件的基本操作。</p>
<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p><img data-src="https://img-blog.csdnimg.cn/20210601120506702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210601120543324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210601120601656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="实验过程与原始数据"><a href="#实验过程与原始数据" class="headerlink" title="实验过程与原始数据"></a>实验过程与原始数据</h2><p>（1）叠加定理<br>实验过程：在画布中插入一个电压源US，一个电流源IS，两个电阻R1和R2；将US的电压值置为10V，IS的电流值置为20mA，R1的阻值置为220Ω，R2的阻值置为100Ω；用导线将各元件连接起来，然后接地。<br>1)	当US，IS共同作用时，直接运行电路图，然后测量各支路电流和电阻元件两端的电压值。<br>2)	当电压源US单独作用时，保持电压源US的电压值不变，将电流源IS的电流值置为0，然后运行电路图，再测量各支路电流和电阻元件两端的电压值。<br>3)	当电流源IS单独作用时，将电流源IS的电流值恢复为20mA，电压源US的电压值置为0，然后运行电路图，再测量各支路电流和电阻元件两端的电压值。<br>初始数据：电压源US&#x3D;10V，直流电流源IS&#x3D;20mA，电阻R1&#x3D;220Ω，R2&#x3D;100Ω<br>理论值计算结果如下（V&#x2F;mA）：<br><img data-src="https://img-blog.csdnimg.cn/20210601120718798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（2）戴维南定理<br>实验过程：在画布中插入两个电压源US和UOC，一个电流源IS，六个电阻R1、R2、R3、RS、RL1、RL2；将US的电压值置为10V，IS的电流值置为20mA，R1的阻值置为510Ω，R2的阻值置为220Ω，R3的阻值置为100Ω；用导线将元件US、IS、R1、R2、R3、RL1和UOC、RS和RL2分别连接，然后各自接地；<br>1)	测量有源一端口网络的等效电路参数：将RL1与ab端断开，然后运行电路图，测量出ab端开路电压，将电压源UOC的电压值置为该开路电压的值。在画布中插入一个电压源UO，将其电压值置为10V，并用导线将其与ab两端连接起来，然后运行电路图，测量出端口电流IO，计算出等效内阻，将电阻RS的阻值置为该等效内阻。<br>2)	测量有缘一端口网络的外特性：用将RL与ab端连接起来，然后多次调节RL1和RL2的阻值，该过程需保证两者阻值相等，然后运行电路图，测量出通过RL1和RL2的电流及RL1和RL2两端电压。<br>初始数据：US&#x3D;10V，IS&#x3D;20mA，R1&#x3D;510Ω，R2&#x3D;220Ω，R3&#x3D;100Ω，RL是0~10kΩ的可调电阻<br>理论值计算结果及初始设定测量值如下（V&#x2F;mA）：<br>1.	线性含源一端口电阻网络等效电路参数测试<br><img data-src="https://img-blog.csdnimg.cn/20210601120750414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.	含源一端口网络及等效电路外特性测试<br><img data-src="https://img-blog.csdnimg.cn/20210601120820376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a>实验结果及分析</h2><p>（1）叠加定理<br>实验结果：<br><img data-src="https://img-blog.csdnimg.cn/20210601120908506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>分析：<br>①	无论是理论值还是测量值，对于电压和电流这两个参数，都满足：US、IS共同作用时产生的响应等于US和IS单独作用时产生的响应的代数和，即叠加定理成立。<br><img data-src="https://img-blog.csdnimg.cn/20210601120923341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>②	无论是US、IS共同作用，还是US和IS单独作用，对于表中任一参数，测量值与理论值近似相等，验证了叠加定理用于理论计算的正确性。<br>（2）戴维南定理<br>1）线性含源一端口电阻网络等效电路参数测试<br>实验结果：<br><img data-src="https://img-blog.csdnimg.cn/20210601120944365.png" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210601121011979.png" alt="在这里插入图片描述"><br>分析：等效电路端口电压的测量值与等效电路开路电压计算值相等，且采用两种不同的电阻测量方法时，等效电路等效内阻的测量值都与等效电路等效内阻计算值相等，验证了戴维南定理的正确性。<br>2）含源一端口网络及等效电路外特性测试<br>实验结果：<br><img data-src="https://img-blog.csdnimg.cn/20210601121033779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>分析：<br>①	当外电路电阻减小时，外电路电流增大，而端口电压减小，即该等效电路与外电路满足闭合电路欧姆定律。<br><img data-src="https://img-blog.csdnimg.cn/20210601121045279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>②	无论外电路电阻如何变化，外电路电流及端口电压的测量值始终与理论值相等，说明即使外电路发生变化，戴维南定理也始终成立。</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>(1)	US、IS共同作用时的功率为P1 &#x3D; U1×I1 &#x3D; （-5.500×25.000）J &#x3D; -137.500J<br>                         P2 &#x3D; U2×I2 &#x3D; （4.500×45.000）J &#x3D; 202.500J<br>US单独作用时的功率为P，1 &#x3D; U，1×I，1 &#x3D; （-6.875×31.250）J &#x3D; -214.844J<br>                       	P，2 &#x3D; U，2×I，2 &#x3D; （3.125×31.250）J &#x3D; 97.656J<br>IS单独作用时的功率为P，，1 &#x3D; U，，1×I，，1 &#x3D; （1.375×-6.250）J &#x3D; -8.594J<br>                        P，，2 &#x3D; U，，2×I，，2 &#x3D; （1.375×13.750）J &#x3D; 18.906J<br>易得P，1 + P，，1 ≠ P1，P，2 + P，，2 ≠ P2<br>则电阻上的功率不符合叠加定理</p>
<h2 id="实验体会与建议"><a href="#实验体会与建议" class="headerlink" title="实验体会与建议"></a>实验体会与建议</h2><ol>
<li><pre><code>体会：①实验中，通过使用仿真实验平台对叠加定理和戴维南定理进行实验验证，我已经掌握了运用该平台模拟电路实验的基本操作，并且对两个定理的原理理解更加深刻，能够熟练运用相关原理来解决电路问题。②通过对思考题的分析解答，认识到了电阻的功率不满足叠加定理，避免了错误使用叠加定理的情况③提高了分析问题的全面性和逻辑思考的缜密性，同时也增强了我的耐心及专注度。
</code></pre>
</li>
<li><pre><code>建议：①指导书及实验报告中有些说法较难理解，希望能够用一种更为通俗易懂的方式表达操作要求。②鉴于仿真实验平台的语言是英语，且学生对元件的英语名称不够熟悉，在平台中寻找所需元件或者其等效元件时较为困难，建议在实验要求中给出所需元件或其等效元件仿真实验平台中英文名称。
</code></pre>
</li>
</ol>
<p><strong>敲黑板！！！</strong></p>
<p><strong>叠加定理与戴维南定理&#x2F;RLC串联谐振电路&#x2F;单管交流电压放大电路&#x2F;集成放大器的应用完整实验报告</strong><br><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9LaXNzTW9vbl8vMTkzMjI4OTY=">https://download.csdn.net/download/KissMoon_&#x2F;19322896</span></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210601220105288.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>电工与电子技术</category>
        <category>叠加定理与戴维南定理</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>电工与电子技术</tag>
      </tags>
  </entry>
  <entry>
    <title>贪吃蛇-Python语言实现</title>
    <url>/GameDevelopment/%E8%B4%AA%E5%90%83%E8%9B%87-Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>贪吃蛇（也叫做贪食蛇）游戏是一款休闲益智类游戏，既简单又耐玩，唯一的目标就是<strong>做这条gai上最长（pang）的蛇（zhu）</strong>！</p>
<p>玩贪吃蛇最考验的就是走位（<strong>简称蛇皮走位</strong>），各种漂移过人，唉，就是玩儿！</p>
<p><img data-src="https://img-blog.csdnimg.cn/20210601204813403.gif#pic_center" alt="在这里插入图片描述"></p>
<h2 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h2><pre><code class="python"># 基本设置
lattice_wh = 20
snake_color = (84, 255, 159)
snake_head_color = (123, 104, 238)
food_color = (255, 64, 64)
</code></pre>
<h2 id="绘制屏幕"><a href="#绘制屏幕" class="headerlink" title="绘制屏幕"></a>绘制屏幕</h2><pre><code class="bash"># 绘制屏幕
pygame.init()
screen = pygame.display.set_mode((25*lattice_wh, 25*lattice_wh))
pygame.display.set_caption(&quot;贪吃蛇&quot;)

# 帧率，每秒刷新屏幕次数
FPS = 10
# 帧率变化系数
level = 1.5
# 时间对象
FPSCLOCK = pygame.time.Clock()
# 游戏结束标志
game_over = 0
# 前进方向
direction = 0
# 进食数量
num = 0
</code></pre>
<h2 id="蛇类"><a href="#蛇类" class="headerlink" title="蛇类"></a>蛇类</h2><pre><code class="python"># 蛇
class Snake():
    def __init__(self, snake_color, snake_head_color, x, y, lattice_wh):
        self.color = snake_color
        self.head_color = snake_head_color
        # 左上顶点坐标
        self.pos = (x, y)
        self.lattice_wh = lattice_wh
          # 绘制蛇体
        self.rect = pygame.rect.Rect(x, y, self.lattice_wh, self.lattice_wh)
        # 左上顶点坐标变化
        self.pos_change = &#123;
            # 上移
            1:(0, -self.lattice_wh),
            # 下移
            2:(0, self.lattice_wh),
            # 左移
            3:(-self.lattice_wh, 0),
            # 右移
            4:(self.lattice_wh, 0)
        &#125;
    
    def move(self, direction):
        self.rect.x += self.pos_change[direction][0]
        self.rect.y += self.pos_change[direction][1]

    def forecast(self, direction):
        return (self.rect.x+self.pos_change[direction][0], self.rect.y+self.pos_change[direction][1])
</code></pre>
<h2 id="食物类"><a href="#食物类" class="headerlink" title="食物类"></a>食物类</h2><pre><code class="python"># 食物
class Food():
    def __init__(self, food_color, screen, lattice_wh, x, y):
        self.screen = screen
        self.color = food_color
        self.lattice_wh = lattice_wh
        # 半径
        self.radius = lattice_wh/2
        self.x, self.y = x, y

    def draw(self):
        # 圆心
        pos = (self.x+self.lattice_wh/2, self.y+self.lattice_wh/2)
        # 绘制食物
        pygame.draw.circle(self.screen, self.color, pos, self.radius, int(self.radius))
</code></pre>
<h2 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h2><pre><code class="python"># 贪吃蛇
snakes = list()
snakes.append(Snake(snake_color, snake_head_color, lattice_wh, 24*lattice_wh, lattice_wh))
snakes.append(Snake(snake_color, snake_head_color, 0, 24*lattice_wh, lattice_wh))

# 食物
food = create_food(food_color, screen, lattice_wh, snakes)

# 游戏状态
game_stats = [game_over, direction, num, food]
</code></pre>
<h2 id="生成食物"><a href="#生成食物" class="headerlink" title="生成食物"></a>生成食物</h2><pre><code class="python"># 生成食物
def create_food(food_color, screen, lattice_wh, snakes):
    # 食物是否生成成功
    create_success = 0
    # 食物位置坐标
    food_x, food_y = 0, 0
    while not create_success:
        food_x, food_y = randint(0, 24), randint(0, 24)
        food_x *= lattice_wh
        food_y *= lattice_wh
        # 检查食物位置是否与贪吃蛇位置重合
        for snake in snakes:
            if (food_x, food_y) != (snake.rect.x, snake.rect.y):
                create_success = 1
                break
    # 在指定位置生成食物
    food = Food(food_color, screen, lattice_wh, food_x, food_y)
    return food
</code></pre>
<h2 id="响应键鼠"><a href="#响应键鼠" class="headerlink" title="响应键鼠"></a>响应键鼠</h2><pre><code class="python"># 响应键鼠
def check_events(game_stats):
    for event in pygame.event.get():
        # 退出游戏
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        # 控制移动方向，注意不能直接反向移动
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_UP and game_stats[1] != 2:
                game_stats[1] = 1
            elif event.key == pygame.K_DOWN and game_stats[1] != 1:
                game_stats[1] = 2
            elif event.key == pygame.K_LEFT and game_stats[1] != 4:
                game_stats[1] = 3
            elif event.key == pygame.K_RIGHT and game_stats[1] != 3:
                game_stats[1] = 4
            else:
                game_stats[1] = game_stats[1]
</code></pre>
<h2 id="更新屏幕"><a href="#更新屏幕" class="headerlink" title="更新屏幕"></a>更新屏幕</h2><pre><code class="python"># 更新屏幕
def update(screen, lattice_wh, snakes, game_stats):
    screen.fill((255, 255, 255))
    # 绘制蛇头
    pygame.draw.rect(screen, snakes[0].head_color, snakes[0].rect)
    # 绘制蛇身
    for i in range(1, len(snakes)):
        pygame.draw.rect(screen, snakes[i].color, snakes[i].rect)
    # 绘制横线
    for i in range(25):
        pygame.draw.line(screen, (105, 105, 105), (0, lattice_wh*i), (500, lattice_wh*i))
    # 绘制竖线
    for i in range(25):
        pygame.draw.line(screen, (105, 105, 105), (lattice_wh*i, 0), (lattice_wh*i, 500))
    # 绘制食物
    game_stats[3].draw()
    # 更新屏幕
    pygame.display.flip()
</code></pre>
<h2 id="移动进食"><a href="#移动进食" class="headerlink" title="移动进食"></a>移动进食</h2><pre><code class="python"># 移动进食
def going(screen, game_stats, snakes, snake_head_color, snake_color, food_color, lattice_wh):
    if not game_stats[1]:
        return
    # 蛇头下一前进位置
    (x, y) = snakes[0].forecast(game_stats[1])
    # 检查是否触碰边界
    if x == -lattice_wh or x == 25*lattice_wh or y == -lattice_wh or y == 25*lattice_wh:
        game_stats[0] = 1
        return
    # 检查是否触碰食物
    if (x, y) == (game_stats[3].x, game_stats[3].y):
        # 更新蛇头
        new_head = Snake(snake_color, snake_head_color, x, y, lattice_wh)
        snakes.insert(0, new_head)
        # 更新分数
        game_stats[2] += 1
        # 重新生成食物
        game_stats[3] = create_food(food_color, screen, lattice_wh, snakes)
        return
    # 检查是否触碰蛇身
    for snake in snakes:
        if (x, y) == (snake.rect.x, snake.rect.y):
            game_stats[0] = 1
            return
    # 更新所有蛇身位置
    for i in range(len(snakes)-1, 0, -1):
        snakes[i].rect.x = snakes[i-1].rect.x
        snakes[i].rect.y = snakes[i-1].rect.y
    # 更新蛇头位置
    snakes[0].move(game_stats[1])
</code></pre>
<h2 id="游戏入口"><a href="#游戏入口" class="headerlink" title="游戏入口"></a>游戏入口</h2><pre><code class="python"># 游戏入口
while not game_stats[0]:
    update(screen, lattice_wh, snakes, game_stats)
    check_events(game_stats)
    going(screen, game_stats, snakes, snake_head_color, snake_color, food_color, lattice_wh)
    FPSCLOCK.tick(FPS * level ** num if FPS * level ** num &lt; 60 else 60)
</code></pre>
<h2 id="snake-py"><a href="#snake-py" class="headerlink" title="snake.py"></a>snake.py</h2><pre><code class="python">import pygame

# 蛇
class Snake():
    def __init__(self, snake_color, snake_head_color, x, y, lattice_wh):
        self.color = snake_color
        self.head_color = snake_head_color
        # 左上顶点坐标
        self.pos = (x, y)
        self.lattice_wh = lattice_wh
        # 绘制蛇体
        self.rect = pygame.rect.Rect(x, y, self.lattice_wh, self.lattice_wh)
        # 左上顶点坐标变化
        self.pos_change = &#123;
            # 上移
            1:(0, -self.lattice_wh),
            # 下移
            2:(0, self.lattice_wh),
            # 左移
            3:(-self.lattice_wh, 0),
            # 右移
            4:(self.lattice_wh, 0)
        &#125;

    # 移动
    def move(self, direction):
        self.rect.x += self.pos_change[direction][0]
        self.rect.y += self.pos_change[direction][1]

    # 下一前进位置
    def forecast(self, direction):
        return (self.rect.x+self.pos_change[direction][0], self.rect.y+self.pos_change[direction][1])
</code></pre>
<h2 id="food-py"><a href="#food-py" class="headerlink" title="food.py"></a>food.py</h2><pre><code class="python">import pygame

# 食物
class Food():
    def __init__(self, food_color, screen, lattice_wh, x, y):
        self.screen = screen
        self.color = food_color
        self.lattice_wh = lattice_wh
        # 半径
        self.radius = lattice_wh/2
        self.x, self.y = x, y

    def draw(self):
        # 圆心
        pos = (self.x+self.lattice_wh/2, self.y+self.lattice_wh/2)
        # 绘制食物
        pygame.draw.circle(self.screen, self.color, pos, self.radius, int(self.radius))
</code></pre>
<h2 id="function-py"><a href="#function-py" class="headerlink" title="function.py"></a>function.py</h2><pre><code class="python">import pygame
import sys
from random import randint
from food import Food
from snake import Snake

# 生成食物
def create_food(food_color, screen, lattice_wh, snakes):
    # 食物是否生成成功
    create_success = 0
    # 食物位置坐标
    food_x, food_y = 0, 0
    while not create_success:
        food_x, food_y = randint(0, 24), randint(0, 24)
        food_x *= lattice_wh
        food_y *= lattice_wh
        # 检查食物位置是否与贪吃蛇位置重合
        for snake in snakes:
            if (food_x, food_y) != (snake.rect.x, snake.rect.y):
                create_success = 1
                break
    # 在指定位置生成食物
    food = Food(food_color, screen, lattice_wh, food_x, food_y)
    return food

# 响应事件
def check_events(game_stats):
    for event in pygame.event.get():
        # 退出游戏
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        # 控制移动方向，注意不能直接反向移动
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_UP and game_stats[1] != 2:
                game_stats[1] = 1
            elif event.key == pygame.K_DOWN and game_stats[1] != 1:
                game_stats[1] = 2
            elif event.key == pygame.K_LEFT and game_stats[1] != 4:
                game_stats[1] = 3
            elif event.key == pygame.K_RIGHT and game_stats[1] != 3:
                game_stats[1] = 4
            else:
                game_stats[1] = game_stats[1]

# 更新屏幕
def update(screen, lattice_wh, snakes, game_stats):
    screen.fill((255, 255, 255))
    # 绘制蛇头
    pygame.draw.rect(screen, snakes[0].head_color, snakes[0].rect)
    # 绘制蛇身
    for i in range(1, len(snakes)):
        pygame.draw.rect(screen, snakes[i].color, snakes[i].rect)
    # 绘制横线
    for i in range(25):
        pygame.draw.line(screen, (105, 105, 105), (0, lattice_wh*i), (500, lattice_wh*i))
    # 绘制竖线
    for i in range(25):
        pygame.draw.line(screen, (105, 105, 105), (lattice_wh*i, 0), (lattice_wh*i, 500))
    # 绘制食物
    game_stats[3].draw()
    # 更新屏幕
    pygame.display.flip()

# 移动进食
def going(screen, game_stats, snakes, snake_head_color, snake_color, food_color, lattice_wh):
    if not game_stats[1]:
        return
    # 蛇头下一前进位置
    (x, y) = snakes[0].forecast(game_stats[1])
    # 检查是否触碰边界
    if x == -lattice_wh or x == 25*lattice_wh or y == -lattice_wh or y == 25*lattice_wh:
        game_stats[0] = 1
        return
    # 检查是否触碰食物
    if (x, y) == (game_stats[3].x, game_stats[3].y):
        # 更新蛇头
        new_head = Snake(snake_color, snake_head_color, x, y, lattice_wh)
        snakes.insert(0, new_head)
        # 更新分数
        game_stats[2] += 1
        # 重新生成食物
        game_stats[3] = create_food(food_color, screen, lattice_wh, snakes)
        return
    # 检查是否触碰蛇身
    for snake in snakes:
        if (x, y) == (snake.rect.x, snake.rect.y):
            game_stats[0] = 1
            return
    # 更新所有蛇身位置
    for i in range(len(snakes)-1, 0, -1):
        snakes[i].rect.x = snakes[i-1].rect.x
        snakes[i].rect.y = snakes[i-1].rect.y
    # 更新蛇头位置
    snakes[0].move(game_stats[1])
</code></pre>
<h2 id="main-py"><a href="#main-py" class="headerlink" title="main.py"></a>main.py</h2><pre><code class="python">import pygame
from function import *
from snake import Snake

# 基本设置
lattice_wh = 20
snake_color = (84, 255, 159)
snake_head_color = (123, 104, 238)
food_color = (255, 64, 64)

# 绘制屏幕
pygame.init()
screen = pygame.display.set_mode((25*lattice_wh, 25*lattice_wh))
pygame.display.set_caption(&quot;贪吃蛇&quot;)

# 帧率，每秒刷新屏幕次数
FPS = 10
# 帧率变化系数
level = 1.5
# 时间对象
FPSCLOCK = pygame.time.Clock()

# 游戏结束标志
game_over = 0

# 前进方向
direction = 0
# 进食数量
num = 0

# 贪吃蛇
snakes = list()
snakes.append(Snake(snake_color, snake_head_color, lattice_wh, 24*lattice_wh, lattice_wh))
snakes.append(Snake(snake_color, snake_head_color, 0, 24*lattice_wh, lattice_wh))

# 食物
food = create_food(food_color, screen, lattice_wh, snakes)

# 游戏状态
game_stats = [game_over, direction, num, food]

# 游戏入口
while not game_stats[0]:
    update(screen, lattice_wh, snakes, game_stats)
    check_events(game_stats)
    going(screen, game_stats, snakes, snake_head_color, snake_color, food_color, lattice_wh)
    FPSCLOCK.tick(FPS * level ** num if FPS * level ** num &lt; 60 else 60)
</code></pre>
<p><strong>敲黑板！！！在控制蛇的移动方向时，易忽略蛇不能直接反向移动这一问题；另外，在生成食物时，要检查食物的位置与蛇的位置是否重合，如果两者位置重合，此时需要生成新的食物。</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210601212016193.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="wolf"></p>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>贪吃蛇-Python语言实现</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>贪吃蛇</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>单管交流电压放大电路</title>
    <url>/Electrotechnics/%E5%8D%95%E7%AE%A1%E4%BA%A4%E6%B5%81%E7%94%B5%E5%8E%8B%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>(1)	掌握晶体管放大电路静态工作点的调试方法。<br>(2)	了解静态工作点的改变对放大电路性能的影响。<br>(3)	了解饱和失真和截止失真对放大电路输出电压波形的影响。<br>(4)	进一步熟悉仿真实验平台的各种基本操作。</p>
<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>(1)	实验原理：单管交流电压放大电路的最典型电路是共发射极分压偏置式交流电压放大电路，原理图如下。在原理图中，晶体管为非线性元件，要使放大器不产生非线性失真，就必须建立一个合适的静态工作点，使晶体管工作在放大区。若Q点过低（IB小，则IC小，UCE大），晶体管进入截止区，产生截止失真；Q点过高（IB、IC大，UCE小），晶体管将进入饱和区，产生饱和失真。调节基极电阻RP即可调整静态工作点。电压放大倍数为<br><img data-src="https://img-blog.csdnimg.cn/20210601220449802.png" alt="在这里插入图片描述"><br>(2)	原理图：<br><img data-src="https://img-blog.csdnimg.cn/2021060122051847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="实验过程与原始数据"><a href="#实验过程与原始数据" class="headerlink" title="实验过程与原始数据"></a>实验过程与原始数据</h2><ol>
<li><pre><code>调整静态工作点
</code></pre>
(1)	实验过程：先根据UCE&#x3D;1&#x2F;2VCC计算出电阻RP阻值的大致范围，然后将电阻RP进行赋值，运行电路图，不断对电阻RP的阻值进行微小调整，直至出现符合要求的静态工作点。<br>(2)	原始数据：<br>RB1&#x3D;20kΩ，RB2&#x3D;20kΩ，RC&#x3D;2.4kΩ，RE&#x3D;1kΩ，C1&#x3D;10μF，C2&#x3D;10μF，CE&#x3D;47μF，VCC&#x3D;12V，Ui&#x3D;10mV（有效值），频率f&#x3D;1kHz<br><img data-src="https://img-blog.csdnimg.cn/20210601220558523.png" alt="在这里插入图片描述"></li>
<li><pre><code>测量电压放大倍数
</code></pre>
(1)	实验过程：当静态工作点测量完毕之后，保持静态工作点不变，接通信号源。在画布中插入一个电阻RL，开始时RL无需接入电路，即RL&#x3D;∞，运行电路图，测量UO并计算Au；然后将RL接入电路，其阻值分别赋为10kΩ和1k欧姆，重复上述过程。<br>(2)	原始数据：<br>RB1&#x3D;20kΩ，RB2&#x3D;20kΩ，RC&#x3D;2.4kΩ，RE&#x3D;1kΩ，RP&#x3D;44.67kΩ，C1&#x3D;10μF，C2&#x3D;10μF，CE&#x3D;47μF，VCC&#x3D;12V，Ui&#x3D;10mV（幅值），频率f&#x3D;1kHz<br><img data-src="https://img-blog.csdnimg.cn/2021060122062057.png" alt="在这里插入图片描述"></li>
<li><pre><code>观测静态工作点对输出电压波形的影响
</code></pre>
(1)	实验过程：<br>①	最佳静态工作点的情况：调节RP，使静态工作点在最佳位置时，观察输出电压波形；然后断开信号源，测量UBE、UCE、VB的电压值以及IB、IC的电流值。<br>②	饱和失真的情况：将RP的阻值逐渐减小，输入信号保持不变，观察输出电压波形，使波形出现饱和失真。然后断开信号源，测量UBE、UCE、VB的电压值以及IB、IC的电流值。<br>③	输入信号增大的情况：输入信号Ui&#x3D;10mV，频率f&#x3D;1kHz，调节RP，使之达到最佳静态工作点。然后逐渐增大Ui，观察输出电压波形，使输出电压波形同时出现饱和失真和截止失真，测量UBE、UCE、VB的电压值以及IB、IC的电流值。<br>(2)	原始数据：<br>RB1&#x3D;20kΩ，RB2&#x3D;20kΩ，RC&#x3D;2.4kΩ，RE&#x3D;1kΩ，C1&#x3D;10μF，C2&#x3D;10μF，CE&#x3D;47μF，VCC&#x3D;12V</li>
</ol>
<p><img data-src="https://img-blog.csdnimg.cn/20210601220741694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>四、实验结果及分析<br>1.	调整静态工作点<br>(1)	实验结果：<br><img data-src="https://img-blog.csdnimg.cn/20210601220810184.png" alt="在这里插入图片描述"><br>2.	测量电压放大倍数<br>(1)	实验结果：<br><img data-src="https://img-blog.csdnimg.cn/20210601220830736.png" alt="在这里插入图片描述"><br>(2)	分析：电压放大倍数Au随着负载阻值RL的减小而减小。<br><img data-src="https://img-blog.csdnimg.cn/20210601220842469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.	观测静态工作点对输出电压波形的影响<br>(1)	实验结果：<br><img data-src="https://img-blog.csdnimg.cn/20210601220908135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(2)	分析：输入信号合适时，如果静态工作点过高，会出现饱和失真，如果静态工作点过低，会出现截止失真；静态工作点合适时，如果输入信号的幅值过大，则会导致电路同时出现饱和失真和截止失真。</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>(1)	晶体管的静态工作点不合适。Q点过低时会导致截止失真，Q点过高时会导致饱和失真。可以通过调整RB的阻值来获得最佳静态工作点。<br>(2)	增大负载RL的阻值。</p>
<h2 id="实验体会与建议"><a href="#实验体会与建议" class="headerlink" title="实验体会与建议"></a>实验体会与建议</h2><p>(1)	体会：在本次实验中，我学会了如何寻找放大电路的最佳静态工作点，并测量和计算最佳静态工作点时电路的各项参数；另外，我还学会了测量并分析电压放大倍数随着负载阻值的改变时产生的变化情况；最后，我还进一步理解了产生饱和失真和截止失真的条件以及两种失真对电路输出电压波形的影响。本次实验是对放大电路的综合考量，极大地增强了我对放大电路的原理及原理图、失真产生条件、输出电压特性、电压电流放大倍数等方面的理解。<br>(2)	建议：在本次实验中，一些原理和步骤较难理解，而且在操作上不易实现，希望能够在正式实验之前能够对实验过程中可能出现的重点难点问题进行相应的提示和指导。</p>
<p><strong>敲黑板！！！</strong></p>
<p><strong>叠加定理与戴维南定理&#x2F;RLC串联谐振电路&#x2F;单管交流电压放大电路&#x2F;集成放大器的应用完整实验报告</strong><br><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9LaXNzTW9vbl8vMTkzMjI4OTY=">https://download.csdn.net/download/KissMoon_&#x2F;19322896</span></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210601221106858.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>电工与电子技术</category>
        <category>单管交流电压放大电路</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>电工与电子技术</tag>
      </tags>
  </entry>
  <entry>
    <title>井字棋-Python语言实现</title>
    <url>/GameDevelopment/%E4%BA%95%E5%AD%97%E6%A3%8B-Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>井字棋，英文名叫Tic-Tac-Toe，是一种在3<em>3格子上进行的连珠游戏，由于棋盘一般不画边框，格线排成井字故得名。（</em><em><del>直接百度照抄哈哈哈</del></em>* ）</p>
<p>另外，百度还给出了一些攻略，反正我是没看懂。。。（**<del>想不到小小井字棋都要勾心斗角</del>** ）</p>
<p>当然，在这个小游戏中，要让电脑像人一样智能是不太可能的，因为要涉及到很多的技术。因此，为了简化游戏，<strong>电脑下棋的位置将采用随机数的方式来确定</strong>。<br><img data-src="https://img-blog.csdnimg.cn/20210601105203318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="绘制屏幕"><a href="#绘制屏幕" class="headerlink" title="绘制屏幕"></a>绘制屏幕</h2><pre><code class="python">import pygame
import sys

# 屏幕大小
screen_width, screen_height = 600, 600
# 格子大小
lattice_width = screen_width/3 - 1
lattice_height = screen_height/3 - 1

# 绘制屏幕
pygame.init()
screen = pygame.display.set_mode((screen_width, screen_height))
pygame.display.set_caption(&quot;井字棋&quot;)
</code></pre>
<h2 id="格子类"><a href="#格子类" class="headerlink" title="格子类"></a>格子类</h2><pre><code class="python"># 格子
class Lattice():
    def __init__(self, rect, screen):
        self.rect = rect
        self.screen = screen
        # 格子状态 -1表示格子被用户占领，1表示格子被电脑占领
        self.stats = 0
        # 格子样式
        self.text_color = (30, 30, 30)
        self.bg_color = (255, 255, 255)
        self.font = pygame.font.SysFont(None, 100)

    def draw(self):
        msg = &quot;&quot;
        # 用户字符U，电脑字符C
        if self.stats == -1:
            msg = &quot;U&quot;
        elif self.stats == 1:
            msg = &quot;C&quot;
        else:
            msg = &quot;&quot;
        # 绘制格子
        if msg:
            self.msg_image = self.font.render(msg, True, self.text_color, self.bg_color)
            self.msg_rect = self.msg_image.get_rect()
            self.msg_rect.center = self.rect.center
            self.screen.blit(self.msg_image, self.msg_rect)
</code></pre>
<h2 id="九宫格"><a href="#九宫格" class="headerlink" title="九宫格"></a>九宫格</h2><pre><code class="python"># 存储九宫格的内容
rects = [0] * 9
# 存储每个格子左上顶点的坐标
rect_wh = [(1, 1), (lattice_width+3, 1), (lattice_width*2+5, 1),
           (1, lattice_height+3), (lattice_width+3, lattice_height+3), (lattice_width*2+5, lattice_height+3),
           (1, lattice_height*2+5), (lattice_width+3, lattice_height*2+5), (lattice_width*2+5, lattice_height*2+5)
]

# 绘制九宫格
for i in range(len(rects)):
    rects[i] = pygame.rect.Rect(*rect_wh[i], lattice_width, lattice_height)
    rects[i] = Lattice(rects[i], screen)
</code></pre>
<p><strong>说明：屏幕的原点位于左上角，x轴横向延伸，y轴纵向延伸。</strong><br><img data-src="https://img-blog.csdnimg.cn/20210601111515926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>说明：绘制格子时涉及到参数的封装与解封装。</strong><br><img data-src="https://img-blog.csdnimg.cn/20210601113848983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="弹窗类"><a href="#弹窗类" class="headerlink" title="弹窗类"></a>弹窗类</h2><pre><code class="python"># 弹窗
class Popup():
    def __init__(self, screen, message):
        self.msg = message
        self.screen = screen
        self.bg_color = (0, 0, 0)
        self.text_color = (230, 230, 230)
        self.font = pygame.font.SysFont(None, 48)
        self.msg_image = self.font.render(self.msg, True, self.text_color, self.bg_color)
        self.msg_rect = self.msg_image.get_rect()
        self.screen_rect = self.screen.get_rect()
        self.msg_rect.centerx = self.screen_rect.centerx
        self.msg_rect.bottom = self.screen_rect.bottom
        self.screen.blit(self.msg_image, self.msg_rect)
</code></pre>
<h2 id="更新屏幕"><a href="#更新屏幕" class="headerlink" title="更新屏幕"></a>更新屏幕</h2><pre><code class="python"># 更新屏幕
def update(time_sleep = 0, msg = &quot;&quot;):
    screen.fill((255, 228, 181))
    for rect in rects:
        pygame.draw.rect(screen, (255, 255, 255), rect.rect)
        rect.draw()
    if msg:
        Popup(screen, msg)
    pygame.display.flip()
    if time_sleep:
        time.sleep(time_sleep)
</code></pre>
<h2 id="电脑回合"><a href="#电脑回合" class="headerlink" title="电脑回合"></a>电脑回合</h2><pre><code class="python"># 电脑回合
def computer_round():
    # 可选序号列表
    random_num = [i for i in range(len(rects)) if not rects[i].stats]
    # 没有可选序号
    if not random_num:
        update(3, &quot;Draw!&quot;)
        pygame.quit()
        sys.exit()
    rects[random.choice(random_num)].stats = 1
</code></pre>
<h2 id="判断胜负"><a href="#判断胜负" class="headerlink" title="判断胜负"></a>判断胜负</h2><pre><code class="python"># 判断胜负
def judge_result():
    global result
    # 用户序号列表
    stats_U = [i for i in range(len(rects)) if rects[i].stats == -1]
    # 电脑序号列表
    stats_C = [i for i in range(len(rects)) if rects[i].stats == 1]
    # 胜出条件列表
    win = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8],
        [0, 3, 6], [1, 4, 7], [2, 5, 8],
        [0, 4, 8], [2, 4, 6]
    ]
    # 遍历胜出条件列表，判断哪方胜出
    for i in win:
        if i == [j for j in i if j in stats_U]:
            update(3, &quot;You win!&quot;)
            pygame.quit()
            sys.exit()
        elif i == [j for j in i if j in stats_C]:
            update(3, &quot;Computer win!&quot;)
            pygame.quit()
            sys.exit()
</code></pre>
<p><img data-src="https://img-blog.csdnimg.cn/20210601113408753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="判断先手"><a href="#判断先手" class="headerlink" title="判断先手"></a>判断先手</h2><pre><code class="python"># 判断先手
def judge_first():
    # 0表示用户先手，1表示电脑先手
    x = random.randint(0, 1)
    if x:
        update(1, &quot;Computer&#39;s round!&quot;)
        computer_round()
    else:
        update(1, &quot;Your round!&quot;)
</code></pre>
<h2 id="游戏入口"><a href="#游戏入口" class="headerlink" title="游戏入口"></a>游戏入口</h2><pre><code class="python"># 游戏入口
judge_first()
while True:
    update()
    # 获取屏幕事件
    for event in pygame.event.get():
        # 退出游戏
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        # 点击屏幕
        elif event.type == pygame.MOUSEBUTTONDOWN:
            # 获取鼠标坐标
            mouse_x, mouse_y = pygame.mouse.get_pos()
            # 鼠标点击位置是否有效
            position_valid = 0
            for i in rects:
                # 鼠标点击有效
                if not i.stats and i.rect.collidepoint(mouse_x, mouse_y):
                    position_valid = 1
                    i.stats = -1
                    update()
                    judge_result()
                    update(1, &quot;Computer&#39;s round!&quot;)
                    time.sleep(1)
                    computer_round()
                    update()
                    judge_result()
                    update(1, &quot;Your round!&quot;)
            # 鼠标点击无效
            if not position_valid:
                update(1, &quot;Your choice is invalid!&quot;)
</code></pre>
<h2 id="运行游戏"><a href="#运行游戏" class="headerlink" title="运行游戏"></a>运行游戏</h2><p><img data-src="https://img-blog.csdnimg.cn/20210601113958746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210601114043481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="lattice-py"><a href="#lattice-py" class="headerlink" title="lattice.py"></a>lattice.py</h2><pre><code class="python">import pygame

# 格子
class Lattice():
    def __init__(self, rect, screen):
        self.rect = rect
        self.screen = screen
        # 格子状态 -1表示格子被用户占领，1表示格子被电脑占领
        self.stats = 0
        # 格子样式
        self.text_color = (30, 30, 30)
        self.bg_color = (255, 255, 255)
        self.font = pygame.font.SysFont(None, 100)

    def draw(self):
        msg = &quot;&quot;
        # 用户字符U，电脑字符C
        if self.stats == -1:
            msg = &quot;U&quot;
        elif self.stats == 1:
            msg = &quot;C&quot;
        else:
            msg = &quot;&quot;
        # 绘制格子
        if msg:
            self.msg_image = self.font.render(msg, True, self.text_color, self.bg_color)
            self.msg_rect = self.msg_image.get_rect()
            self.msg_rect.center = self.rect.center
            self.screen.blit(self.msg_image, self.msg_rect)
</code></pre>
<h2 id="popup-py"><a href="#popup-py" class="headerlink" title="popup.py"></a>popup.py</h2><pre><code class="python">import pygame

# 弹窗
class Popup():
    def __init__(self, screen, message):
        self.msg = message
        self.screen = screen
        self.bg_color = (0, 0, 0)
        self.text_color = (230, 230, 230)
        self.font = pygame.font.SysFont(None, 48)
        self.msg_image = self.font.render(self.msg, True, self.text_color, self.bg_color)
        self.msg_rect = self.msg_image.get_rect()
        self.screen_rect = self.screen.get_rect()
        self.msg_rect.centerx = self.screen_rect.centerx
        self.msg_rect.bottom = self.screen_rect.bottom
        self.screen.blit(self.msg_image, self.msg_rect)
</code></pre>
<h2 id="main-py"><a href="#main-py" class="headerlink" title="main.py"></a>main.py</h2><pre><code class="python">import pygame
import sys
import random
import time
from lattice import Lattice
from popup import Popup

# 屏幕大小
screen_width, screen_height = 600, 600
lattice_width = screen_width/3 - 1
lattice_height = screen_height/3 - 1

# 绘制屏幕
pygame.init()
screen = pygame.display.set_mode((screen_width, screen_height))
pygame.display.set_caption(&quot;井字棋&quot;)

# 建立九宫格
rects = [0] * 9
rect_wh = [(1, 1), (lattice_width+3, 1), (lattice_width*2+5, 1),
           (1, lattice_height+3), (lattice_width+3, lattice_height+3), (lattice_width*2+5, lattice_height+3),
           (1, lattice_height*2+5), (lattice_width+3, lattice_height*2+5), (lattice_width*2+5, lattice_height*2+5)
]

# 绘制九宫格
for i in range(len(rects)):
    rects[i] = pygame.rect.Rect(*rect_wh[i], lattice_width, lattice_height)
    rects[i] = Lattice(rects[i], screen)

# 更新屏幕
def update(time_sleep = 0, msg = &quot;&quot;):
    screen.fill((255, 228, 181))
    for rect in rects:
        pygame.draw.rect(screen, (255, 255, 255), rect.rect)
        rect.draw()
    if msg:
        Popup(screen, msg)
    pygame.display.flip()
    if time_sleep:
        time.sleep(time_sleep)

# 电脑回合
def computer_round():
    # 可选序号列表
    random_num = [i for i in range(len(rects)) if not rects[i].stats]
    # 没有可选序号
    if not random_num:
        update(3, &quot;Draw!&quot;)
        pygame.quit()
        sys.exit()
    rects[random.choice(random_num)].stats = 1

# 判断胜负
def judge_result():
    global result
    # 用户序号列表
    stats_U = [i for i in range(len(rects)) if rects[i].stats == -1]
    # 电脑序号列表
    stats_C = [i for i in range(len(rects)) if rects[i].stats == 1]
    # 胜出条件列表
    win = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8],
        [0, 3, 6], [1, 4, 7], [2, 5, 8],
        [0, 4, 8], [2, 4, 6]
    ]
    # 遍历胜出条件列表，判断哪方胜出
    for i in win:
        if i == [j for j in i if j in stats_U]:
            update(3, &quot;You win!&quot;)
            pygame.quit()
            sys.exit()
        elif i == [j for j in i if j in stats_C]:
            update(3, &quot;Computer win!&quot;)
            pygame.quit()
            sys.exit()

# 判断先手
def judge_first():
    # 0表示用户先手，1表示电脑先手
    x = random.randint(0, 1)
    if x:
        update(1, &quot;Computer&#39;s round!&quot;)
        computer_round()
    else:
        update(1, &quot;Your round!&quot;)

# 游戏入口
judge_first()
while True:
    update()
    # 获取屏幕事件
    for event in pygame.event.get():
        # 退出游戏
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        # 点击屏幕
        elif event.type == pygame.MOUSEBUTTONDOWN:
            # 获取鼠标坐标
            mouse_x, mouse_y = pygame.mouse.get_pos()
            # 鼠标点击位置是否有效
            position_valid = 0
            for i in rects:
                # 鼠标点击有效
                if not i.stats and i.rect.collidepoint(mouse_x, mouse_y):
                    position_valid = 1
                    i.stats = -1
                    update()
                    judge_result()
                    update(1, &quot;Computer&#39;s round!&quot;)
                    time.sleep(1)
                    computer_round()
                    update()
                    judge_result()
                    update(1, &quot;Your round!&quot;)
            # 鼠标点击无效
            if not position_valid:
                update(1, &quot;Your choice is invalid!&quot;)
</code></pre>
<p><strong>敲黑板！！！祝各位兄弟姐妹六一儿童节快乐！！！</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210601114826921.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>井字棋-Python语言实现</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>游戏</tag>
        <tag>井字棋</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到我的世界</title>
    <url>/Hello-MyWorld/hello-world/</url>
    <content><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo</span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting</span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub</span>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing</span></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server</span></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating</span></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment</span></p>
]]></content>
      <categories>
        <category>我的世界</category>
        <category>欢迎来到我的世界</category>
      </categories>
      <tags>
        <tag>helloWorld</tag>
      </tags>
  </entry>
  <entry>
    <title>集成运算放大器的应用</title>
    <url>/Electrotechnics/%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>(1)	掌握集成运算放大器的基本运算功能及正确使用。<br>(2)	掌握集成运算放大器常用单元电路的设计和调试方法。<br>(3)	掌握在仿真实验平台中导入和调试新元件的方法。</p>
<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><ol>
<li><pre><code>实验原理
</code></pre>
集成运算放大器是由高开环电压放大倍数的多级直接耦合放大器组成。从工作原理上，集成运算放大器可分为线性应用和非线性应用两个方面。在线性工作区内，其输出电压uo与输入电压ui的线性放大的关系为uo&#x3D;Auo（u+-u-）&#x3D;Auoui，由于集成运算放大器的放大倍数Auo高达104~107，若使uo为有限值，必须引入深度负反馈，使线性区加宽，构成集成运算放大器的线性运算电路。<br>  在工程应用情况下，将集成运放视为理想运放，就是将集成运放的各项技术指标理想化，满足下列条件的运算放大器称为理想运放，即<br>  (1)开环电压放大倍数Auo&#x3D;∞<br>  (2)输入阻抗ri&#x3D;∞<br>  (3)输出阻抗ro&#x3D;0<br>  (4)带宽fBW&#x3D;∞<br>  (5)失调与漂移均为零<br>  理想运放工作在线性区的分析依据是，输入端的虚短（u+&#x3D;u-），输入端的虚断（i+&#x3D;i-&#x3D;0）和输入端的虚地（同相端接地时，u-&#x3D;0）。<br>理想运放工作在非线性区的分析依据是：<br>u+&gt;u-, uo&#x3D;+UOM          u-&gt;u+, uo&#x3D;-UOM</li>
<li><pre><code>原理图
</code></pre>
(1)	电压跟随器，原理图如下：<br><img data-src="https://img-blog.csdnimg.cn/20210601221504560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(2)	反向比例运算电路，原理图如下：<br><img data-src="https://img-blog.csdnimg.cn/20210601221520539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<p>(3)	同向比例运算电路，原理图如下：<br><img data-src="https://img-blog.csdnimg.cn/20210601221537472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(4)	减法器的设计，原理图如下：<br><img data-src="https://img-blog.csdnimg.cn/20210601221601987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(5)	电压比较器，原理图如下：<br><img data-src="https://img-blog.csdnimg.cn/20210601221621297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(6)	矩形波发生器，原理图如下：<br><img data-src="https://img-blog.csdnimg.cn/20210601221637847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="实验过程与原始数据"><a href="#实验过程与原始数据" class="headerlink" title="实验过程与原始数据"></a>实验过程与原始数据</h2><ol>
<li><pre><code>电压跟随器
</code></pre>
(1)	实验过程：在画布中插入三个电压源和一个理想运放，将输入电压ui设置为直流1V，然后按照原理图将各元件连接起来。运行电路图并测量输出电压uo。<br>(2)	原始数据：ui&#x3D;1V<br><img data-src="https://img-blog.csdnimg.cn/20210601221710662.png" alt="在这里插入图片描述"></li>
<li><pre><code>反向比例运算电路
</code></pre>
(1)	实验过程：在画布中插入三个电压源、一个理想运放和三个电阻，将R1赋为20kΩ，R2赋为16.667kΩ，RF赋为100kΩ，然后按照原理图将各元件连接起来。不断改变输入电压ui，运行电路图并测量输出电压uo。<br>(2)	原始数据：R1&#x3D;20kΩ，R2&#x3D;16.667kΩ，RF&#x3D;100kΩ<br><img data-src="https://img-blog.csdnimg.cn/20210601221728721.png" alt="在这里插入图片描述"></li>
<li><pre><code>同向比例运算电路
</code></pre>
(1)	实验过程：在画布中插入三个电压源、一个理想运放和三个电阻，将<br>R1赋为20kΩ，R2赋为16.667kΩ，RF赋为100kΩ，然后按照原理图将各元件连接起来。不断改变输入电压ui，运行电路图并测量输出电压uo。<br>(2)	原始数据：R1&#x3D;20kΩ，R2&#x3D;16.667kΩ，RF&#x3D;100kΩ<br><img data-src="https://img-blog.csdnimg.cn/20210601221744385.png" alt="在这里插入图片描述"></li>
<li><pre><code>减法器的设计
</code></pre>
(1)	实验过程：在画布中插入四个电压源、一个理想运放和四个电阻，将R1赋为10kΩ，R2赋为10kΩ，R3赋为100kΩ，RF赋为100kΩ，然后按照原理图将各元件连接起来。不断改变输入电压ui1和ui2，运行电路图并测量输出电压uo。该减法器可实现关系式uo&#x3D;10（ui2-ui1）。<br>(2)	原始数据：R1&#x3D;10kΩ，R2&#x3D;10kΩ，R3&#x3D;100Kω,RF&#x3D;100kΩ<br><img data-src="https://img-blog.csdnimg.cn/2021060122180757.png" alt="在这里插入图片描述"></li>
<li><pre><code>电压比较器
</code></pre>
(1)	实验过程：在画布中插入三个电源、一个理想运放和两个电阻，将R1赋为10kΩ，R2赋为10kΩ，ui赋为交流1V，频率为1kHz，然后按照原理图将各元件连接起来。运行电路图，画出输出电压uo的波形和传输特性。<br>(2)	原始数据：R1&#x3D;10kΩ,R2&#x3D;10kΩ,ui&#x3D;1V，频率为1kHz<br><img data-src="https://img-blog.csdnimg.cn/20210601221824228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><pre><code>矩形波发生器
</code></pre>
(1)	实验过程：在画布中插入两个电源、一个理想运放、一个电容和四个电阻，按照原理图将各元件连接起来。不断改变R1、R2、R3、RF的阻值和C的容抗，运行电路并测量输出电压的周期、频率和幅度。<br>(2)	原始数据：<br><img data-src="https://img-blog.csdnimg.cn/20210601221842497.png" alt="在这里插入图片描述"><h2 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a>实验结果及分析</h2></li>
<li><pre><code>电压跟随器
</code></pre>
(1)	实验结果：<br><img data-src="https://img-blog.csdnimg.cn/20210601221904795.png" alt="在这里插入图片描述"><br>(2)	分析：输出电压uo等于输入电压ui，即电压跟随器不具有放大效应。</li>
<li><pre><code>反向比例运算电路
</code></pre>
(1)	实验结果：<br><img data-src="https://img-blog.csdnimg.cn/20210601221918182.png" alt="在这里插入图片描述"><br>(2)	分析：在一定范围内，输出电压和输入电压满足uo&#x3D;-5ui，即输出电压与输入电压成正比，且其相位相反。当ui超过某一定值时，uo不再增大。</li>
<li><pre><code>同向比例运算电路
</code></pre>
(1)	实验结果：<br><img data-src="https://img-blog.csdnimg.cn/20210601221938255.png" alt="在这里插入图片描述"><br>(2)	分析：在一定范围内，输出电压与输入电压满足uo&#x3D;6ui，即输出电压与输入电压成正比，且其相位相同。当ui超过一定值时，uo不再增大。</li>
<li><pre><code>减法器的设计
</code></pre>
(1)	实验结果：<br><img data-src="https://img-blog.csdnimg.cn/20210601221953204.png" alt="在这里插入图片描述"><br>(2)	分析：在一定范围内，输出电压与输入电压满足uo&#x3D;10（ui2-ui1），即输出电压与输入电压的差值成正比。当差值超过一定值时，uo不再增大。</li>
<li><pre><code>电压比较器
</code></pre>
(1)	实验结果：<br><img data-src="https://img-blog.csdnimg.cn/20210601222004269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210601222009349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><pre><code>矩形波发生器
</code></pre>
(1)	实验结果<br><img data-src="https://img-blog.csdnimg.cn/20210601222021793.png" alt="在这里插入图片描述"><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2>(1)	不能。因为输出电压的幅值受到供能直流电源电压的限制，即输出电压的最大值不超过供能直流电源的电压。<br>(2)	可将两个二极管串联在运放的正、负电源电路中，如果正接负、负接正，则二极管不导通，运放不工作，从而保护运放。电路图如下：<br><img data-src="https://img-blog.csdnimg.cn/20210601222039316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="实验体会与建议"><a href="#实验体会与建议" class="headerlink" title="实验体会与建议"></a>实验体会与建议</h2></li>
<li><pre><code>体会：在本次实验中我掌握了多种集成运算放大电路的原理和常用单元电路的设计和调试方法，且能够利用仿真实验平台分析输出电压的波形和传输特性。另外，通过这次实验，我对集成运算放大电路的理论分析更加清晰准确，进一步提高了我对电路各项参数进行理论计算的能力。
</code></pre>
</li>
<li><pre><code>本次实验难度中等偏易，且其对电路分析的能力要求不够高，可以适当提升实验难度。
</code></pre>
</li>
</ol>
<p><strong>敲黑板！！！</strong></p>
<p><strong>叠加定理与戴维南定理&#x2F;RLC串联谐振电路&#x2F;单管交流电压放大电路&#x2F;集成放大器的应用完整实验报告</strong><br><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9LaXNzTW9vbl8vMTkzMjI4OTY=">https://download.csdn.net/download/KissMoon_&#x2F;19322896</span></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210601222244974.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>电工与电子技术</category>
        <category>集成运算放大器的应用</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>电工与电子技术</tag>
      </tags>
  </entry>
  <entry>
    <title>四阶龙格-库塔方法</title>
    <url>/NumericalAnalysis/%E5%9B%9B%E9%98%B6%E9%BE%99%E6%A0%BC-%E5%BA%93%E5%A1%94%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="四阶龙格-库塔（Runge-Kutta）方法"><a href="#四阶龙格-库塔（Runge-Kutta）方法" class="headerlink" title="四阶龙格-库塔（Runge-Kutta）方法"></a>四阶龙格-库塔（Runge-Kutta）方法</h1><h2 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h2><p><img data-src="https://img-blog.csdnimg.cn/20210429224918843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="待求问题"><a href="#待求问题" class="headerlink" title="待求问题"></a>待求问题</h2><p><img data-src="https://img-blog.csdnimg.cn/20210429224949269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/2021042922500855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/2021042922502658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429225040433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h2><p><img data-src="https://img-blog.csdnimg.cn/20210429225105122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><pre><code class="c">/*Matlab函数
function Result = Runge_Kutta(a, b, alpha, N, f, has_x, has_y)
    x0 = a;
    y0 = alpha;
    h = (b-a)/N;
    X = zeros(N, 1);
    Y = zeros(N, 1);
    if(has_x == 0 &amp;&amp; has_y == 1)
        for n = 1:N
            K1 = h*subs(f, symvar(f), y0);
            K2 = h*subs(f, symvar(f), y0+1/2*K1);
            K3 = h*subs(f, symvar(f), y0+1/2*K2);
            K4 = h*subs(f, symvar(f), y0+K3);
            X(n) = x0+h;
            Y(n) = y0+(K1+2*K2+2*K3+K4)/6;
            x0 = X(n);
            y0 = Y(n);
        end
    elseif(has_x == 1 &amp;&amp; has_y == 0)
        for n = 1:N
            K1 = h*subs(f, symvar(f), x0);
            K2 = h*subs(f, symvar(f), x0+h/2);
            K3 = h*subs(f, symvar(f), x0+h/2);
            K4 = h*subs(f, symvar(f), x0+h);
            X(n) = x0+h;
            Y(n) = y0+(K1+2*K2+2*K3+K4)/6;
            x0 = X(n);
            y0 = Y(n);
        end
    elseif(has_x == 1 &amp;&amp; has_y == 1)
        for n = 1:N
            K1 = h*subs(f, symvar(f), [x0, y0]);
            K2 = h*subs(f, symvar(f), [x0+h/2, y0+1/2*K1]);
            K3 = h*subs(f, symvar(f), [x0+h/2, y0+1/2*K2]);
            K4 = h*subs(f, symvar(f), [x0+h, y0+K3]);
            X(n) = x0+h;
            Y(n) = y0+(K1+2*K2+2*K3+K4)/6;
            x0 = X(n);
            y0 = Y(n);
        end
    else
        Result = &#39;No independent variables!&#39;;
        return;
    end
    Result = [X,Y];
end*/
/*C语言程序
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

int n;
double a, b, fa;

double f(double x, double y) &#123; return -y * y; &#125;
double f_(double x) &#123; return 1.0 / (x + 1.0); &#125;

int main() &#123;
    scanf(&quot;%lf%lf%lf%d&quot;, &amp;a, &amp;b, &amp;fa, &amp;n);
    double x = a, y = fa, h = (b - a) / n;
    for (int i = 1; i &lt;= n; i++) &#123;
        double k1 = h * f(x, y);
        double k2 = h * f(x + h / 2, y + k1 / 2);
        double k3 = h * f(x + h / 2, y + k2 / 2);
        double k4 = h * f(x + h, y + k3);
        x += h;
        y += 1.0 / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4);
        printf(&quot;%.2lf\t%lf\t%.2lf\n&quot;, x, y, fabs(f_(x) - y));
    &#125;
    return 0;
&#125;*/
</code></pre>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img data-src="https://img-blog.csdnimg.cn/20210429225314667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/2021042922532258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429225329845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429225342867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429225353271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429225401789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429225410276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429225415226.png" alt="在这里插入图片描述"></p>
<h3 id="Newton-x2F-Gauss-x2F-Lagrange-x2F-Runge-Kutta实验内容-方法指导-Matlab脚本-Matlab函数-Matlab运行报告-C程序-实验报告，一键下载："><a href="#Newton-x2F-Gauss-x2F-Lagrange-x2F-Runge-Kutta实验内容-方法指导-Matlab脚本-Matlab函数-Matlab运行报告-C程序-实验报告，一键下载：" class="headerlink" title="Newton&#x2F;Gauss&#x2F;Lagrange&#x2F;Runge-Kutta实验内容+方法指导+Matlab脚本+Matlab函数+Matlab运行报告+C程序+实验报告，一键下载："></a>Newton&#x2F;Gauss&#x2F;Lagrange&#x2F;Runge-Kutta实验内容+方法指导+Matlab脚本+Matlab函数+Matlab运行报告+C程序+实验报告，一键下载：</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9LaXNzTW9vbl8vMTgyNDQ0MTk=">https://download.csdn.net/download/KissMoon_&#x2F;18244419</span></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210429225501168.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>数值分析原理</category>
        <category>四阶龙格-库塔方法</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>数值分析原理</tag>
        <tag>四阶龙格-库塔法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>拉格朗日插值</title>
    <url>/NumericalAnalysis/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/</url>
    <content><![CDATA[<h1 id="拉格朗日（Lagrange）插值"><a href="#拉格朗日（Lagrange）插值" class="headerlink" title="拉格朗日（Lagrange）插值"></a>拉格朗日（Lagrange）插值</h1><h2 id="方法概要"><a href="#方法概要" class="headerlink" title="方法概要"></a>方法概要</h2><p><img data-src="https://img-blog.csdnimg.cn/20210429223807959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="待求问题"><a href="#待求问题" class="headerlink" title="待求问题"></a>待求问题</h2><h3 id="1-拉格朗日插值多项式的次数n越大越好吗？"><a href="#1-拉格朗日插值多项式的次数n越大越好吗？" class="headerlink" title="1.拉格朗日插值多项式的次数n越大越好吗？"></a>1.拉格朗日插值多项式的次数n越大越好吗？</h3><p><img data-src="https://img-blog.csdnimg.cn/20210429224041269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-插值区间越小越好吗？"><a href="#2-插值区间越小越好吗？" class="headerlink" title="2.插值区间越小越好吗？"></a>2.插值区间越小越好吗？</h3><p><img data-src="https://img-blog.csdnimg.cn/20210429224115175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3-内插比外推更可靠吗？"><a href="#3-内插比外推更可靠吗？" class="headerlink" title="3.内插比外推更可靠吗？"></a>3.内插比外推更可靠吗？</h3><p><img data-src="https://img-blog.csdnimg.cn/20210429224235554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429224249795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h2><p><img data-src="https://img-blog.csdnimg.cn/20210429224323619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><pre><code class="c">/*Matlab函数
function Result = Lagrange(n, x_in, a, b, f)
    h = (b-a)/n;
    M = zeros(n+1, 2);
    i = 0;
    while i &lt;= n
        xi = a+i*h;
        yi = subs(f, symvar(f), xi);
        M(i+1, 1) = xi;
        M(i+1, 2) = yi;
        i = i+1;
    end
    y = 0.0;
    k = 1;
    while k &lt;= n+1
       l = 1.0;
       for j = 1:k-1
           l = l*(x_in - M(j, 1))/(M(k, 1) - M(j, 1));
       end
       for j = k+1:n+1
           l = l*(x_in - M(j, 1))/(M(k, 1) - M(j, 1));
       end
       y = y + l*M(k, 2);
       k = k+1;
    end
    Result = [x_in, y];
end*/

/*C语言程序
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

#define N1 3   // n amount
#define N2 4   // x amount
#define N3 20  // n max

int Ns[N1] = &#123;5, 10, 20&#125;;
double x[N2] = &#123;-0.95, -0.05, 0.05, 0.95&#125;;
double l = -1.0;
double r = 1.0;

double X(int k, int n) &#123;
    double h = (r - l) / n;
    return l + k * h;
&#125;

double Y(double x) &#123; return 1 / (1 + x * x); &#125;

int main() &#123;
    for (int i = 0; i &lt; N2; i++) printf(&quot;\tx=%.2lf&quot;, x[i]);
    printf(&quot;\n&quot;);
    for (int i = 0; i &lt; N1; i++) &#123;
        double a[N3 + 1], b[N3 + 1];
        int n = Ns[i];
        for (int k = 0; k &lt;= n; k++) &#123;
            a[k] = X(k, n);  // x
            b[k] = Y(a[k]);  // y
        &#125;
        printf(&quot;n=%d&quot;, n);
        for (int p = 0; p &lt; N2; p++) &#123;
            double y = 0.0;
            for (int k = 0; k &lt;= n; k++) &#123;
                double l = 1.0;
                for (int j = 0; j &lt;= n; j++) &#123;
                    if (j != k) l *= (x[p] - a[j]) / (a[k] - a[j]);
                &#125;
                y += l * b[k];
            &#125;
            printf(&quot;\t%.6lf&quot;, y);
        &#125;
        printf(&quot;\n&quot;);
    &#125;
    printf(&quot;Actual&quot;);
    for (int p = 0; p &lt; N2; p++) printf(&quot;\t%.6lf&quot;, Y(x[p]));
    return 0;
&#125;*/
</code></pre>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img data-src="https://img-blog.csdnimg.cn/20210429224528979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429224536287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429224545708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429224552838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429224600555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429224607351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429224613979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429224620853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Newton-x2F-Gauss-x2F-Lagrange-x2F-Runge-Kutta实验内容-方法指导-Matlab脚本-Matlab函数-Matlab运行报告-C程序-实验报告，一键下载："><a href="#Newton-x2F-Gauss-x2F-Lagrange-x2F-Runge-Kutta实验内容-方法指导-Matlab脚本-Matlab函数-Matlab运行报告-C程序-实验报告，一键下载：" class="headerlink" title="Newton&#x2F;Gauss&#x2F;Lagrange&#x2F;Runge-Kutta实验内容+方法指导+Matlab脚本+Matlab函数+Matlab运行报告+C程序+实验报告，一键下载："></a>Newton&#x2F;Gauss&#x2F;Lagrange&#x2F;Runge-Kutta实验内容+方法指导+Matlab脚本+Matlab函数+Matlab运行报告+C程序+实验报告，一键下载：</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9LaXNzTW9vbl8vMTgyNDQ0MTk=">https://download.csdn.net/download/KissMoon_&#x2F;18244419</span></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210429224646843.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>数值分析原理</category>
        <category>拉格朗日插值</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>数值分析原理</tag>
        <tag>算法</tag>
        <tag>拉格朗日插值法</tag>
      </tags>
  </entry>
  <entry>
    <title>Turtle库绘画实例</title>
    <url>/Python/Turtle%E5%BA%93%E7%BB%98%E7%94%BB%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="彩色螺旋线"><a href="#彩色螺旋线" class="headerlink" title="彩色螺旋线"></a>彩色螺旋线</h1><pre><code class="python">from turtle import *
speed(9)            # 画笔速度
pensize(2)			# 画笔的宽度
bgcolor(&quot;black&quot;)		# 画布背景色
colors = [&quot;red&quot;,&quot;yellow&quot;,&quot;purple&quot;,&quot;blue&quot;]	# 定义画笔线色
for x in range(400):		# 循环一次 画一条线 
    forward(2*x) 	        # 向当前方向前进n像素
    color(colors[x % 4])	# 根据求余 调整画笔线色
    left(91)                # 向左旋转91度

mainloop()
</code></pre>
<h1 id="太阳花"><a href="#太阳花" class="headerlink" title="太阳花"></a>太阳花</h1><pre><code class="python">import turtle
turtle=turtle.Turtle()
screen=turtle.getscreen()
turtle.color(&#39;red&#39;, &#39;yellow&#39;)
turtle.begin_fill()
for i in range(50):
    turtle.forward(200)
    turtle.left(170)
turtle.end_fill()
turtle.done()
</code></pre>
<h1 id="国旗"><a href="#国旗" class="headerlink" title="国旗"></a>国旗</h1><pre><code class="python">from turtle import *

screensize(2000, 2000, &#39;white&#39;)  # 设置画布大小
speed(9)
# 绘制旗面
pencolor(&#39;red&#39;)
# pu()
goto(-300, -200)
pd()
fillcolor(&#39;red&#39;)
begin_fill()
for i in range(0, 2):
    fd(600)
    lt(90)
    fd(400)
    lt(90)
end_fill()


# 绘制大五角星
pu()
pencolor(&#39;yellow&#39;)
goto(-260, 120)
pd()
fillcolor(&#39;yellow&#39;)
begin_fill()
for i in range(0, 5):
    fd(113.137)  # 大星一划的边长
    rt(144)
end_fill()

# 绘制四个小五角星
list1 = [(-100, 160), (-60, 120), (-60, 60), (-100, 20)]  # 四个五角星的中心坐标
list2 = [31.98, 8.13, -15.59, -38.66]  # 相对角度0的后退1.111需要左转的角度

for j in range(0, 4):
    seth(0)  # 这是龟头角度为0
    pu()
    goto(list1[j])  # 定位到五角星中心
    lt(list2[j])  # 旋转角度，以背向指向大五角星的角尖
    bk(20)  # 从五角星中心到指向大五角星的角尖（龟倒着爬)退一个小圆半径
    lt(18)  # 五角星的半角角度
    pd()
    begin_fill()
    for i in range(0, 5):
        fd(113.137 / 3)  # 小星一划的边长
        rt(144)
    end_fill()
pu()
ht()
done()
</code></pre>
<h1 id="玫瑰花"><a href="#玫瑰花" class="headerlink" title="玫瑰花"></a>玫瑰花</h1><pre><code class="python">import turtle
import time
turtle.speed(5)
# 设置初始位置  
turtle.penup()  
turtle.left(90)  
turtle.fd(200)  
turtle.pendown()  
turtle.right(90)
# 花蕊 
turtle.fillcolor(&quot;red&quot;)  
turtle.begin_fill()  
turtle.circle(10,180)  
turtle.circle(25,110)  
turtle.left(50)  
turtle.circle(60,45)  
turtle.circle(20,170)  
turtle.right(24)  
turtle.fd(30)  
turtle.left(10)  
turtle.circle(30,110)  
turtle.fd(20)  
turtle.left(40)  
turtle.circle(90,70)  
turtle.circle(30,150)  
turtle.right(30)  
turtle.fd(15)  
turtle.circle(80,90)  
turtle.left(15)  
turtle.fd(45)  
turtle.right(165)  
turtle.fd(20)  
turtle.left(155)  
turtle.circle(150,80)  
turtle.left(50)  
turtle.circle(150,90)  
turtle.end_fill()  

# 花瓣1  
turtle.left(150)  
turtle.circle(-90,70)  
turtle.left(20)  
turtle.circle(75,105)  
turtle.setheading(60)  
turtle.circle(80,98)  
turtle.circle(-90,40)  

# 花瓣2  
turtle.left(180)  
turtle.circle(90,40)  
turtle.circle(-80,98)  
turtle.setheading(-83)  

# 叶子1  
turtle.fd(30)  
turtle.left(90)  
turtle.fd(25)  
turtle.left(45)  
turtle.fillcolor(&quot;green&quot;)  
turtle.begin_fill()  
turtle.circle(-80,90)  
turtle.right(90)  
turtle.circle(-80,90)  
turtle.end_fill()  
turtle.right(135)  
turtle.fd(60)  
turtle.left(180)  
turtle.fd(85)  
turtle.left(90)  
turtle.fd(80)  

# 叶子2  
turtle.right(90)  
turtle.right(45)  
turtle.fillcolor(&quot;green&quot;)  
turtle.begin_fill()  
turtle.circle(80,90)  
turtle.left(90)  
turtle.circle(80,90)  
turtle.end_fill()  
turtle.left(135)  
turtle.fd(60)  
turtle.left(180)  
turtle.fd(60)  
turtle.right(90)  
turtle.circle(200,60) 
turtle.done()
</code></pre>
<h1 id="彩色树"><a href="#彩色树" class="headerlink" title="彩色树"></a>彩色树</h1><pre><code class="python"># 这个比较复杂，画的时间较长

from turtle import *
# 设置色彩模式是RGB:
colormode(255)
lt(90)
lv = 14
l = 120
s = 45
width(lv)
# 初始化RGB颜色:
r = 0
g = 0
b = 0
pencolor(r, g, b)
penup()
bk(l)
pendown()
fd(l)
def draw_tree(l, level):
    global r, g, b
    # save the current pen width
    w = width()
    # narrow the pen width
    width(w * 3.0 / 4.0)
    # set color:
    r = r + 1
    g = g + 2
    b = b + 3
    pencolor(r % 200, g % 200, b % 200)
    l = 3.0 / 4.0 * l
    lt(s)
    fd(l)
    if level &lt; lv:
        draw_tree(l, level + 1)
    bk(l)
    rt(2 * s)
    fd(l)
    if level &lt; lv:
        draw_tree(l, level + 1)
    bk(l)
    lt(s)
    # restore the previous pen width
    width(w)
speed(&quot;fastest&quot;)
draw_tree(l, 4)
done()
</code></pre>
<h1 id="随机樱花树"><a href="#随机樱花树" class="headerlink" title="随机樱花树"></a>随机樱花树</h1><pre><code class="python"># 每次运行 树的形状是随机的
import turtle as T
import random
import time

# 画樱花的躯干(60,t)
def Tree(branch, t):
    time.sleep(0.0005)
    if branch &gt; 3:
        if 8 &lt;= branch &lt;= 12:
            if random.randint(0, 2) == 0:
                t.color(&#39;snow&#39;)  # 白
            else:
                t.color(&#39;lightcoral&#39;)  # 淡珊瑚色
            t.pensize(branch / 3)
        elif branch &lt; 8:
            if random.randint(0, 1) == 0:
                t.color(&#39;snow&#39;)
            else:
                t.color(&#39;lightcoral&#39;)  # 淡珊瑚色
            t.pensize(branch / 2)
        else:
            t.color(&#39;sienna&#39;)  # 赭(zhě)色
            t.pensize(branch / 10)  # 6
        t.forward(branch)
        a = 1.5 * random.random()
        t.right(20 * a)
        b = 1.5 * random.random()
        Tree(branch - 10 * b, t)
        t.left(40 * a)
        Tree(branch - 10 * b, t)
        t.right(20 * a)
        t.up()
        t.backward(branch)
        t.down()

# 掉落的花瓣
def Petal(m, t):
    for i in range(m):
        a = 200 - 400 * random.random()
        b = 10 - 20 * random.random()
        t.up()
        t.forward(b)
        t.left(90)
        t.forward(a)
        t.down()
        t.color(&#39;lightcoral&#39;)  # 淡珊瑚色
        t.circle(1)
        t.up()
        t.backward(a)
        t.right(90)
        t.backward(b)

# 绘图区域
t = T.Turtle()
# 画布大小
w = T.Screen()
t.hideturtle()  # 隐藏画笔
t.getscreen().tracer(5, 0)
w.screensize(bg=&#39;wheat&#39;)  # wheat小麦
t.left(90)
t.up()
t.backward(150)
t.down()
t.color(&#39;sienna&#39;)

# 画樱花的躯干
Tree(60, t)
# 掉落的花瓣
Petal(200, t)
w.exitonclick()
T.done()
</code></pre>
<h1 id="表白树"><a href="#表白树" class="headerlink" title="表白树"></a>表白树</h1><pre><code class="python">import random
import turtle
def love(x, y):  # 在(x,y)处画爱心lalala
    lv = turtle.Turtle()
    lv.hideturtle()
    lv.up()
    lv.goto(x, y)  # 定位到(x,y)
 
    def curvemove():  # 画圆弧
        for i in range(20):
            lv.right(10)
            lv.forward(2)
 
    lv.color(&#39;red&#39;, &#39;pink&#39;)
    lv.speed(0)
    lv.pensize(1)
    # 开始画爱心lalala
    lv.down()
    lv.begin_fill()
    lv.left(140)
    lv.forward(22)
    curvemove()
    lv.left(120)
    curvemove()
    lv.forward(22)
    lv.write(&quot;&#123;&#125;&quot;.format(&quot;他-她&quot;), font=(&quot;Arial&quot;, 10, &quot;normal&quot;), align=&quot;center&quot;)
    lv.left(140)  # 画完复位
    lv.end_fill()
 
 
def tree(branchLen, t):
    if branchLen &gt; 5:  # 剩余树枝太少要结束递归
        if branchLen &lt; 20:  # 如果树枝剩余长度较短则变绿
            t.color(&quot;green&quot;)
            t.pensize(random.uniform((branchLen + 5) / 4 - 2, (branchLen + 6) / 4 + 5))
            t.down()
            t.forward(branchLen)
            love(t.xcor(), t.ycor())  # 传输现在turtle的坐标
            t.up()
            t.backward(branchLen)
            t.color(&quot;brown&quot;)
            return
        t.pensize(random.uniform((branchLen + 5) / 4 - 2, (branchLen + 6) / 4 + 5))
        t.down()
        t.forward(branchLen)
        # 以下递归
        ang = random.uniform(15, 45)
        t.right(ang)
        tree(branchLen - random.uniform(12, 16), t)  # 随机决定减小长度
        t.left(2 * ang)
        tree(branchLen - random.uniform(12, 16), t)  # 随机决定减小长度
        t.right(ang)
        t.up()
        t.backward(branchLen)
 
 
def Fonts():
    t.penup()
    t.goto(-500, -300)
    t.pencolor(&#39;black&#39;)
    t.write(&quot;余生的快乐希望与你一起！^_^&quot;, font=(&#39;方正行黑简体&#39;, 30, &#39;normal&#39;))
myWin = turtle.Screen()
t = turtle.Turtle()
t.hideturtle()
t.speed(0)
t.left(90)
t.up()
t.backward(200)
t.down()
t.color(&quot;brown&quot;)
t.pensize(32)
t.forward(60)
tree(100, t)
Fonts()
myWin.exitonclick()
</code></pre>
<h1 id="圆舞曲"><a href="#圆舞曲" class="headerlink" title="圆舞曲"></a>圆舞曲</h1><pre><code class="python">from turtle import *

def stop():
    global running
    running = False

def main():
    global running
    clearscreen()
    bgcolor(&quot;gray10&quot;)
    tracer(False)
    shape(&quot;triangle&quot;)
    f =   0.793402
    phi = 9.064678
    s = 5
    c = 1
    # create compound shape
    sh = Shape(&quot;compound&quot;)
    for i in range(10):
        shapesize(s)
        p =get_shapepoly()
        s *= f
        c *= f
        tilt(-phi)
        sh.addcomponent(p, (c, 0.25, 1-c), &quot;black&quot;)
    register_shape(&quot;multitri&quot;, sh)
    # create dancers
    shapesize(1)
    shape(&quot;multitri&quot;)
    pu()
    setpos(0, -200)
    dancers = []
    for i in range(180):
        fd(7)
        tilt(-4)
        lt(2)
        update()
        if i % 12 == 0:
            dancers.append(clone())
    home()
    # dance
    running = True
    onkeypress(stop)
    listen()
    cs = 1
    while running:
        ta = -4
        for dancer in dancers:
            dancer.fd(7)
            dancer.lt(2)
            dancer.tilt(ta)
            ta = -4 if ta &gt; 0 else 2
        if cs &lt; 180:
            right(4)
            shapesize(cs)
            cs *= 1.005
        update()
    return &quot;DONE!&quot;

if __name__==&#39;__main__&#39;:
    print(main())
    mainloop()
</code></pre>
<p>9、哆啦A梦</p>
<pre><code class="python">import turtle


def flyTo(x, y):
    turtle.penup()
    turtle.goto(x, y)
    turtle.pendown()
def drawEye():
    turtle.tracer(False)
    a = 2.5
    for i in range(120):
        if 0 &lt;= i &lt; 30 or 60 &lt;= i &lt; 90:
            a -= 0.05
        else:
            a += 0.05
        turtle.left(3)
        turtle.fd(a)
    turtle.tracer(True)
def beard():
    &quot;&quot;&quot; 画胡子， 一共六根
    &quot;&quot;&quot;
    # 左边第一根胡子
    flyTo(-37, 135)
    turtle.seth(165)
    turtle.fd(60)
    # 左边第二根胡子
    flyTo(-37, 125)
    turtle.seth(180)
    turtle.fd(60)
    # 左边第三根胡子
    flyTo(-37, 115)
    turtle.seth(193)
    turtle.fd(60)
    # 右边第一根胡子
    flyTo(37, 135)
    turtle.seth(15)
    turtle.fd(60)
    # 右边第二根胡子
    flyTo(37, 125)
    turtle.seth(0)
    turtle.fd(60)
    # 右边第三根胡子
    flyTo(37, 115)
    turtle.seth(-13)
    turtle.fd(60)
def drawRedScarf():
    &quot;&quot;&quot; 画围巾
    &quot;&quot;&quot;
    turtle.fillcolor(&quot;red&quot;)  # 填充颜色
    turtle.begin_fill()
    turtle.seth(0)  # 朝向右
    turtle.fd(200)  # 前进10个单位
    turtle.circle(-5, 90)
    turtle.fd(10)
    turtle.circle(-5, 90)
    turtle.fd(207)
    turtle.circle(-5, 90)
    turtle.fd(10)
    turtle.circle(-5, 90)
    turtle.end_fill()
def drawMouse():
    flyTo(5, 148)
    turtle.seth(270)
    turtle.fd(100)
    turtle.seth(0)
    turtle.circle(120, 50)
    turtle.seth(230)
    turtle.circle(-120, 100)
def drawRedNose():
    flyTo(-10, 158)
    turtle.fillcolor(&quot;red&quot;)  # 填充颜色
    turtle.begin_fill()
    turtle.circle(20)
    turtle.end_fill()
def drawBlackdrawEye():
    turtle.seth(0)
    flyTo(-20, 195)
    turtle.fillcolor(&quot;#000000&quot;)  # 填充颜色
    turtle.begin_fill()
    turtle.circle(13)
    turtle.end_fill()
    turtle.pensize(6)
    flyTo(20, 205)
    turtle.seth(75)
    turtle.circle(-10, 150)
    turtle.pensize(3)
    flyTo(-17, 200)
    turtle.seth(0)
    turtle.fillcolor(&quot;#ffffff&quot;)
    turtle.begin_fill()
    turtle.circle(5)
    turtle.end_fill()
    flyTo(0, 0)
def drawFace():
    turtle.forward(183)  # 前行183个单位
    turtle.fillcolor(&quot;white&quot;)  # 填充颜色为白色
    turtle.begin_fill()  # 开始填充
    turtle.left(45)  # 左转45度
    turtle.circle(120, 100)  # 右边那半边脸
    turtle.seth(90)  # 朝向向上
    drawEye()  # 画右眼睛
    turtle.seth(180)  # 朝向左
    turtle.penup()  # 抬笔
    turtle.fd(60)  # 前行60
    turtle.pendown()  # 落笔
    turtle.seth(90)  # 朝向上
    drawEye()  # 画左眼睛
    turtle.penup()  # 抬笔
    turtle.seth(180)  # 朝向左
    turtle.fd(64)  # 前进64
    turtle.pendown()  # 落笔
    turtle.seth(215)  # 修改朝向
    turtle.circle(120, 100)  # 左边那半边脸
    turtle.end_fill()  #
def drawHead():
    &quot;&quot;&quot; 画了一个被切掉下半部分的圆
    &quot;&quot;&quot;
    turtle.penup()  # 抬笔
    turtle.circle(150, 40)  # 画圆, 半径150，圆周角40
    turtle.pendown()  # 落笔
    turtle.fillcolor(&quot;#00a0de&quot;)  # 填充色
    turtle.begin_fill()  # 开始填充
    turtle.circle(150, 280)  # 画圆，半径150, 圆周角280
    turtle.end_fill()
def drawAll():
    drawHead()
    drawRedScarf()
    drawFace()
    drawRedNose()
    drawMouse()
    beard()
    flyTo(0, 0)
    turtle.seth(0)
    turtle.penup()
    turtle.circle(150, 50)
    turtle.pendown()
    turtle.seth(30)
    turtle.fd(40)
    turtle.seth(70)
    turtle.circle(-30, 270)
    turtle.fillcolor(&quot;#00a0de&quot;)
    turtle.begin_fill()
    turtle.seth(230)
    turtle.fd(80)
    turtle.seth(90)
    turtle.circle(1000, 1)
    turtle.seth(-89)
    turtle.circle(-1000, 10)
    turtle.seth(180)
    turtle.fd(70)
    turtle.seth(90)
    turtle.circle(30, 180)
    turtle.seth(180)
    turtle.fd(70)
    turtle.seth(100)
    turtle.circle(-1000, 9)
    turtle.seth(-86)
    turtle.circle(1000, 2)
    turtle.seth(230)
    turtle.fd(40)
    turtle.circle(-30, 230)
    turtle.seth(45)
    turtle.fd(81)
    turtle.seth(0)
    turtle.fd(203)
    turtle.circle(5, 90)
    turtle.fd(10)
    turtle.circle(5, 90)
    turtle.fd(7)
    turtle.seth(40)
    turtle.circle(150, 10)
    turtle.seth(30)
    turtle.fd(40)
    turtle.end_fill()
    # 左手
    turtle.seth(70)
    turtle.fillcolor(&quot;#FFFFFF&quot;)
    turtle.begin_fill()
    turtle.circle(-30)
    turtle.end_fill()
    # 脚
    flyTo(103.74, -182.59)
    turtle.seth(0)
    turtle.fillcolor(&quot;#FFFFFF&quot;)
    turtle.begin_fill()
    turtle.fd(15)
    turtle.circle(-15, 180)
    turtle.fd(90)
    turtle.circle(-15, 180)
    turtle.fd(10)
    turtle.end_fill()
    flyTo(-96.26, -182.59)
    turtle.seth(180)
    turtle.fillcolor(&quot;#FFFFFF&quot;)
    turtle.begin_fill()
    turtle.fd(15)
    turtle.circle(15, 180)
    turtle.fd(90)
    turtle.circle(15, 180)
    turtle.fd(10)
    turtle.end_fill()
    # 右手
    flyTo(-133.97, -91.81)
    turtle.seth(50)
    turtle.fillcolor(&quot;#FFFFFF&quot;)
    turtle.begin_fill()
    turtle.circle(30)
    turtle.end_fill()
    # 口袋
    flyTo(-103.42, 15.09)
    turtle.seth(0)
    turtle.fd(38)
    turtle.seth(230)
    turtle.begin_fill()
    turtle.circle(90, 260)
    turtle.end_fill()
    flyTo(5, -40)
    turtle.seth(0)
    turtle.fd(70)
    turtle.seth(-90)
    turtle.circle(-70, 180)
    turtle.seth(0)
    turtle.fd(70)
    # 铃铛
    flyTo(-103.42, 15.09)
    turtle.fd(90)
    turtle.seth(70)
    turtle.fillcolor(&quot;#ffd200&quot;)
    turtle.begin_fill()
    turtle.circle(-20)
    turtle.end_fill()
    turtle.seth(170)
    turtle.fillcolor(&quot;#ffd200&quot;)
    turtle.begin_fill()
    turtle.circle(-2, 180)
    turtle.seth(10)
    turtle.circle(-100, 22)
    turtle.circle(-2, 180)
    turtle.seth(180 - 10)
    turtle.circle(100, 22)
    turtle.end_fill()
    flyTo(-13.42, 15.09)
    turtle.seth(250)
    turtle.circle(20, 110)
    turtle.seth(90)
    turtle.fd(15)
    turtle.dot(10)
    flyTo(0, -150)
    drawBlackdrawEye()
def main():
    turtle.screensize(800, 6000, &quot;#F0F0F0&quot;)
    turtle.pensize(3)
    turtle.speed(9)
    drawAll()
if __name__ == &quot;__main__&quot;:
    main()
    turtle.mainloop()
</code></pre>
<h1 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h1><pre><code class="python">import turtle
from datetime import *

# 抬起画笔，向前运动一段距离放下
def Skip(step):
    turtle.penup()
    turtle.forward(step)
    turtle.pendown()


def mkHand(name, length):
    # 注册Turtle形状，建立表针Turtle
    turtle.reset()
    Skip(-length * 0.1)
    # 开始记录多边形的顶点。当前的乌龟位置是多边形的第一个顶点。
    turtle.begin_poly()
    turtle.forward(length * 1.1)
    # 停止记录多边形的顶点。当前的乌龟位置是多边形的最后一个顶点。将与第一个顶点相连。
    turtle.end_poly()
    # 返回最后记录的多边形。
    handForm = turtle.get_poly()
    turtle.register_shape(name, handForm)


def Init():
    global secHand, minHand, hurHand, printer
    # 重置Turtle指向北
    turtle.mode(&quot;logo&quot;)
    # 建立三个表针Turtle并初始化
    mkHand(&quot;secHand&quot;, 135)
    mkHand(&quot;minHand&quot;, 125)
    mkHand(&quot;hurHand&quot;, 90)
    secHand = turtle.Turtle()
    secHand.shape(&quot;secHand&quot;)
    minHand = turtle.Turtle()
    minHand.shape(&quot;minHand&quot;)
    hurHand = turtle.Turtle()
    hurHand.shape(&quot;hurHand&quot;)

    for hand in secHand, minHand, hurHand:
        hand.shapesize(1, 1, 3)
        hand.speed(0)

    # 建立输出文字Turtle
    printer = turtle.Turtle()
    # 隐藏画笔的turtle形状
    printer.hideturtle()
    printer.penup()


def SetupClock(radius):
    # 建立表的外框
    turtle.reset()
    turtle.pensize(7)
    for i in range(60):
        Skip(radius)
        if i % 5 == 0:
            turtle.forward(20)
            Skip(-radius - 20)

            Skip(radius + 20)
            if i == 0:
                turtle.write(int(12), align=&quot;center&quot;, font=(&quot;Courier&quot;, 14, &quot;bold&quot;))
            elif i == 30:
                Skip(25)
                turtle.write(int(i / 5), align=&quot;center&quot;, font=(&quot;Courier&quot;, 14, &quot;bold&quot;))
                Skip(-25)
            elif (i == 25 or i == 35):
                Skip(20)
                turtle.write(int(i / 5), align=&quot;center&quot;, font=(&quot;Courier&quot;, 14, &quot;bold&quot;))
                Skip(-20)
            else:
                turtle.write(int(i / 5), align=&quot;center&quot;, font=(&quot;Courier&quot;, 14, &quot;bold&quot;))
            Skip(-radius - 20)
        else:
            turtle.dot(5)
            Skip(-radius)
        turtle.right(6)


def Week(t):
    week = [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期日&quot;]
    return week[t.weekday()]


def Date(t):
    y = t.year
    m = t.month
    d = t.day
    return &quot;%s-%d-%d&quot; % (y, m, d)


def Tick():
    # 绘制表针的动态显示
    t = datetime.today()
    second = t.second + t.microsecond * 0.000001
    minute = t.minute + second / 60.0
    hour = t.hour + minute / 60.0
    secHand.setheading(6 * second)
    minHand.setheading(6 * minute)
    hurHand.setheading(30 * hour)

    turtle.tracer(False)
    printer.forward(65)
    printer.write(Week(t), align=&quot;center&quot;, font=(&quot;Courier&quot;, 14, &quot;bold&quot;))
    printer.back(130)
    printer.write(Date(t), align=&quot;center&quot;, font=(&quot;Courier&quot;, 14, &quot;bold&quot;))
    printer.home()
    turtle.tracer(True)

    # 100ms后继续调用tick
    turtle.ontimer(Tick, 100)


def main():
    # 打开/关闭龟动画，并为更新图纸设置延迟。
    turtle.tracer(False)
    Init()
    SetupClock(160)
    turtle.tracer(True)
    Tick()
    turtle.done()


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<p><strong>还愣着干嘛，赶紧拿去骗小姐姐啊？</strong><br><img data-src="https://img-blog.csdnimg.cn/2705eefe731d49288993bb5d66974ef7.jpg#pic_center" alt="在这里插入图片描述"></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210326221456228.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Python语言</category>
        <category>Turtle库绘画实例</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>高斯列主元消去法</title>
    <url>/NumericalAnalysis/%E9%AB%98%E6%96%AF%E5%88%97%E4%B8%BB%E5%85%83%E6%B6%88%E5%8E%BB%E6%B3%95/</url>
    <content><![CDATA[<h1 id="高斯（Gauss）列主元消去法"><a href="#高斯（Gauss）列主元消去法" class="headerlink" title="高斯（Gauss）列主元消去法"></a>高斯（Gauss）列主元消去法</h1><h2 id="方法概要"><a href="#方法概要" class="headerlink" title="方法概要"></a>方法概要</h2><p><img data-src="https://img-blog.csdnimg.cn/20210429221918286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="待求问题"><a href="#待求问题" class="headerlink" title="待求问题"></a>待求问题</h2><p><img data-src="https://img-blog.csdnimg.cn/20210429222104408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210429222133787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210429222149344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h2><p><img data-src="https://img-blog.csdnimg.cn/20210429222227470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><pre><code class="c">/*Matlab函数
function Result = Gauss(n, A, b)
    for k = 1:n-1
        max = abs(A(k, k));
        p = k;
        for j = k+1:n
            if(abs(A(j, k)) &gt; max)
                max = abs(A(j, k));
                p = j;
            end
        end
        if(A(p, k) == 0)
            Result = &#39;Singular matrix!&#39;;
            return;
        end
        if(p ~= k)
           A([k p], :) = A([p k], :);
           b([k p], :) = b([p k], :);
        end
        for i = k+1:n
            Mik = A(i, k)/A(k, k);
            for j = k:n
                A(i, j) = A(i, j) - A(k, j)*Mik;
            end
            b(i) = b(i) - b(k)*Mik;
        end
    end
    if(A(n, n) == 0)
        Result = &#39;Singular matrix!&#39;;
        return;
    end
    Result = zeros(n, 1);
    Result(n, 1) = b(n)/A(n, n);
    for k = n-1:-1:1
        Sum = 0;
        for j = k+1:n
            Sum = Sum + A(k, j)*Result(j, 1);
        end
        Result(k, 1) = (b(k) - Sum)/A(k, k);
    end
end*/

/*C语言程序
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

#define N 10

int n;
double a[N][N], b[N], x[N];

int main() &#123;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n; j++) scanf(&quot;%lf&quot;, &amp;a[i][j]);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;b[i]);
    for (int k = 1; k &lt; n; k++) &#123;
        int p = k;
        double maxabs = fabs(a[k][k]);
        for (int j = k + 1; j &lt;= n; j++)
            if (fabs(a[j][k]) - maxabs &gt; 0) &#123;
                p = j;
                maxabs = fabs(a[j][k]);
            &#125;
        if (a[p][k] == 0) &#123;
            printf(&quot;Singular&quot;);
            return 0;
        &#125;
        if (p != k) &#123;
            double tmp;
            for (int j = 1; j &lt;= n; j++) &#123;
                tmp = a[p][j];
                a[p][j] = a[k][j];
                a[k][j] = tmp;
            &#125;
            tmp = b[p];
            b[p] = b[k];
            b[k] = tmp;
        &#125;
        for (int i = k + 1; i &lt;= n; i++) &#123;
            double m_ik = a[i][k] / a[k][k];
            for (int j = k + 1; j &lt;= n; j++) a[i][j] -= a[k][j] * m_ik;
            b[i] -= b[k] * m_ik;
        &#125;
    &#125;
    if (a[n][n] == 0) &#123;
        printf(&quot;Singular&quot;);
        return 0;
    &#125;
    x[n] = b[n] / a[n][n];
    for (int k = n - 1; k &gt;= 1; k--) &#123;
        double sigma = 0.0;
        for (int j = k + 1; j &lt;= n; j++) sigma += a[k][j] * x[j];
        x[k] = (b[k] - sigma) / a[k][k];
    &#125;
    for (int i = 1; i &lt;= n; i++) printf(&quot;%lf\t&quot;, x[i]);
    return 0;
&#125;*/
</code></pre>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img data-src="https://img-blog.csdnimg.cn/20210429222542617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210429222613165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Newton-x2F-Gauss-x2F-Lagrange-x2F-Runge-Kutta实验内容-方法指导-Matlab脚本-Matlab函数-Matlab运行报告-C程序-实验报告，一键下载："><a href="#Newton-x2F-Gauss-x2F-Lagrange-x2F-Runge-Kutta实验内容-方法指导-Matlab脚本-Matlab函数-Matlab运行报告-C程序-实验报告，一键下载：" class="headerlink" title="Newton&#x2F;Gauss&#x2F;Lagrange&#x2F;Runge-Kutta实验内容+方法指导+Matlab脚本+Matlab函数+Matlab运行报告+C程序+实验报告，一键下载："></a>Newton&#x2F;Gauss&#x2F;Lagrange&#x2F;Runge-Kutta实验内容+方法指导+Matlab脚本+Matlab函数+Matlab运行报告+C程序+实验报告，一键下载：</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9LaXNzTW9vbl8vMTgyNDQ0MTk=">https://download.csdn.net/download/KissMoon_&#x2F;18244419</span></p>
<p><img data-src="https://img-blog.csdnimg.cn/2021042922265415.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>数值分析原理</category>
        <category>高斯列主元消去法</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>数值分析原理</tag>
        <tag>算法</tag>
        <tag>高斯消去法</tag>
      </tags>
  </entry>
  <entry>
    <title>牛顿迭代法</title>
    <url>/NumericalAnalysis/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/</url>
    <content><![CDATA[<h1 id="牛顿（Newton）迭代法"><a href="#牛顿（Newton）迭代法" class="headerlink" title="牛顿（Newton）迭代法"></a>牛顿（Newton）迭代法</h1><h2 id="方法概要"><a href="#方法概要" class="headerlink" title="方法概要"></a>方法概要</h2><p><img data-src="https://img-blog.csdnimg.cn/20210429214552553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="待求问题"><a href="#待求问题" class="headerlink" title="待求问题"></a>待求问题</h2><p><img data-src="https://img-blog.csdnimg.cn/2021042921463173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h2><p><img data-src="https://img-blog.csdnimg.cn/20210429214859187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><pre><code class="c">/*Matlab函数
function Result = Newton(x0, e1, e2, N, f)
    n = 1;
    while n &lt;= N
        F = subs(f, symvar(f), x0);
        DF = subs(diff(f), symvar(f), x0);
        if(abs(F) &lt; e1)
            Result = double(x0);
            return;
        end
        if(abs(DF) &lt; e2)
            Result = &#39;Iteration failed!&#39;;
            return;
        end
        x1 = x0-F/DF;
        Tol = abs(x1 - x0);
        if(Tol &lt; e1)
            Result = double(x1);
            return;
        end
        n = n+1;
        x0 = x1;
    end
    Result = &#39;Iteration failed!&#39;;
end*/


/*C语言程序
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

double x, e1, e2;
int n;

double f(double x) &#123; return cos(x) - x; &#125;
double df(double x) &#123; return -sin(x) - 1; &#125;

int main() &#123;
    scanf(&quot;%lf%lf%lf%d&quot;, &amp;x, &amp;e1, &amp;e2, &amp;n);
    for (int i = 1; i &lt;= n; i++) &#123;
        double F = f(x), DF = df(x);
        if (fabs(F) &lt; e1) &#123;
            printf(&quot;%lf&quot;, x);
            return 0;
        &#125;
        if (fabs(DF) &lt; e2) &#123;
            printf(&quot;Failed&quot;);
            return 0;
        &#125;
        double x1 = x - F / DF;
        double tol = fabs(x - x1);
        if (tol &lt; e1) &#123;
            printf(&quot;%lf&quot;, x1);
            return 0;
        &#125;
        x = x1;
    &#125;
    printf(&quot;Failed&quot;);
    return 0;
&#125;
*/
</code></pre>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img data-src="https://img-blog.csdnimg.cn/20210429215743424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/2021042921575322.png" alt="在这里插入图片描述"></p>
<h3 id="Newton-x2F-Gauss-x2F-Lagrange-x2F-Runge-Kutta实验内容-方法指导-Matlab脚本-Matlab函数-Matlab运行报告-C程序-实验报告，一键下载："><a href="#Newton-x2F-Gauss-x2F-Lagrange-x2F-Runge-Kutta实验内容-方法指导-Matlab脚本-Matlab函数-Matlab运行报告-C程序-实验报告，一键下载：" class="headerlink" title="Newton&#x2F;Gauss&#x2F;Lagrange&#x2F;Runge-Kutta实验内容+方法指导+Matlab脚本+Matlab函数+Matlab运行报告+C程序+实验报告，一键下载："></a>Newton&#x2F;Gauss&#x2F;Lagrange&#x2F;Runge-Kutta实验内容+方法指导+Matlab脚本+Matlab函数+Matlab运行报告+C程序+实验报告，一键下载：</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9LaXNzTW9vbl8vMTgyNDQ0MTk=">https://download.csdn.net/download/KissMoon_&#x2F;18244419</span></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210429220649480.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>数值分析原理</category>
        <category>牛顿迭代法</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>数值分析原理</tag>
        <tag>算法</tag>
        <tag>牛顿迭代法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机八股文之操作系统</title>
    <url>/StereotypedWriting/OperatingSystem/</url>
    <content><![CDATA[<h1 id="简要概述一下什么是操作系统？"><a href="#简要概述一下什么是操作系统？" class="headerlink" title="简要概述一下什么是操作系统？"></a>简要概述一下什么是操作系统？</h1><ul>
<li>操作系统是<strong>管理计算机硬件和软件资源</strong>的计算机程序，提供一个计算机用户与计算机硬件系统之间的接口（向上对用户程序提供接口，向下接管硬件资源）。</li>
<li>操作系统本质上也是一个软件，作为最接近硬件的<strong>系统软件，负责处理器管理、存储器管理、设备驱动管理、文件系统管理和提供用户接口。</strong></li>
</ul>
<h1 id="操作系统的分类有哪些？"><a href="#操作系统的分类有哪些？" class="headerlink" title="操作系统的分类有哪些？"></a>操作系统的分类有哪些？</h1><ul>
<li>操作系统一般可分为<strong>批处理操作系统、分时操作系统和实时操作系统。</strong></li>
<li>若一个操作系统兼顾批处理和分时的功能，则称该系统为<strong>通用操作系统</strong>，常见的通用操作系统有：Windows、Linux、MacOS等。</li>
</ul>
<h1 id="什么是内核态和用户态？"><a href="#什么是内核态和用户态？" class="headerlink" title="什么是内核态和用户态？"></a>什么是内核态和用户态？</h1><ul>
<li>为了<strong>避免操作系统和关键数据被用户程序破坏</strong>，将处理器的执行状态分为内核态和用户态。</li>
<li>内核态是操作系统管理程序执行时所处的状态，<strong>能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。</strong></li>
<li>用户态是用户程序执行时处理器所处的状态，<strong>不能执行特权指令，只能访问用户地址空间。</strong></li>
<li>用户程序运行在用户态，操作系统内核运行在内核态。</li>
</ul>
<h1 id="如何实现内核态和用户态的切换？"><a href="#如何实现内核态和用户态的切换？" class="headerlink" title="如何实现内核态和用户态的切换？"></a>如何实现内核态和用户态的切换？</h1><p>处理器从用户态切换到内核态的方法有三种：<strong>系统调用、异常、外部中断。</strong></p>
<ul>
<li>系统调用，操作系统的最小功能单位，是操作系统提供的<strong>用户接口，是软中断。</strong></li>
<li>异常，也叫做<strong>内中断，是由错误引起的</strong>，如文件损坏、缺页故障等。</li>
<li>外部中断，通过两根信号线来通知处理器<strong>外设的状态变化，是硬中断。</strong></li>
</ul>
<h1 id="软中断和硬中断的区别与联系？"><a href="#软中断和硬中断的区别与联系？" class="headerlink" title="软中断和硬中断的区别与联系？"></a>软中断和硬中断的区别与联系？</h1><ul>
<li>硬中断是有<strong>外设硬件</strong>发出的，<strong>需要有中断控制器</strong>的参与。其过程是外设侦测到变化，告知中断控制器，中断控制器通过CPU或内存的中断脚通CPU，然后<strong>硬件</strong>进行程序计数器及堆栈寄存器的现场保存工作（引发上下文切换），并根据中断向量调用<strong>硬中断处理程序</strong>进行中断处理。</li>
<li>软中断则通常是由<strong>硬中断处理程序或者进程调度程序等软件程序</strong>发出的中断信号，<strong>无需中断控制器</strong>的参与，直接以一个CPU指令之形式指示<strong>CPU</strong>进行程序计数器及堆栈寄存器之现场保存工作(亦会引发上下文切换)，并调用相应的<strong>软中断处理程序</strong>进行中断处理(即我们通常所言之系统调用)。</li>
<li>硬中断直接以硬件的方式引发，处理速度快。软中断以软件指令的方式引发，适合于对响应速度要求不是特别严格的场景。</li>
<li>硬中断通过设置 CPU 的屏蔽位可进行屏蔽，软中断则由于是指令之方式给出，不能屏蔽（<strong>硬中断可以被屏蔽，软中断不可以被屏蔽</strong>）。</li>
<li>硬中断和软中断**均会引起上下文切换(进程&#x2F;线程之切换)**，进程切换的过程是差不多的。</li>
</ul>
<h1 id="并发和并行的区别？"><a href="#并发和并行的区别？" class="headerlink" title="并发和并行的区别？"></a>并发和并行的区别？</h1><ul>
<li>并发：宏观上看多个程序在同时运行，比如在单核CPU上的多任务，但微观上看程序的指令是<strong>交替运行</strong>的，<strong>CPU在任何时刻最多只能同时运行一条指令</strong>。</li>
<li>并行：严格意义上的同时运行，比如多核CPU，程序的指令是<strong>同时运行</strong>的，<strong>CPU在任何时刻最多能够同时运行多条指令</strong>。</li>
<li>并发<strong>不能</strong>提高计算机的性能，而并行<strong>能够</strong>提高计算机的性能。</li>
</ul>
<h1 id="什么是进程、线程、协程？"><a href="#什么是进程、线程、协程？" class="headerlink" title="什么是进程、线程、协程？"></a>什么是进程、线程、协程？</h1><ul>
<li>进程：进程是<strong>系统进行资源分配和管理的基本单位</strong>。每个进程都有自己<strong>独立的内存空间</strong>，不同进程之间可以进行通信。由于进程比较重量，占据独立的内存，所以进程上下文的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对来说比较安全。</li>
<li>线程：线程是进程的一个实体，是<strong>CPU调度和分派的基本单位</strong>，它是比进程更小的能够独立运行的单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（栈、寄存器、程序计数器），但是它可<strong>与同属一个进程的其他线程共享进程所拥有的全部资源</strong>。线程间的通信主要通过共享内存，上下文的切换开销比较少，但相比进程不够稳定，容易丢失数据。</li>
<li>协程：协程是<strong>一种用户态的轻量级线程</strong>，协程的<strong>调度完全由用户控制</strong>。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方。在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则<strong>基本没有内核切换的开销，可以不加锁地访问全局变量</strong>，所以上下文的切换非常快。</li>
</ul>
<h1 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a>进程和线程的区别？</h1><ul>
<li><strong>一个程序至少有一个进程，一个进程至少有一个线程。</strong></li>
<li><strong>从系统调度上看：进程是资源分配和管理的基本单位，线程是CPU调度和分派的基本单位。</strong></li>
<li><strong>从上下文切换上看：线程上下文的切换要比进程上下文的切换快得多。</strong></li>
<li><strong>从系统开销上看：创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间、I&#x2F;O设备等，而创建或撤销线程时，系统只需要为之分配或回收少量资源，如栈、寄存器等，所以进程切换的开销要远大于线程切换的开销。</strong></li>
</ul>
<h1 id="协程和线程的区别？"><a href="#协程和线程的区别？" class="headerlink" title="协程和线程的区别？"></a>协程和线程的区别？</h1><ul>
<li>一个线程可以有多个协程，一个进程也可以有多个协程。线程和进程都是同步机制，而协程是异步机制。</li>
<li>协程是由程序自身控制的，没有线程切换的开销，执行效率非常高。</li>
<li>协程不需要多线程的锁机制：在协程中控制共享资源不需要加锁，只需要判断状态即可，所以执行效率比多线程高很多。</li>
<li>线程是抢占式的，而协程是非抢占式的，需要用户释放使用权切换到其他协程，因此同一时间只有一个协程拥有运行权，相当于单线程。</li>
<li>协程不被操作系统内核管理，而完全由程序控制。线程是被分割的CPU资源，协程是组织好的代码流程，线程是协程的资源。但协程不会直接使用线程，协程直接利用的是执行器来关联任意线程或线程池。</li>
</ul>
<h1 id="进程的基本操作有哪些？"><a href="#进程的基本操作有哪些？" class="headerlink" title="进程的基本操作有哪些？"></a>进程的基本操作有哪些？</h1><ul>
<li>fork()创建子进程：<strong>fork()函数调用一次，返回两次，在父进程中返回子进程的PID，而在子进程中返回0</strong>，可以利用这个特点来判断一个进程是父进程还是子进程。<br>（1）新创建子进程几乎但不完全与父进程相同：子进程得到与父进程用户级<strong>虚拟地址空间相同（但是独立的）一份副本</strong>，包括代码和数据段、堆、共享库以及用户栈；子进程还获得与父进程所有<strong>打开文件的描述符相同的一份副本</strong>，这意味着子进程可以读写父进程中任何打开的文件。<br>（2）父进程与子进程最大的区别在于它们的进程ID（PID）不同。</li>
<li>exec()执行新程序：<strong>exec()函数可以替换当前进程的代码，执行一个新的程序，而不是继续执行当前程序</strong>。exec()函数可以接受一个参数，这个参数是一个字符串，表示要执行的新程序的路径，如果参数是一个相对路径，那么它会被解析为当前进程的工作目录下的路径。</li>
<li>wait()等待子进程结束：<strong>wait()函数可以等待子进程结束，并返回子进程的返回值。</strong></li>
<li>waitpid()等待子进程结束：<strong>waitpid()函数可以等待指定的子进程结束，并返回子进程的返回值。</strong></li>
<li>exit()退出当前进程：<strong>exit()函数可以退出当前进程，并返回一个整数。</strong></li>
</ul>
]]></content>
      <categories>
        <category>计算机八股文</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>踩坑之严格缩进</title>
    <url>/Python/%E8%B8%A9%E5%9D%91%E4%B9%8B%E4%B8%A5%E6%A0%BC%E7%BC%A9%E8%BF%9B/</url>
    <content><![CDATA[<p>本篇文章适合python初学者食用。<br>相信很多刚开始入手python的新人，都跟我一样，习惯了C&#x2F;C++采用分号来结束语句和花括号来标明代码块的方式，导致在<del>用python写个简简单单的“hello world”都能Error半天</del> 。（哈哈，又是无中生有系列！）所以，我只能痛定思痛，写下这惨痛的经历并总结经验。<br>在python中，代码块是通过<strong>冒号+缩进</strong>来实现的，语句末尾的冒号表示创建一个子代码块，有C&#x2F;C++花括号那味了。同一级别的代码必须有相同的缩进，也就是所有同一级别的代码都必须左对齐，<strong>多一个空格少一个空格都不行！！！</strong>（不得不说python就是一头倔驴！）所以对于习惯了C&#x2F;C++的python新手来说，下次程序报错时，不妨先看一下是不是<strong>缩进</strong>的问题，当然更多时候是忘记写<strong>冒号</strong>了（<del><em>我是不会告诉你我就是那个经常忘记写冒号的憨憨的！</em></del> ）。<br>无图无真相，下面我们来CC编程实操：</p>
<pre><code class="python">&gt;&gt;&gt; x = &quot;错误演示&quot;
&gt;&gt;&gt;   print(x) #print前留有空格
SyntaxError: unexpected indent #存在不必要空格

&gt;&gt;&gt; for i in range(5) #句尾忘记打上冒号
SyntaxError: invalid syntax #提示非法语法

&gt;&gt;&gt; for i in range(5): #子代码块的缩进错误
print(x)
SyntaxError: expected an indented block #提示句首缺少空格

&gt;&gt;&gt; x = &quot;正确演示&quot;
&gt;&gt;&gt; for i in range(5):
        print(x)
正确演示
正确演示
正确演示
正确演示
正确演示

&gt;&gt;&gt; x, y = &quot;第二级&quot;,&quot;第三级&quot;
&gt;&gt;&gt; for i in range(3):
        print(x)
        for j in range(2): #与print(x)同级，缩进相同
            print(y)
            print(&quot;同是第三级&quot;) #与print(y)同级，缩进相同
        print(&quot;同是第二级&quot;) #与print(x)同级，缩进相同
第二级
第三级
同是第三级
第三级
同是第三级
同是第二级
第二级
第三级
同是第三级
第三级
同是第三级
同是第二级
第二级
第三级
同是第三级
第三级
同是第三级
同是第二级

&gt;&gt;&gt; for i in range(3):
        print(x)
        for j in range(2):
            print(y)
              print(&quot;同是第三级&quot;) #与第三级错位
          print(&quot;同是第二级&quot;) #与第二级错位
        
SyntaxError: unexpected indent #存在不必要空格
</code></pre>
<p>是不是感觉python没有C&#x2F;C++那么人性化呢？但相反这确是python的一大优点。其他语言没有强制缩进，导致一些程序员不追求代码的美观，一通乱写，当你看到这些代码时，你就会发现你的眼睛废了（<strong>这次真的是我的一个朋友了！！！</strong> 我说了他几次了，还是不听，因为他们老师没强制要求缩进，他个人也不注重美化，他拿他的代码来问我题，我都宁愿自己重新打一遍。）无图无真相，就问你难不难受？<br><img data-src="https://img-blog.csdnimg.cn/20210323135609894.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210323141229122.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>所以，python 的这种强制性缩进，既能让代码简化（少打了许多花括号和分号），又能让代码美观（zzqq，专治各种强迫症。）虽然刚开始会比较难适应，但慢慢习惯了你就会发现世界如此美妙。<br>这么说python缩进没有缺点？那也不是，相信很多同仁都喜欢<strong>ctrl+c和ctrl+v</strong>吧，有时你就会发现你别人能运行的代码你不能运行，这就是在复制粘贴缩进错乱的结果。</p>
<p><strong>既然讲到了ctrl+c和crtl+v，那就顺便讲讲为啥会在复制粘贴的过程中出现缩进错乱。</strong></p>
<p>假设你的小伙伴给了你一段代码，他又喜欢使坏，故意将“Tap”键和空格键混用。<strong>假设他的电脑设定了“Tab &#x3D; 4个空格”，而你的电脑设定了“Tap &#x3D; 8个空格”，</strong>（*<del>又找到了一个防止抄袭的方法，只不过只能玩一次，一次之后人还在不在我就不知道了</del>* ）这时，你就会发现这份代码无法运行。</p>
<p><strong>这就是前面提到的缩进错乱引起的严重结果。</strong></p>
<p>测验如下：（<strong>CSDN博客代码片段中的Tap &#x3D; 4个空格，而我使用的python IDLE中的Tap &#x3D; 8个空格，代码从CSDN复制到IDLE</strong>）</p>
<pre><code class="python">&gt;&gt;&gt; for i in range(2):
    print(&quot;1&quot;) #使用Tap
    for i in range(2):
        print(&quot;2&quot;) #使用Tap	
1
2
2
1
2
2
#程序在IDLE中可以正常运行
&gt;&gt;&gt; for i in range(2):
    print(&quot;1&quot;) #使用4个空格
    for i in range(2):
        print(&quot;2&quot;) #使用4个空格
1
2
2
1
2
2
#程序在IDLE中可以正常运行
&gt;&gt;&gt; for i in range(2):
    print(&quot;1&quot;) #使用Tap
    for i in range(2):
        print(&quot;2&quot;) #使用4个空格
        
SyntaxError: unindent does not match any outer indentation level
#程序在IDLE中报错
</code></pre>
<p><img data-src="https://img-blog.csdnimg.cn/20210324163649932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210324163636663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210324163700198.png#pic_center" alt="在这里插入图片描述"></p>
<p>既然存在这个问题，那我们就要解决这个问题。</p>
<p><strong>方式1：手动将Tap换成空格或将空格换成Tap。</strong>（<del>你行你上啊！！！</del> ）<br><img data-src="https://img-blog.csdnimg.cn/20210324164230465.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>方式2：利用函数expandtabs()预处理代码，将代码中的Tap设定为指定空格数。</strong><br><strong>使用方法：先将代码存放为字符串code，可以选择程序输入、文件导入、手动添加三引号号等方式。然后new_code &#x3D; code.expandtabs(空格数)，这时new_code中所有的Tap都会被换成指定数量的空格，实现了大一统。（<del><em>简直就是秦始皇再世</em></del> ）</strong></p>
<pre><code class="python">&gt;&gt;&gt; code = &quot;&quot;&quot;for i in range(2):
    print(&quot;1&quot;) #使用Tap
    for i in range(2):
        print(&quot;2&quot;) #使用4个空格&quot;&quot;&quot;
&gt;&gt;&gt; new_code = code.expandtabs(4) #注意空格数要保持一致，否则就是做无用功
&gt;&gt;&gt; print(new_code)
for i in range(2):
    print(&quot;1&quot;) #Tap变成4个空格
    for i in range(2):
        print(&quot;2&quot;) #使用4个空格
&gt;&gt;&gt; for i in range(2): #处理过的代码，可以正常运行
    print(&quot;1&quot;) #Tap变成4个空格
    for i in range(2):
        print(&quot;2&quot;) #使用4个空格  
1
2
2
1
2
2
</code></pre>
<p><strong>方式3：修改所用软件中Tap的值。具体方式自行参考不同软件的使用手册。</strong></p>
<p><strong>当然，还是得从根本上解决这个问题，参考方式如下：</strong><br><img data-src="https://img-blog.csdnimg.cn/20210324165147434.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>敲黑板！！！python是采用冒号+缩进来标示代码块，谨防忘记缩进，避免不必要的缩进，并且同级代码的缩进必须相同，不能多也不能少。谨记Tab和空格不要混用，否则性命难保！</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210323141141460.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Python语言</category>
        <category>踩坑之严格缩进</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>踩坑之转义字符与反斜杠</title>
    <url>/Python/%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%8F%8D%E6%96%9C%E6%9D%A0/</url>
    <content><![CDATA[<p>本文章适用于python新手。<br>转义字符，俗称<strong>反斜杠”\“+啥啥啥</strong>，在许多的编程语言中都被广泛使用。转义，也就是伪装，让你<strong>眼见不为实</strong>。在编程中，转义字符用于实现特定的功能，以下给出常见的转义字符和所对应的意义：<br><img data-src="https://img-blog.csdnimg.cn/2021032321372944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>就这？</strong>（可能有的小伙伴愤怒了，*<del>我电脑都打开了就给我看这?</del>* <strong>此处引用一句非常经典的话，懂的都懂！</strong>）<br><img data-src="https://img-blog.csdnimg.cn/20210323224107583.gif#pic_center" alt="在这里插入图片描述"></p>
<p>还早着呢，学会使用这些转义字符只是编程的基本功而已，更要引起小伙伴们重视的是，如何避免因为转义而带来不必要的麻烦。<br>我们都知道，计算机就是一根筋的思维，只能按照设定的模式进行编译代码，这就很容易对我们产生误会。<br>无图无真相，先上代码：</p>
<pre><code class="python">&gt;&gt;&gt; print(&quot;\ten\nine\three\two\one\now&quot;)
    en
ine	hree	wo\one
ow
</code></pre>
<p>显然，程序并没有为我们打印出我们想要的”\ten\nine\three\two\one\now”，而是<strong>打印出一些奇奇怪怪的东西</strong>（举例中没有，但是在写程序时经常有。）这是因为程序在见到反斜杠的时候，就习惯地将反斜杠与其后的字符连用，<del>这就好比在大街上看到帅哥美女你都会忍不住多看两眼，相互理解是吧</del> ！</p>
<p><strong>怎么办呢？</strong></p>
<p>方案1：<br>既然计算机默认转义，那就<strong>再转一次</strong>呗（<del>转义转义字符</del> ，啪，禁止套娃！！！）</p>
<pre><code class="python">&gt;&gt;&gt; print(&quot;D:\\three\\two\\one\\now&quot;)
D:\three\two\one\now
</code></pre>
<p>这个方法非常常用。但是，如果需要写到几百上千个\t..\n..\f..\v....呢。额，我想砸键盘了。<br><img data-src="https://img-blog.csdnimg.cn/20210323223929799.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>方案2：<br><strong>在字符串第一个单&#x2F;双引号前加一个小写字母”r”来告诉计算机该字符串是原始字符串，不需要转义等特殊处理。</strong></p>
<pre><code class="python">&gt;&gt;&gt; print(r&quot;D:\three\two\one\now&quot;)
D:\three\two\one\now
</code></pre>
<p>此外，反斜杠除了与某些字符构成转义字符外，还可以<strong>与回车键连用表示跨行</strong>，通俗地讲就是”<del>这事没完！！！</del> “。（奇怪的知识增加了！！！）</p>
<pre><code class="python">&gt;&gt;&gt; print(&quot;I love python!  \n\
I love C++!     \n\
I love coding!  \n&quot;)

I love python!  
I love C++!     
I love coding! 
</code></pre>
<p><strong>实际上这也是转义的一种</strong>，当你没有使用反斜杠直接点击Enter键时，计算机就会认为语句结束了，这时计算机就不乐意了，<strong>不带这么玩的！！！</strong></p>
<pre><code class="python">&gt;&gt;&gt; print(&quot;I love python!  \n
      
SyntaxError: EOL while scanning string literal
</code></pre>
<p>既然讲到跨行，那就不得不说一下长字符串的输入方式了。常用的是通过<strong>三个单引号或三个双引号</strong>来告诉计算机这个字符串很长，有面条辣么长（<del>说到这我都饿了，该吃夜宵了</del> ），需要跨行。</p>
<pre><code class="python">&gt;&gt;&gt; print(&#39;&#39;&#39;I love python!
I love C++!
I love coding!&#39;&#39;&#39;)

I love python!
I love C++!
I love coding!

&gt;&gt;&gt; print(&quot;&quot;&quot;I love python!
I love C++!
I love coding!&quot;&quot;&quot;)

I love python!
I love C++!
I love coding!
</code></pre>
<p>要注意的是，不能三个单引号和三个双引号不能混用，要始终如一，因为它们的眼里都只有自己的另一半（<del>纯真的爱情值得我们取追求</del> ），否则，它们就会跟你没完！！！（<strong>亲测</strong>）</p>
<p><strong>敲黑板！转义字符是编程语言中用于实现特定功能的字符组合，由反斜杠“\”+啥啥啥组成，在编程中，要避免因为转义而导致程序错误，在需要打印含有反斜杠的字符串时，可以采用转义字符再转义或将其声明为原始字符串的方式来解决这个问题。最后，反斜杠可以与Enter键连用来表示跨行，只不过我们常用三引号的方式来实现该功能。</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210323224435220.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Python语言</category>
        <category>踩坑之转义字符与反斜杠</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>荣耀20220412</title>
    <url>/WrittenExamination/Honor_20220412/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔试一共三道编程题，分数依次为100、200、300，需要按顺序依次完成，只有做完这一道题，才能进入下一道题，无法跳题，使用的是牛客网，允许跳出界面使用自己的IDE。</p>
<h1 id="题目一：字符串分割"><a href="#题目一：字符串分割" class="headerlink" title="题目一：字符串分割"></a>题目一：字符串分割</h1><p>给定一系列的字符串，字符串的个数为N，每个字符串的长度不超过100。长度小于8的字符串用零补足，长度大于等于8的字符串，按8位位一组的形式不断分割，最后剩余部分用零补足。</p>
<p>输入：</p>
<p>第一行包括一个整数N和N个原始字符串。</p>
<p>输出：</p>
<p>第一行包括分割后的字符串按字典序从小到大排列。</p>
<p>输入示例：</p>
<p>2 abc 123456789</p>
<p>输出示例：</p>
<p>12345678 90000000 abc00000</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这一题比较简单，只需要按照题目的描述做即可。</p>
<pre><code class="python">inp = input().split()
n = int(inp[0])
ls = []
for i in range(1, n+1):
    string = inp[i]
    while len(string) &gt; 8:
        ls.append(string[:8])
        string = string[8:]
    ls.append(string + &quot;0&quot;*(8-len(string)))
ls.sort()
print(&quot; &quot;.join(ls))
</code></pre>
<h1 id="题目二：蜜蜂采蜜"><a href="#题目二：蜜蜂采蜜" class="headerlink" title="题目二：蜜蜂采蜜"></a>题目二：蜜蜂采蜜</h1><p>平原上，一群蜜蜂离开蜂巢采蜜，要连续采集5片花丛后归巢。<br>已知5片花丛相对蜂巢的坐标，请你帮它们规划一下到访花丛的顺序，以使飞行总距离最短。</p>
<p>输入：</p>
<p>以蜂巢为平面坐标原点的5片花丛A、B、C、D、E的坐标，坐标值为整数。</p>
<p>输出：</p>
<p>从出发到返回蜂巢最短路径的长度取整值，取整办法为舍弃小数点后面的值。</p>
<p>输入示例：</p>
<p>200 0 200 10 200 50 200 30 200 25</p>
<p>输出示例：</p>
<p>456</p>
<p>说明：</p>
<p>样例中的10个数，相邻两个分别为一组，表示一个花丛相对蜂巢的坐标：A(x1, y1)、B(x2, y2)、C(x3, y3)、D(x4, y4)、E(x5, y5)，分表代表x1,y1,x2,y2,x3,y3,x4,y4,x5,y5。</p>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>本题实际上是一道旅行商问题（TSP），经典的TSP可以描述为：一个商品推销员要去若干个城市推销商品，该推销员从一个城市出发，需要经过所有城市后，回到出发地。应如何选择行进路线，以使总的行程最短。从图论的角度来看，该问题实质是在一个带权完全无向图中，找一个权值最小的Hamilton回路。由于该问题的可行解是所有顶点的全排列，随着顶点数的增加，会产生组合爆炸，它是一个NP完全问题。</p>
<p>常见的解法有暴力破解、深度优先遍历，动态规划等。</p>
<p>高级的解法有模拟退火算法，遗传算法，粒子群算法、神经网络等</p>
<h2 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h2><p>暴力破解，求出五片花丛所有可能的到访顺序（全排列），取飞行总距离最短的路径即可。</p>
<pre><code class="python">from math import sqrt, floor
from xmlrpc.client import MAXINT
inp = list(map(int, input().split()))
mincost = MAXINT
ls = [(inp[i*2], inp[i*2+1]) for i in range(5)]
matrix = [[0 for i in range(5)] for j in range(5)]
for i in range(5):
    for j in range(5):
        matrix[i][j] = sqrt((ls[i][0]-ls[j][0])**2 + (ls[i][1]-ls[j][1])**2)

def Perm(nums, begin, end):
    global mincost, ls, matrix, path
    if begin &gt;= end:
        cost = 0
        for i in range(4):
            cost += matrix[nums[i]][nums[i+1]]
        cost = cost + sqrt((ls[nums[0]][0]**2) + (ls[nums[0]][1]**2)) + sqrt((ls[nums[-1]][0]**2) + (ls[nums[-1]][1]**2))
        if cost &lt; mincost:
            path = nums
            mincost = cost
        return
    else:
        for num in range(begin, end):
            nums[begin], nums[num] = nums[num], nums[begin]
            Perm(nums, begin+1, end)
            nums[begin], nums[num] = nums[num], nums[begin]

nums = [i for i in range(5)]
Perm(nums, 0, len(nums))
print(floor(mincost))
</code></pre>
<h2 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h2><p>采用深度优先遍历来寻找最短路径，并在遍历过程中通过不断剪枝来简化求解过程，广义上来讲也是全排列的一种。</p>
<pre><code class="python">from math import sqrt, floor
from xmlrpc.client import MAXINT

def DFS(u, cnt, cost):
    global mincost, matrix, visited
    if cost &gt; mincost:
        return
    if cnt == 6:
        cost = cost + sqrt((ls[u][0]**2) + (ls[u][1]**2)) + sqrt((ls[0][0]**2) + (ls[0][1]**2))
        if cost &lt; mincost:
            mincost = cost
    visited[u] = 1
    for v in range(6):
        if not visited[v]:
            DFS(v, cnt+1, cost + matrix[u][v])
    visited[u] = 0

inp = list(map(int, input().split()))
mincost = MAXINT
visited = [0 for i in range(6)]
ls = [(inp[i*2], inp[i*2+1]) for i in range(5)]
ls.insert(0, (0, 0))
matrix = [[0 for i in range(6)] for j in range(6)]
for i in range(6):
    for j in range(6):
        matrix[i][j] = sqrt((ls[i][0]-ls[j][0])**2 + (ls[i][1]-ls[j][1])**2)

DFS(0, 1, 0)
print(floor(mincost))
</code></pre>
<h1 id="惨痛经历"><a href="#惨痛经历" class="headerlink" title="惨痛经历"></a>惨痛经历</h1><p>因为邮件上写着系统开放时间为18:00-21:00（不同于美团写着笔试时间为16:00-18:00），所以我习惯性得以为笔试时间为三个小时，当我悠哉游哉地把第二题做完返回系统时，笔试已经结束了，因此只提交了第一题，直接人麻了。。。所以，各位小伙伴无论是在比赛还是在测试，一定先看好时间！！！当然，对于秒AK的大佬来说，时间根本不是事，那就当我没说。</p>
<p><img data-src="/WrittenExamination/Honor_20220412/Honor_20220412/Wolf.jpg" alt="Wolf"></p>
]]></content>
      <categories>
        <category>企业笔试</category>
        <category>荣耀笔试题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>牛客网</tag>
        <tag>荣耀</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>美团20220409</title>
    <url>/WrittenExamination/MeiTuan_20220409/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔试一共五道编程题（四+一），一为专项编程题，估计不同岗位有题目不一样，使用的是赛码网，允许跳出界面使用自己的IDE。</p>
<p>在此感谢<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlYm9ydHQ/dHlwZT1ibG9n">筱羊冰冰</span>提供的部分题目及题解。</p>
<h1 id="题目一：数圈游戏"><a href="#题目一：数圈游戏" class="headerlink" title="题目一：数圈游戏"></a>题目一：数圈游戏</h1><p>给定一个整数n，计算该整数含有的圆圈个数。数字0-9对应的圈数如下：<br>0: 1<br>1: 0<br>2: 0<br>3: 0<br>4: 0<br>5: 0<br>6: 1<br>7: 0<br>8: 2<br>9: 1</p>
<p>输入：<br>第一行为一个整数n，表示数圈游戏的数字。</p>
<p>输入示例：<br>60498<br>输出示例：<br>5</p>
<p>限制：<br>80%的测试用例：n&lt;&#x3D;10000<br>100%的测试用例：n&lt;&#x3D;100000000</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>该题较为简单，一次遍历累加即可。</p>
<h1 id="题目二：士兵排队"><a href="#题目二：士兵排队" class="headerlink" title="题目二：士兵排队"></a>题目二：士兵排队</h1><p>给定一定数量的士兵，将士兵按照身高从小到大排列，身高相同者按照姓名的字典序从小到大排列。</p>
<p>输入：<br>第一行为一个整数n，表示士兵的数量。<br>第二行为n个士兵的身高，单位为cm。<br>第三行为n个士兵的姓名。</p>
<p>输入示例：<br>4<br>176 170 176 176<br>bamma tom alpha beta</p>
<p>输出示例：<br>tom alpha bamma beta</p>
<p>限制：<br>士兵身高 hi &lt;&#x3D; 300<br>士兵姓名长度 ni &lt;&#x3D; 20</p>
<h2 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h2><p>将每一个人的身高和名字按照 (身高，名字) 的格式存储，然后进行两次排序，先按照身高排序，再按照名字排序即可。（利用了python排序算法的稳定性！）</p>
<pre><code class="python">n = int(input())
heights = list(map(str, input().split()))
names = list(map(str, input().split()))
ls = []
for i in range(n):
    ls.append((heights[i], names[i]))
# lambda函数指定排序规则
ls.sort(key=lambda x:x[1])
ls.sort(key=lambda x:x[0])
for i in range(n):
    print(ls[i][1], end=&#39; &#39;)
</code></pre>
<h2 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h2><p>因为身高的限制为 hi &lt;&#x3D; 300，所以身高最高只能为三位数，那么我们可以把所有身高都通过补前置零的方式化为三位数，然后再与名字拼接成一个字符串，这样只需要一次排序就能够得出结果。</p>
<pre><code class="python">n = int(input())
heights = list(map(str, input().split()))
names = list(map(str, input().split()))
for i in range(n):
    # str.zfill()自动填充
    heights[i] = heights[i].zfill(3) + names[i]
heights.sort()
for i in range(n):
    print(heights[i][3:], end=&#39; &#39;)
</code></pre>
<h1 id="题目三：路径搜索"><a href="#题目三：路径搜索" class="headerlink" title="题目三：路径搜索"></a>题目三：路径搜索</h1><p>给定一个地图，询问是否存在一条从起点到终点的直接通路。注意，通路是双向的。</p>
<p>输入：<br>第一行包括两个整数n和m，分别表示地图上点的数量和通路的数量。<br>第二行包括m个整数，表示地图上通路的一端。<br>第三行包括m个整数，表示地图上通路的另一端。<br>第四行包括k个整数，表示询问的次数。<br>接下来的k行每行包括两个整数，分别表示起点和终点。</p>
<p>输入示例：<br>4 5<br>1 2 1 3 1<br>2 3 3 4 4<br>4<br>1 3<br>2 4<br>2 1<br>3 2</p>
<p>输出示例：<br>Yes<br>No<br>Yes<br>Yes</p>
<h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>筱羊冰冰：上来就看错了，然后花了好久写了类似并查集的东西，然后用不上……<br>（果然大佬就是不一样，上来直接手撕并查集）<br>这道题只需要检查有无指定通路就行了，不过要特别注意查询范围，因为通路是双向的而且要求的是直接通路。</p>
<pre><code class="python">n, m = map(int, input().split())
lsu = list(map(int, input().split()))
lsv = list(map(int, input().split()))
k = int(input())
ways = set((lsu[i], lsv[i]) for i in range(m))
out = []
for _ in range(k):
    u, v = map(int, input().split())
    if (u, v) in ways or (v, u) in ways:
        out.append(&#39;Yes&#39;)
    else:
        out.append(&#39;No&#39;)
print(&#39;\n&#39;.join(out))
</code></pre>
<h1 id="题目四：井字棋"><a href="#题目四：井字棋" class="headerlink" title="题目四：井字棋"></a>题目四：井字棋</h1><p>给定一个2x2的棋盘和n中不同的颜色，要求每行每列均不能出现相同的颜色，计算总共有多少种填充方案。</p>
<p>输入：<br>第一行包括一个整数n，表示颜色的数量。</p>
<p>输出：<br>输出一个整数，表示有多少种填充方案。</p>
<p>输入示例：<br>2</p>
<p>输出示例：<br>2</p>
<p>限制：<br>颜色的种类n &lt;&#x3D; 10</p>
<h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><p>筱羊冰冰：有一说一，感觉就属这个题有意思吧。我当时看完，感觉就有一点像排列组合(业余玩家，不太清楚具体的类型)。<br>n种颜色，如果颜色足够(指大于四种)，我们其实也只能取出四种来操作，所以只需要一个<br>$$<br>C_n^4<br>$$<br>所以我们其实只需要考虑四种以内的情况。</p>
<p>两种颜色：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>和</th>
<th>2</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>1</td>
<td></td>
<td>1</td>
<td>2</td>
</tr>
</tbody></table>
<p>三种颜色：<br>我们自然可以想到，拿两种颜色就可以填上面的两种<br>$$<br>C_3^2 * 2<br>$$<br>然后，如果是三种颜色都要，有12种，肯定是有一个重复的，那么对角线重复就有两种情况，剩下的其实就是将三个数字填入三个位置，<br>$$<br>A_3^3<br>$$<br>就是6 + 6*2 &#x3D; 18。</p>
<p>到这里其实就应该明白了，我们只需要知道 i 种颜色有多少种即可，因为 i &#x3D; 2, 3, 4，我们完全可以直接写出来，剩下的就是一个组合问题，再给出一个阶乘列表。</p>
<pre><code class="python"># ls[i]为i种颜色都使用，对应的可能数
# 四种颜色忘了说了，不过就是个A44
ls = [0, 0, 2, 12, 24]
# ls_jc[i] = i!
ls_jc = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]
ret = 0
n = int(input())
if n &lt;= 1:
    # 他在系统公告中，提示了0的问题
    ret = 0
elif n &lt;= 4:
    for i in range(2, n+1):
        ret += ls[i] * ls_jc[n] // (ls_jc[i] * ls_jc[n-i])
        # 还有一个限制就是输出大小，这里原题目是有的
        ret %= 1000000007
else:
    for i in range(2, 5):
        ret += ls[i] * ls_jc[n] // (ls_jc[i] * ls_jc[n-i])
        ret %= 1000000007
print(ret)
</code></pre>
<h2 id="小插曲："><a href="#小插曲：" class="headerlink" title="小插曲："></a>小插曲：</h2><p>当时有一块写错了，然后跑出来只有27%，自己就去看了一下范围是小于等于十，那么案例至少有10个吧。<br>然后自己因为有边界检测，负数、0、1、2都能正确，那么至少对三个，反推出案例应该是11个，那么就是3往上有问题，所以将矛头对准了ls[3]，果然是算少了，改成12，啪的一下，很快就过了……</p>
<h1 id="题目五：堆积木"><a href="#题目五：堆积木" class="headerlink" title="题目五：堆积木"></a>题目五：堆积木</h1><p>给定一个已有的字符串和一个目标字符串，可以从右边删除一个字符，也可以往左边插入一个字符，删除和插入操作的次数没有限制，问最少操作多少次可以使已有字符串变成目标字符串。</p>
<table>
<thead>
<tr>
<th>输入</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>原串长度</td>
</tr>
<tr>
<td>1 5 3 4 6</td>
<td>原串</td>
</tr>
<tr>
<td>5</td>
<td>目标串长度</td>
</tr>
<tr>
<td>2 1 5 3 4</td>
<td>目标串</td>
</tr>
</tbody></table>
<h2 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h2><p>筱羊冰冰：这个题，其实看明白了就没那么难，其实就是找最长公共子序列。</p>
<pre><code class="python">from collections import deque
l_old = int(input())
old = input().split()
l_new = int(input())
new = input().split()
length = 0
# 这里没啥原因，就是deque的头插尾插都比较快，O(1)的
s1, s2 = deque(), deque()
judge = 0
while True:
    s1.append(old[length])
    s2.appendleft(new[-length-1])
    length += 1
    if s1 == s2:
        judge = 1
        break
    elif length == min(l_old, l_new):
        break
if judge:
    print(l_old+l_new - length*2)
else:
    print(l_old+l_new)
</code></pre>
<h2 id="重大失误"><a href="#重大失误" class="headerlink" title="重大失误"></a>重大失误</h2><p>上面的代码其实没考虑，如果有多对子串相同，要找出最长的……<br>不过感觉测试案例比较拉，所以显示还是ac了的。</p>
<p><img data-src="/WrittenExamination/MeiTuan_20220409/MeiTuan_20220409/Wolf.jpg" alt="Wolf"></p>
]]></content>
      <categories>
        <category>企业笔试</category>
        <category>美团笔试题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>笔试</tag>
        <tag>赛码网</tag>
        <tag>美团</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯20220424</title>
    <url>/WrittenExamination/Tencent_20220424/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔试一共五道编程题，满分是100分，时间是两个小时，可以跳题，使用的平台是牛客网，允许跳出界面使用本地IDE。</p>
<h1 id="题目一：构建数字"><a href="#题目一：构建数字" class="headerlink" title="题目一：构建数字"></a>题目一：构建数字</h1><p>给定n个长度均为m的数字字符串，从上往下构建成m个新的数，去掉前置0后按照从小到大的顺序输出。</p>
<p>输入：</p>
<p>第一行包括一个整数n。</p>
<p>接下来n行每行包括一个长度为m的数字字符串。</p>
<p>输出：</p>
<p>第一行包括新构建的数按从小到大排列。</p>
<p>输入示例：</p>
<p>3</p>
<p>0121</p>
<p>1502</p>
<p>2138</p>
<p>输出示例：</p>
<p>12 128 151 203</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>该题比较简单，可以直接暴力求解，需要注意的是前置0的处理。</p>
<pre><code class="python">n = int(input())
nums = []
for i in range(n):
    num = input()
    nums.append(num)

ans = []
for i in range(len(nums[0])):
    a = &quot;&quot;
    for j in range(n):
        a += nums[j][i]
    # int()函数会直接去掉前置0
    ans.append(int(a))

ans.sort()
for i in range(len(ans)):
    print(ans[i], end=&quot; &quot;)
</code></pre>
<h1 id="题目二：淘汰数字"><a href="#题目二：淘汰数字" class="headerlink" title="题目二：淘汰数字"></a>题目二：淘汰数字</h1><p>给定一个数组，下标从1~n，每次淘汰下标为非质数的数字，剩下的数形成新的数组，重复上述过程，直到数组内只剩下一个数字。</p>
<p><strong>本题为核心代码模式，只需要补充解法类的实现代码即可。</strong></p>
<p>输入：</p>
<p>第一行包括一个长度为n的数组。</p>
<p>输出：</p>
<p>第一行包括一个整数。</p>
<p>输入示例1：</p>
<p>[1, 2, 3, 4]</p>
<p>输出示例1：</p>
<p>3</p>
<p>输入示例2：</p>
<p>[3, 1 , 1 , 4 , 5, 6]</p>
<p>输出示例2：</p>
<p>5</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本题也是直接暴力求解，重点是求出n内的所有质数。</p>
<pre><code class="python">from math import sqrt, ceil
class Solution:
    def isP(self, x):
        m = ceil(sqrt(x))+1
        for j in range(2, m):
            if x%j == 0:
                return False
        return True

    def getNumber(self , a):
        # write code here
        n = len(a)
        pnums = [2]
        for i in range(3, n):
            if self.isP(i):
                pnums.append(i)
        while n != 1:
            k = 0
            for i in range(len(pnums)):
                if pnums[i] &gt; n:
                    break
                a[k] = a[pnums[i]-1]
                k += 1
            n = k
        return a[0]
    
a = [1,2,3,4] # [3,1,1,4,5,6]
print(Solution().getNumber(a))
</code></pre>
<h1 id="题目三：士兵分配"><a href="#题目三：士兵分配" class="headerlink" title="题目三：士兵分配"></a>题目三：士兵分配</h1><p>给定一定数量的士兵，编号为1<del>n，用长度为n的0&#x2F;1串s表示，其中0代表该士兵只会进攻，1代表该士兵只会防御，且其攻击力或防御力等于其编号。将士兵分组，编号为1</del>pos的士兵为进攻组，该组的攻击力之和用w表示，编号为pos+1~n的士兵为防御组，该组的防御力之和用v表示，求|w-v|的最小值。注意：pos可以取0，当pos取0时，表示将所有士兵分到防御组，而进攻组没有士兵。</p>
<p>输入：</p>
<p>第一行包括一个整数n，表示士兵的数量。</p>
<p>第二行包括一个0&#x2F;1字符串s，表示士兵的状态。</p>
<p>输出：</p>
<p>第一行包括一个整数，表示|w-v|的最小值。</p>
<p>输入示例1：</p>
<p>4</p>
<p>0011</p>
<p>输出示例1：</p>
<p>1</p>
<p>输入示例2：</p>
<p>7</p>
<p>1000101</p>
<p>输出示例2：</p>
<p>2</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>思路一：暴力求解。遍历整个字符串，在每一个位置对其进行分割，得到左右两个子串，然后分别统计左右两边的攻击力或防御力，与此同时不断刷新差值绝对值的最小值。这种方法的算法复杂度较高，无法AC。</p>
<p>思路二：逐个分配。可以先假设所有的士兵都在右边，左边没有士兵，即pos为0的情况，此时w和v均可知。然后遍历整个字符串，将士兵逐个从右边分配到左边，如果分配的士兵为0，那么w加上该士兵的编号，v不变；如果分配的士兵为1，那么v减去该士兵的编号，w不变，与此同时不断刷新差值绝对值的最小值即可。</p>
<p>以下为思路二的代码：</p>
<pre><code class="python">n = int(input())
s = input()
# 因为编号为1~n，且pos的取值范围为0~n
# 所以添加两个占位符可以简化问题的求解过程
s = &quot;-&quot; + s + &quot;-&quot;
w = 0
v = 0
for i in range(n+2):
    if s[i] == &quot;1&quot;:
        v += i
res = v
for i in range(n+2):
    if s[i] == &quot;0&quot;:
        w += i
    if s[i] == &quot;1&quot;:
        v -= i
    res = min(res, abs(w-v))
print(res)
</code></pre>
<h1 id="题目四：合并链表"><a href="#题目四：合并链表" class="headerlink" title="题目四：合并链表"></a>题目四：合并链表</h1><p>给出一个链表数组，该链表数组均是某一个环状链表的一部分，请将这些链表组合并成环状链表，然后需要找到一个位置，使得从这个位置将环切开后，按照顺序或逆序遍历这个环，形成的链字典序尽量小，并返回这条链。</p>
<ul>
<li><p>链表字典序的定义：对于两个链表a、b，从头节点到尾节点遍历，找到第一个不相同的节点值并比较大小，如果a[i].val &lt; b[i].val，则认为a的字典序小于b的字典序。例如：链表{1,2,3} &lt; 链表{1,2,4},     链表{3,4,5} &lt; 链表{6,7}。</p>
</li>
<li><p>环状链表不存在相同的节点值。  </p>
</li>
<li><p>该题环状链表节点个数最小为2  </p>
</li>
<li><p>每个链表都是在环状链表上的顺时针的一部分。  </p>
</li>
<li><p>给定的链表数组一定能组成一个环状链表。</p>
</li>
</ul>
<p>输入示例1：</p>
<p>[{1, 2, 3}, {2, 3, 4}, {4, 1}]</p>
<p>输出示例1：</p>
<p>{1, 2, 3, 4}</p>
<p>输入示例2：</p>
<p>[{3, 7, 4}, {7, 4, 5, 1, 10, 3}]</p>
<p>输出示例2：</p>
<p>{1, 5, 4, 7, 3, 10}</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>用字典存每个下标的前驱和后继，即可还原环状链表。接下来考虑切口位置，可将其转化为确定头节点和遍历方向的问题。要使字典序最小，那么头节点必须是链表里面的最小值（确定头节点），而下一节点为头节点的前驱节点和后继节点中较小的一个（确定遍历方向）。</p>
<p>本题的解法并不难，难的是如何处理输入，将其合并成一个环状链表。系统中采用的核心代码模式，只需补充解法类的实现代码即可，这里给出的是完整代码。</p>
<pre><code class="python">from re import compile
from xmlrpc.client import MAXINT
inp = input()
lss = compile(&#39;\d+&#39;).findall(inp)
ring = dict()
head = MAXINT
for i in range(len(lss)-1):
    ring[int(lss[i])] = int(lss[i+1])
    head = min(head, int(lss[i]))

rering = &#123;v : k for k, v in ring.items()&#125;
pre = rering[head]
nex = ring[head]
res = &#39;&#123;&#39; + str(head) + &#39;,&#39;
if pre &lt; nex:
    for i in range(len(rering)-1):
        res += str(rering[head]) + &#39;,&#39;
        head = rering[head]
if pre &gt; nex:
    for i in range(len(ring)-1):
        res += str(ring[head]) + &#39;,&#39;
        head = ring[head]
print(res[:-1] + &#39;&#125;&#39;)
</code></pre>
<h1 id="题目五：买卖股票"><a href="#题目五：买卖股票" class="headerlink" title="题目五：买卖股票"></a>题目五：买卖股票</h1><p>现在有一个长度为n的价格数组a，表示某只股票每天的价格。每天最多可以买入或卖出该只股票的一股，买入或者卖出没有手续费，且卖出股票前必须手里已经有股票才能卖出，但是持有的股票数目不受限制，并且初始资金为m元，在任何时刻都不能进行透支，即资金必须始终大于等于0。请问在n天结束之后，拥有的最大总资产是多少？其中总资产 &#x3D; 股票数目 * 股票价格 + 现金。</p>
<p>输入：</p>
<p>第一行包括两个整数n和m，分别表示天数和初始资金。</p>
<p>第二行包括n个整数，分别表示该只股票每天的价格。</p>
<p>输入示例：</p>
<p>6 2</p>
<p>2 3 1 1 1 2</p>
<p>输出示例：</p>
<p>6</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>动态规划，01背包的变种。定义dp[i][j]代表前i天，手上当前持有j只股票的最大现金数，那么可以根据每天选择买入还是卖出达成转移。</p>
<pre><code class="python">n, m = map(int, input().split())
prices = list(map(int, input().split()))
prices.insert(0, -1e16)
dp = [[-1e16 for i in range(n+2)] for j in range(n+2)]
dp[0][0] = m
for i in range(1, n+1):
    for j in range(n+1):
        # 今天不买不卖的情况
        nodo = dp[i-1][j]
        # 今天买入一股的情况
        buy = -1e16
        if j &gt; 0 and dp[i-1][j-1] &gt;= prices[i]:
            buy = dp[i-1][j-1]-prices[i]
        # 昨天卖出一股的情况
        sell = dp[i-1][j+1]+prices[i]
        # 取资金数目最大的一种
        dp[i][j] = max(nodo, buy, sell)


res = -1e16
for i in range(n+1):
    res = max(res, dp[n][i] + i*prices[n])

print(res)
</code></pre>
<p><img data-src="/WrittenExamination/Tencent_20220424/Tencent_20220424/Wolf.jpg" alt="Wolf"></p>
]]></content>
      <categories>
        <category>企业笔试</category>
        <category>腾讯笔试题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>牛客网</tag>
        <tag>笔试</tag>
        <tag>腾讯</tag>
      </tags>
  </entry>
  <entry>
    <title>53-II</title>
    <url>/LeetCode/%E5%89%91%E6%8C%87Offer/53-II/</url>
    <content><![CDATA[<h2 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h2><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<h2 id="题解示例"><a href="#题解示例" class="headerlink" title="题解示例"></a>题解示例</h2><p>示例 1:</p>
<p>输入: [0,1,3]<br>输出: 2<br>示例 2:</p>
<p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>1 &lt;&#x3D; 数组长度 &lt;&#x3D; 10000</p>
<h2 id="标记难度"><a href="#标记难度" class="headerlink" title="标记难度"></a>标记难度</h2><p>通过次数：126,612<br>提交次数：284,562<br>通过率：44.5%</p>
<h2 id="问题简析"><a href="#问题简析" class="headerlink" title="问题简析"></a>问题简析</h2><p>对该数组进行<strong>二分查找</strong>即可。<br>若计算得到的中值与数组中值相等，则缺失的数字在右区间中；<br>若计算得到的中值与数组中值不相等，则缺失的数字在左区间中；</p>
<p>最简单的方法便是遍历数组，如此则未能将<strong>数组有序</strong>的条件合理利用，其时间复杂度也相对较大。</p>
<h2 id="python3代码"><a href="#python3代码" class="headerlink" title="python3代码"></a>python3代码</h2><pre><code class="python">class Solution:
    def missingNumber(self, nums: List[int]) -&gt; int:
        i, j = 0, len(nums)-1     
        while i &lt;= j:
            mid = (i+j) // 2
            if nums[mid] == mid:
                i = mid+1
            else:
                j = mid-1
        return i
</code></pre>
<h2 id="C语言代码"><a href="#C语言代码" class="headerlink" title="C语言代码"></a>C语言代码</h2><pre><code class="c">int missingNumber(int* nums, int numsSize)&#123;
    int left = 0, right = numsSize-1, mid;
    while (left &lt;= right) 
    &#123;
        mid = left + (right - left) / 2;
        if (nums[mid] != mid) 
        &#123;
            right = mid - 1;
        &#125; 
        else
        &#123;
            left = mid + 1;
        &#125;
    &#125;
    return left;
&#125;
</code></pre>
<h2 id="C-代码（Copy）"><a href="#C-代码（Copy）" class="headerlink" title="C++代码（Copy）"></a>C++代码（Copy）</h2><pre><code class="cpp">class Solution &#123;
public:
    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;
        int left = 0, right = nums.size() - 1;

        while (left &lt;= right)
        &#123;
            int mid = (left + right) &gt;&gt; 1;
            if (nums[mid] == mid) left = mid + 1;
            else right = mid - 1;
        &#125;

        return left;    //注意最后left不等于right，只能返回left
    &#125;
&#125;;
</code></pre>
<h2 id="大佬专属代码"><a href="#大佬专属代码" class="headerlink" title="大佬专属代码"></a>大佬专属代码</h2><pre><code class="python">return (len(nums)+1)*len(nums)/2 -sum(nums)
</code></pre>
<p><strong>敲黑板！！！</strong><br><strong>有序数组二分法！！！有序数组二分法！！！有序数组二分法！！！（重要的事情说三遍）</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210607210749915.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>力扣题库</category>
        <category>剑指0ffer</category>
        <category>53-II</category>
      </categories>
  </entry>
  <entry>
    <title>54-螺旋矩阵</title>
    <url>/LeetCode/%E9%9A%BE%E5%BA%A6%E4%B8%AD%E7%AD%89/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h2><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>
<h2 id="题解示例"><a href="#题解示例" class="headerlink" title="题解示例"></a>题解示例</h2><p>示例 1：<br>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br><img data-src="https://img-blog.csdnimg.cn/20210604152606550.png" alt="在这里插入图片描述"><br>示例 2：<br>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]<br><img data-src="https://img-blog.csdnimg.cn/20210604152628828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>m &#x3D; matrix.length<br>n &#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 10<br>-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100</p>
<h2 id="标记难度"><a href="#标记难度" class="headerlink" title="标记难度"></a>标记难度</h2><p>难度：中等<br>通过次数：158025<br>提交次数：335,777<br>通过率：47.1%</p>
<h2 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h2><p>本题主要考察矩阵的遍历，还涉及到递归、矩阵转置等知识。</p>
<p>最直观的方法就是按圈遍历矩阵，从外到里一圈一圈遍历，即先遍历矩阵的最外圈，然后递归地遍历其子矩阵的最外圈。要注意的是，单行或单列需要特殊处理。</p>
<h2 id="python3代码"><a href="#python3代码" class="headerlink" title="python3代码"></a>python3代码</h2><pre><code class="python">class Solution(object):
    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: 
        row, col = len(matrix), len(matrix[0])
        def getOutermostCircle(row_start, row_end, col_start, col_end): 
            if row_start &gt; row_end or col_start &gt; col_end:# 防错
                return []
            elif row_start == row_end: #单行
                circle = []
                for j in range(col_start, col_end+1): # 上边
                    circle.append(matrix[row_start][j])
                return circle
                # return matrix[row_start][col_start:col_end+1]
            elif col_start == col_end: #单列
                circle = []
                for i in range(row_start, row_end+1):
                    circle.append(matrix[i][col_start])
                return circle
            else: # 多行多列
                circle = []
                for j in range(col_start, col_end+1): # 上边
                    circle.append(matrix[row_start][j])
                    # circle.extend(matrix[row_start][col_start:col_end+1])
                for i in range(row_start+1, row_end): # 右边
                    circle.append(matrix[i][col_end])
                for j in range(col_end, col_start-1, -1): # 下边
                    circle.append(matrix[row_end][j])
                    # circle.extend(reversed(matrix[row_end][col_start:col_end+1]))
                for i in range(row_end-1, row_start, -1): # 左边
                    circle.append(matrix[i][col_start])
                return circle + getOutermostCircle(row_start+1, row_end-1, col_start+1, col_end-1) # 拼接

        return getOutermostCircle(0, row-1, 0, col-1)
</code></pre>
<h2 id="C语言代码（官方）"><a href="#C语言代码（官方）" class="headerlink" title="C语言代码（官方）"></a>C语言代码（官方）</h2><pre><code class="c">int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) &#123;
    if (matrixSize == 0 || matrixColSize[0] == 0) &#123;
        *returnSize = 0;
        return NULL;
    &#125;

    int rows = matrixSize, columns = matrixColSize[0];
    int total = rows * columns;
    int* order = malloc(sizeof(int) * total);
    *returnSize = 0;

    int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
    while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;
        for (int column = left; column &lt;= right; column++) &#123;
            order[(*returnSize)++] = matrix[top][column];
        &#125;
        for (int row = top + 1; row &lt;= bottom; row++) &#123;
            order[(*returnSize)++] = matrix[row][right];
        &#125;
        if (left &lt; right &amp;&amp; top &lt; bottom) &#123;
            for (int column = right - 1; column &gt; left; column--) &#123;
                order[(*returnSize)++] = matrix[bottom][column];
            &#125;
            for (int row = bottom; row &gt; top; row--) &#123;
                order[(*returnSize)++] = matrix[row][left];
            &#125;
        &#125;
        left++;
        right--;
        top++;
        bottom--;
    &#125;
    return order;
&#125;
</code></pre>
<h2 id="C-（官方）"><a href="#C-（官方）" class="headerlink" title="C++（官方）"></a>C++（官方）</h2><pre><code class="cpp">class Solution &#123;
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
        if (matrix.size() == 0 || matrix[0].size() == 0) &#123;
            return &#123;&#125;;
        &#125;

        int rows = matrix.size(), columns = matrix[0].size();
        vector&lt;int&gt; order;
        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;
            for (int column = left; column &lt;= right; column++) &#123;
                order.push_back(matrix[top][column]);
            &#125;
            for (int row = top + 1; row &lt;= bottom; row++) &#123;
                order.push_back(matrix[row][right]);
            &#125;
            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;
                for (int column = right - 1; column &gt; left; column--) &#123;
                    order.push_back(matrix[bottom][column]);
                &#125;
                for (int row = bottom; row &gt; top; row--) &#123;
                    order.push_back(matrix[row][left]);
                &#125;
            &#125;
            left++;
            right--;
            top++;
            bottom--;
        &#125;
        return order;
    &#125;
&#125;;
</code></pre>
<h2 id="大佬专属代码"><a href="#大佬专属代码" class="headerlink" title="大佬专属代码"></a>大佬专属代码</h2><pre><code class="python">def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:
        res = []
        while matrix:
            res += matrix.pop(0)
            matrix = list(zip(*matrix))[::-1]
        return res
</code></pre>
<p><strong>敲黑板！！！</strong><br><strong>熟练掌握矩阵、列表的各种函数或方法！！！</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210604172806704.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>力扣题库</category>
        <category>难度中等</category>
        <category>螺旋矩阵</category>
      </categories>
  </entry>
  <entry>
    <title>22-黑白方格画</title>
    <url>/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/22-%E9%BB%91%E7%99%BD%E6%96%B9%E6%A0%BC%E7%94%BB/</url>
    <content><![CDATA[<h2 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h2><p>小扣注意到秋日市集上有一个创作黑白方格画的摊位。摊主给每个顾客提供一个固定在墙上的白色画板，画板不能转动。画板上有 n * n 的网格。绘画规则为，小扣可以选择任意多行以及任意多列的格子涂成黑色（<strong>选择的整行、整列均需涂成黑色</strong>），<strong>所选行数、列数均可为 0</strong>。</p>
<p>小扣希望最终的成品上需要有 k 个黑色格子，请返回小扣共有多少种涂色方案。</p>
<p>注意：两个方案中任意一个相同位置的格子颜色不同，就视为不同的方案。</p>
<h2 id="题解示例"><a href="#题解示例" class="headerlink" title="题解示例"></a>题解示例</h2><p>示例 1：</p>
<p>输入：n &#x3D; 2, k &#x3D; 2</p>
<p>输出：4</p>
<p>解释：一共有四种不同的方案：<br>第一种方案：涂第一列；<br>第二种方案：涂第二列；<br>第三种方案：涂第一行；<br>第四种方案：涂第二行。</p>
<p>示例 2：</p>
<p>输入：n &#x3D; 2, k &#x3D; 1</p>
<p>输出：0</p>
<p>解释：不可行，因为第一次涂色至少会涂两个黑格。</p>
<p>示例 3：</p>
<p>输入：n &#x3D; 2, k &#x3D; 4</p>
<p>输出：1</p>
<p>解释：共有 2*2&#x3D;4 个格子，仅有一种涂色方案。</p>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>1 &lt;&#x3D; n &lt;&#x3D; 6<br>0 &lt;&#x3D; k &lt;&#x3D; n * n</p>
<h2 id="标记难度"><a href="#标记难度" class="headerlink" title="标记难度"></a>标记难度</h2><p>难度：简单<br>通过次数：8065<br>提交次数：24485<br>通过率：32.9%</p>
<h2 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h2><p>本题主要考察组合和阶乘。</p>
<p>假设选择涂黑i行、j列，那么此时黑色方块共有 <strong>i*n + j*n - i*j</strong> 块，其中 <strong>i*j</strong> 为行和列重合的块数。</p>
<p>而在n行中取i行、在n列中取j列，即数学中的组合数，其值可以分别为 <strong>n! &#x2F; (i!(n-i)!)</strong>  、 <strong>n! &#x2F; (j!(n-j)!)</strong> ，这便涉及到阶乘的计算了。</p>
<p>要注意的是，当不涂或者涂满时，方法都只有一种。</p>
<h2 id="python3代码"><a href="#python3代码" class="headerlink" title="python3代码"></a>python3代码</h2><pre><code class="python">class Solution:
    def paintingPlan(self, n: int, k: int) -&gt; int:
        if k == 0 or k == n*n:
            return 1
        result = 0
        for i in range(1, n):
            for j in range(1, n):
                if n*i + n*j - i*j == k:
                    result += math.factorial(n)/(math.factorial(i) * math.factorial(n-i))*math.factorial(n)/(math.factorial(j) * math.factorial(n-j))           
        return int(result)
</code></pre>
<p>其中，阶乘的求解可以用递归，也可以用循环，或者直接用库函数，可以分别运行来比较其时间复杂度和空间复杂度。</p>
<p>另外，组合的求解方式也非常多样化，可以利用阶乘函数计算，也可以直接进行数值计算。</p>
<pre><code class="python"># 递归
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)

# 循环
def factorial(n):
    fact = 1
    for i in range(2, n+1):
        fact *= i
    return fact

# 利用阶乘
def C(n, a):
    return factorial(n)/(factorial(a) * factorial(n-a))
    
# 直接计算
def C(n, a):
    result = 1
    for i in range(n, n-a, -1):
           result *= i
    for j in range(1, a+1):
        result /= j
    return result

# 防溢出防除不尽
def C(n, a):
    result = 1
    for i in range(1, a+1):
        result *= (n+1-i)/i
    return result    
</code></pre>
<h2 id="C语言代码"><a href="#C语言代码" class="headerlink" title="C语言代码"></a>C语言代码</h2><pre><code class="c">int factorial(int n)
&#123;
       if(n == 1) 
    &#123; 	
        return 1;
    &#125;
       return n * factorial(n-1);
&#125;
int C(int n, int a)
&#123;
       return factorial(n) / (factorial(a) * factorial(n-a));
&#125;
int paintingPlan(int n, int k)&#123;
    int result = 0, i, j;
    if(k == 0 || k == n*n)
    &#123;
        return 1;
      &#125;
    for(i = 1; i &lt;= n; ++i)
    &#123;
        for&#123;j = 1; j &lt;= n; ++j)
        &#123;
            if((n*i + n*j - i*j) == k)
            &#123;
                result += C(n, i) * C(n, j);
            &#125;
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h2 id="C-代码（Copy）"><a href="#C-代码（Copy）" class="headerlink" title="C++代码（Copy）"></a>C++代码（Copy）</h2><pre><code class="cpp">class Solution &#123;
public:
    //预处理组合数
    int C[10][10];
    void Init()&#123;
        for(int i = 0; i &lt; 10; i++)&#123;
            for(int j = 0; j &lt;= i; j++)&#123;
                if(!j) C[i][j] = 1;
                else C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
            &#125;
        &#125;
    &#125;
    int paintingPlan(int n, int k) &#123;
        if(k == 0) return 1;
        if(k &lt; n) return 0;
        if(k == n * n) return 1;
        Init();
        int ans = 0;
        for(int i = 0 ; i &lt;= n; i++)&#123;
            for(int j = 0; j &lt;= n; j++)&#123;
                if(n * i + n * j - i * j == k)&#123;
                    ans += C[n][i] * C[n][j];
                &#125;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<h2 id="大佬专属代码"><a href="#大佬专属代码" class="headerlink" title="大佬专属代码"></a>大佬专属代码</h2><pre><code class="c">int paintingPlan(int n, int k)
&#123;
    int p=0;
    if(k==0)
        p=1;
    if(n==1)
    &#123;
        if(k==1)
            p=1;
    &#125;
    if(n==2)
    &#123;
        if(k==2)
            p=4;
        if(k==3)
            p=4;
        if(k==4)
            p=1;
    &#125;
    if(n==3)
    &#123;
        if(k==3)
            p=6;
        if(k==5)
            p=9;
        if(k==6)
            p=6;
        if(k==7)
           p=18;
        if(k==8)
            p=9;
        if(k==9)
            p=1;
    &#125;
    if(n==4)
    &#123;
        if(k==4)
            p=8;
        if(k==7)
            p=16;
        if(k==8)
            p=12;
        if(k==10)
            p=48;
        if(k==12)
            p=44;
        if(k==13)
            p=32;
        if(k==14)
            p=48;
        if(k==15)
            p=16;
        if(k==16)
            p=1;
    &#125;
    if(n==5)
    &#123;
        if(k==5)
            p=10;
        if(k==9)
            p=25;
        if(k==10)
            p=20;
        if(k==13)
            p=100;
        if(k==15)
            p=20;
        if(k==16)
            p=100;
        if(k==17)
            p=200;
        if(k==21)
            p=150;
        if(k==19)
            p=200;
        if(k==20)
            p=10;
        if(k==25)
            p=1;
        if(k==24)
            p=25;
        if(k==23)
            p=100;
        if(k==22)
            p=100;
    &#125;
    if(n==6)
    &#123;
        if(k==36)
            p=1;
        if(k==35)
            p=36;
        if(k==34)
            p=180;
        if(k==33)
            p=240;
        if(k==32)
            p=405;
        if(k==31)
            p=72;
        if(k==30)
            p=612;
        if(k==28)
            p=450;
        if(k==27)
            p=400;
        if(k==26)
            p=180;
        if(k==24)
            p=630;
        if(k==21)
            p=240;
        if(k==20)
            p=225;
        if(k==18)
            p=40;
        if(k==16)
            p=180;
        if(k==12)
            p=30;
        if(k==11)
            p=36;
        if(k==6)
            p=12;
    &#125;
    return p;
&#125;
</code></pre>
<p><strong>敲黑板！！！<br>排列、组合、阶乘的各种实现代码必须做到信手拈来，还要考虑其时间复杂度、空间复杂度、是否溢出、是否除不尽等！！！</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210602213721831.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>力扣题库</category>
        <category>难度简单</category>
        <category>黑白方格画</category>
      </categories>
  </entry>
  <entry>
    <title>833-三维形体投影面积</title>
    <url>/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/833-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E6%8A%95%E5%BD%B1%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在 n x n 的网格 grid 中，我们放置了一些与 x，y，z 三轴对齐的 1 x 1 x 1 立方体。每个值 v &#x3D; grid[i] [j] 表示 v 个正方体叠放在单元格 (i, j) 上。现在，我们查看这些立方体在 xy 、yz 和 zx 平面上的投影。投影就像影子，将三维形体映射到一个二维平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。返回所有三个投影的总面积 。</p>
<p>输入示例1：</p>
<p>[[1, 2], [3, 4]]</p>
<p>输出示例1：</p>
<p>17</p>
<p>解释：</p>
<p>该立体图形的俯视图如下，数字代表该处有多少块立方体。</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">3</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p>投影面积 &#x3D; 4（俯视图） + 7（主视图） + 6（左视图）&#x3D; 17</p>
<p>输入示例2：</p>
<p>[[2]]</p>
<p>输出示例2：</p>
<p>5</p>
<p>输入示例3：</p>
<p>[[1, 0], [0, 2]]</p>
<p>输出示例3：</p>
<p>8</p>
<p>限制条件：</p>
<p>n &#x3D;&#x3D; grid.length &#x3D;&#x3D; grid[i].length</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 50</p>
<p>0 &lt;&#x3D; grid[i] [j] &lt;&#x3D; 50</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>S（俯视图） &#x3D; sum(grid[i] [j] &gt; 0)，即矩阵中非零数值的个数。</p>
<p>S（主视图） &#x3D; sum(max(grid[j]))，即矩阵中每一列最大值的和。</p>
<p>S（左视图） &#x3D; sum(max(grid[i]))，即矩阵中每一行最大值的和。</p>
<h1 id="个人代码"><a href="#个人代码" class="headerlink" title="个人代码"></a>个人代码</h1><pre><code class="python">class Solution:
    def projectionArea(self, grid: List[List[int]]) -&gt; int:
        xy, xz, yz = 0, 0, 0
        for i in range(len(grid)):
            maxr, maxc = 0, 0
            for j in range(len(grid[i])):
                if grid[i][j] &gt; 0:
                    xy += 1
                maxr = max(maxr, grid[i][j])
                maxc = max(maxc, grid[j][i])

            xz += maxr
            yz += maxc     
        return (xy+xz+yz)  
</code></pre>
<h1 id="官方代码"><a href="#官方代码" class="headerlink" title="官方代码"></a>官方代码</h1><pre><code class="python">class Solution:
    def projectionArea(self, grid: List[List[int]]) -&gt; int:
        xyArea = sum(v &gt; 0 for row in grid for v in row)
        # 注意这里为 O(n) 空间复杂度，改为下标枚举则可以 O(1)
        yzArea = sum(map(max, zip(*grid)))  
        zxArea = sum(map(max, grid))
        return xyArea + yzArea + zxArea
</code></pre>
<pre><code class="c++">class Solution &#123;
public:
    int projectionArea(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;
        int n = grid.size();
        int xyArea = 0, yzArea = 0, zxArea = 0;
        for (int i = 0; i &lt; n; i++) &#123;
            int yzHeight = 0, zxHeight = 0;
            for (int j = 0; j &lt; n; j++) &#123;
                xyArea += grid[i][j] &gt; 0 ? 1 : 0;
                yzHeight = max(yzHeight, grid[j][i]);
                zxHeight = max(zxHeight, grid[i][j]);
            &#125;
            yzArea += yzHeight;
            zxArea += zxHeight;
        &#125;
        return xyArea + yzArea + zxArea;
    &#125;
&#125;;
</code></pre>
<pre><code class="c">#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))

int projectionArea(int** grid, int gridSize, int* gridColSize) &#123;
    int xyArea = 0, yzArea = 0, zxArea = 0;
    for (int i = 0; i &lt; gridSize; i++) &#123;
        int yzHeight = 0, zxHeight = 0;
        for (int j = 0; j &lt; gridSize; j++) &#123;
            xyArea += grid[i][j] &gt; 0 ? 1 : 0;
            yzHeight = MAX(yzHeight, grid[j][i]);
            zxHeight = MAX(zxHeight, grid[i][j]);
        &#125;
        yzArea += yzHeight;
        zxArea += zxHeight;
    &#125;
    return xyArea + yzArea + zxArea;
&#125;
</code></pre>
<p><img data-src="https://img-blog.csdnimg.cn/187e682d741b47389088c8f74f117822.png#pic_center" alt="wolf"></p>
]]></content>
      <categories>
        <category>力扣题库</category>
        <category>难度简单</category>
        <category>三维形体投影面积</category>
      </categories>
  </entry>
  <entry>
    <title>11-期望个数统计</title>
    <url>/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/11-%E6%9C%9F%E6%9C%9B%E4%B8%AA%E6%95%B0%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h2><p>某互联网公司一年一度的春招开始了，一共有 n 名面试者入选。每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。</p>
<p>小 A 和小 B 负责审核面试者，他们均有所有面试者的简历，并且将各自根据面试者能力值从大到小的顺序浏览。由于简历事先被打乱过，能力值相同的简历的出现顺序是从它们的全排列中等可能地取一个。现在给定 n 名面试者的能力值 scores，设 X 代表小 A 和小 B 的浏览顺序中出现在同一位置的简历数，求 X 的期望。</p>
<p>提示：离散的非负随机变量的期望计算公式为   E(X) &#x3D; Σ(k&#x3D;1, ∞) kPr(X &#x3D; k)。在本题中，由于 X 的取值为 0 到 n 之间，期望计算公式可以是E(X) &#x3D; Σ(k&#x3D;1, n) kPr(X &#x3D; k)。</p>
<h2 id="题解示例"><a href="#题解示例" class="headerlink" title="题解示例"></a>题解示例</h2><p>示例 1：</p>
<p>输入：scores &#x3D; [1,2,3]</p>
<p>输出：3</p>
<p>解释：由于面试者能力值互不相同，小 A 和小 B 的浏览顺序一定是相同的。X的期望是 3 。</p>
<p>示例 2：</p>
<p>输入：scores &#x3D; [1,1]</p>
<p>输出：1</p>
<p>解释：设两位面试者的编号为 0, 1。由于他们的能力值都是 1，小 A 和小 B 的浏览顺序都为从全排列 [[0,1],[1,0]] 中等可能地取一个。如果小 A 和小 B 的浏览顺序都是 [0,1] 或者 [1,0] ，那么出现在同一位置的简历数为 2 ，否则是 0 。所以 X 的期望是 (2+0+2+0) * 1&#x2F;4 &#x3D; 1</p>
<p>示例 3：</p>
<p>输入：scores &#x3D; [1,1,2]</p>
<p>输出：2</p>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>1 &lt;&#x3D; scores.length &lt;&#x3D; 10^5<br>0 &lt;&#x3D; scores[i] &lt;&#x3D; 10^6</p>
<h2 id="标记难度"><a href="#标记难度" class="headerlink" title="标记难度"></a>标记难度</h2><p>难度：简单<br>通过次数：6051<br>提交次数：8963<br>通过率：67.5%</p>
<h2 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h2><p>数组中的元素可以分为两种：单元素和多元素。</p>
<p>对于单元素，由于两位面试官都是根据能力值从大到小的顺序浏览，假设数组元素按数值非递c增的顺序排列，那么其在数组中的顺序一定是相同的，即单元素在两位面试官的浏览顺序中一定是出现在同一位置的，则单元素的数学期望为1。</p>
<p>对于多元素，假设该元素出现m次，编号为0，1，2，…，m-1。假设m &#x3D; 3，则全排列有如下6种情况：（0,1,2），（0,2,1），（1,0,2），（1,2,0），（2,0,1），（2,1,0），现两个面试官分别从六种顺序里挑选一种，易知每个位置编号相同的概率均为1&#x2F;3，那么可以得出两位面试官在同一位置选取同一元素的概率为1&#x2F;n，则多元素的数学期望为1&#x2F;n × n &#x3D; 1。</p>
<p>可以得出，无论是单元素还是多元素，其数学期望均为1，即整个数组的数学期望等于数组中数值不同的元素的个数和。</p>
<h2 id="python3代码"><a href="#python3代码" class="headerlink" title="python3代码"></a>python3代码</h2><pre><code class="python">class Solution:
    def expectNumber(self, scores: List[int]) -&gt; int:
        return len(set(scores))
</code></pre>
<h2 id="C语言代码"><a href="#C语言代码" class="headerlink" title="C语言代码"></a>C语言代码</h2><pre><code class="c">int expectNumber(int* scores, int scoresSize)&#123;
    int hash[1000000] = &#123;0&#125;;
    int result = 0;
    for (int i = 0; i &lt; scoresSize; ++i) &#123;
        if (hash[scores[i]] == 0) &#123;
            hash[scores[i]]++;
            result++;
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><pre><code class="cpp">class Solution &#123;
public:
    int expectNumber(vector&lt;int&gt;&amp; scores) &#123;
        return set&lt;int&gt;(scores.begin(), scores.end()).size();
    &#125;
&#125;;
</code></pre>
<h2 id="大佬专属代码"><a href="#大佬专属代码" class="headerlink" title="大佬专属代码"></a>大佬专属代码</h2><pre><code class="python"># 暂时没看到任何“出类拔萃”的代码
</code></pre>
<p><strong>敲黑板！！！</strong><br><strong>这道题关键在于看懂题目，只能说：概率论yyds！！！</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210606171417228.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>力扣题库</category>
        <category>难度简单</category>
        <category>期望个数统计</category>
      </categories>
  </entry>
</search>
