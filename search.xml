<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一章-人工智能的概述</title>
    <url>/ArtificialIntelligence/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="人工智能概述"><a href="#人工智能概述" class="headerlink" title="人工智能概述"></a>人工智能概述</h1><h2 id="人工智能的定义"><a href="#人工智能的定义" class="headerlink" title="人工智能的定义"></a>人工智能的定义</h2><h3 id="什么是智能"><a href="#什么是智能" class="headerlink" title="什么是智能"></a>什么是智能</h3><ul>
<li>自然智能：指人类和一些动物所具有的智力和行为能力。</li>
<li>人类的自然智能（简称智能）：指人类在认识客观世界中，由思维过程和脑力活动所表现出的综合能力。</li>
</ul>
<h3 id="智能的不同观点"><a href="#智能的不同观点" class="headerlink" title="智能的不同观点"></a>智能的不同观点</h3><ul>
<li>思维理论：<strong>智能来源于思维活动，智能的核心是思维，人的一切知识都是思维的产物</strong>。可望通过对思维规律和思维方法的研究来揭示智能的本质。</li>
<li>知识阈值理论：<strong>智能取决于知识的数量及其可运用程度</strong>。一个系统所具有的可运用知识越多，其智能就会越高。</li>
<li>进化理论：智能取决于感知和行为，取决于对外界复杂环境的适应，智能不需要知识、不需要表示、不需要推理，<strong>智能可由逐步进化来实现</strong>。（MIT，Brooks，人造机器虫研究）</li>
</ul>
<h3 id="智能的层次结构"><a href="#智能的层次结构" class="headerlink" title="智能的层次结构"></a>智能的层次结构</h3><ul>
<li>高层智能：以大脑皮层（抑制中枢）为主，主要完成记忆、思维等活动。</li>
<li>中层智能：以丘脑（间脑，感觉中枢）为主，主要完成感知活动。</li>
<li>低层智能：以小脑、脊髓为主，主要完成动作反应活动。</li>
<li><strong>思维理论和知识阈值理论对应高层智能，而进化理论对应中层智能和低层智能</strong>。</li>
</ul>
<h3 id="智能包含的能力"><a href="#智能包含的能力" class="headerlink" title="智能包含的能力"></a>智能包含的能力</h3><ul>
<li><p>感知能力：<strong>人类获得外界信息的基本途径</strong>。</p>
<p>感知–动作方式：对简单、紧急的信息。</p>
<p>感知–思维–动作方式：对复杂的信息。</p>
</li>
<li><p>记忆和思维的能力：</p>
<p>记忆：对感知到的外界信息和由思维产生的内部知识的<strong>存储</strong>过程。</p>
<p>思维：对已存储信息或知识的本质属性、内部规律的<strong>认识</strong>过程。</p>
<p>思维方式：</p>
<ul>
<li>抽象思维（逻辑思维）：根据<strong>逻辑规则</strong>对信息和知识进行处理的理性思维方式。</li>
<li>形象思维（直感思维）：根据<strong>感性形象认识材料</strong>对客观现象进行处理的一种思维方式。</li>
<li>灵感思维（顿悟思维）：是一种显意识和潜意识相互作用的思维方式。</li>
</ul>
</li>
<li><p>学习和自适应能力：</p>
<p>学习：<strong>是一个具有特定目的的知识获取过程，是人的一种本能</strong>。不同人的学习方法、能力不同。</p>
<p>自适应：<strong>是一种通过自我调节适应外界环境的过程，是人的一种本能</strong>。不同人的适应能力不同。</p>
</li>
<li><p>行为能力：<strong>对感知的外界信息做出动作反应的能力</strong>。</p>
<p>信息来源：由感知直接获得的外界信息或经过思维加工后的信息。</p>
<p>实现过程’：通过脊髓来控制，由语言、表情、体姿等来实现。</p>
</li>
</ul>
<h3 id="什么是人工智能"><a href="#什么是人工智能" class="headerlink" title="什么是人工智能"></a>什么是人工智能</h3><ul>
<li>学科的名称。</li>
<li>人工方法实现的智能。</li>
<li>计算机模拟实现的智能。</li>
<li>人造的智能机器或系统。</li>
<li>模仿、延伸以及扩展人的智能。</li>
</ul>
<h3 id="人工智能典型的4种定义方法"><a href="#人工智能典型的4种定义方法" class="headerlink" title="人工智能典型的4种定义方法"></a>人工智能典型的4种定义方法</h3><ul>
<li>类人思维方法（认知模型方法）：1978年贝尔曼，人工智能是那些与人的思维、决策、问题求解和学习等有关活动的自动化。</li>
<li>类人行为方法（图灵测试方法）：1990年库兹韦勒，人工智能是一种创建机器的技艺，这种机器能够执行需要人的智能才能完成的功能。</li>
<li>理性思维方法（思维法则方法）：1985年查尼艾克、麦克德莫特，人工智能是通过计算模型来进行心智能力研究的。</li>
<li>理性行为方法（理性智能体方法）：1998年尼尔森，人工智能关心的是人工制品种的智能行为，即人工智能就是研究和建造理性智能体。</li>
<li><strong>理性思维方法与理性行为方法的关系：</strong><ul>
<li>前者强调正确思维，后者强调合理行动。</li>
<li>理性行为可以依据理性思维进行。</li>
<li>理性行为不一定要依据理性思维进行。</li>
</ul>
</li>
</ul>
<h3 id="人工智能的一般解释"><a href="#人工智能的一般解释" class="headerlink" title="人工智能的一般解释"></a>人工智能的一般解释</h3><ul>
<li>从能力的角度：人工智能是指<strong>用人工的方法在机器上实现的智能</strong>，是智能机器所执行的通常与人类智能有关的功能，如判断、推理、证明、识别、感知、理解、设计、思考、规划、学习和问题求解等思维活动。</li>
<li>从学科的角度：人工智能是<strong>一门研究如何构造智能机器或智能系统，去模拟、延伸和扩展人类智能的学科</strong>，是计算机科学中涉及研究、设计和应用智能机器的一个分支。</li>
</ul>
<h3 id="人工智能的研究目标"><a href="#人工智能的研究目标" class="headerlink" title="人工智能的研究目标"></a>人工智能的研究目标</h3><ul>
<li><p>1978年斯洛曼，三个主要目标：</p>
<ul>
<li><p>对智能行为有效解释的理论分析。</p>
</li>
<li><p>解释人类智能。</p>
</li>
<li><p>构造具有智能的人工制品。</p>
</li>
</ul>
</li>
<li><p>远期目标：<strong>用自动机重现人类的思维过程和智能行为</strong>。</p>
<p>揭示人类智能的根本机理，用智能机器去模拟、延伸和扩展人类的智能。涉及到脑科学、认知科学、计算机科学、系统科学、控制论等多种学科，并依赖于它们的共同发展。</p>
</li>
<li><p>近期目标：<strong>建造智能计算机代替人类的部分智力劳动</strong>。</p>
<p>研究如何使现有的计算机更聪明，即使它能够运用知识去处理问题，能够模拟人类的智能行为。</p>
</li>
<li><p><strong>远期目标和近期目标的相互关系：</strong></p>
<ul>
<li>远期目标为近期目标指明了方向。</li>
<li>近期目标则为远期目标奠定了理论和技术基础。</li>
</ul>
</li>
</ul>
<h2 id="人工智能的发展简史"><a href="#人工智能的发展简史" class="headerlink" title="人工智能的发展简史"></a>人工智能的发展简史</h2><h3 id="简史总结"><a href="#简史总结" class="headerlink" title="简史总结"></a>简史总结</h3><p><img data-src="/ArtificialIntelligence/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/1.png" alt="1"></p>
<h2 id="人工智能的研究内容"><a href="#人工智能的研究内容" class="headerlink" title="人工智能的研究内容"></a>人工智能的研究内容</h2><h3 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h3><ul>
<li>如何获取知识？</li>
<li>如何将获取的知识以计算机内部代码形式加以合理表示？</li>
<li>如何运用知识进行推理，解决实际问题？</li>
</ul>
<h2 id="人工智能研究方法与途径"><a href="#人工智能研究方法与途径" class="headerlink" title="人工智能研究方法与途径"></a>人工智能研究方法与途径</h2><h3 id="三大学派"><a href="#三大学派" class="headerlink" title="三大学派"></a>三大学派</h3><ul>
<li>符号主义：运用计算机科学的方法（逻辑演绎）。<ul>
<li>智能的基础是<strong>知识</strong>，其核心是<strong>知识表示和知识推理</strong>。</li>
<li><strong>知识可用符号表示，也可用符号进行推理</strong>，因而可以建立基于知识的人类智能和机器智能的统一的理论体系。</li>
<li><strong>功能模拟，构造能够模拟大脑功能的智能系统</strong>。</li>
</ul>
</li>
<li>联结主义：运用仿生学的方法（网络连接机制）。<ul>
<li>智能行为的基元是<strong>神经元</strong>，而不是符号。</li>
<li>思维过程是<strong>神经元的联结活动过程</strong>，而不是符号运算过程，反对符号主义关于物理符号系统的假设。</li>
<li><strong>结构模拟，构造模拟大脑结构的神经网络系统</strong>。</li>
</ul>
</li>
<li>行为主义：运用进化论的思想（控制论和机器学习方法）。<ul>
<li>智能取决于<strong>感知和行动</strong>，即“感知-动作”模型。</li>
<li>智能不需要知识、不需要表示、不需要推理，人工智能可以像人类智能那样<strong>逐步进化</strong>。</li>
<li><strong>行为模拟，构造具有进化能力的智能系统</strong>。</li>
</ul>
</li>
</ul>
<h2 id="人工智能的研究领域"><a href="#人工智能的研究领域" class="headerlink" title="人工智能的研究领域"></a>人工智能的研究领域</h2><h3 id="研究领域"><a href="#研究领域" class="headerlink" title="研究领域"></a>研究领域</h3><ul>
<li>机器思维：<strong>推理（确定性推理、不确定性推理）和搜索（状态空间搜索、与&#x2F;或树搜索、博弈树搜索）</strong>。</li>
<li>机器感知：计算机视觉、模式识别和自然语言处理。</li>
<li>机器行为：智能控制&#x2F;制造。</li>
<li>机器学习：符号学习和神经学习。</li>
<li>计算智能：神经计算、进化计算和模糊计算。</li>
<li>分布智能：并行求解。</li>
<li>智能系统：专家系统和智能决策支持系统。</li>
</ul>
<h2 id="人工智能的研究现状与发展方向"><a href="#人工智能的研究现状与发展方向" class="headerlink" title="人工智能的研究现状与发展方向"></a>人工智能的研究现状与发展方向</h2><h3 id="研究现状"><a href="#研究现状" class="headerlink" title="研究现状"></a>研究现状</h3><ul>
<li>多学科交叉研究</li>
<li>多学派和多技术融合研究</li>
<li>分布智能研究</li>
<li>群体智能研究</li>
<li>社会智能研究</li>
<li>集成智能研究</li>
<li>认知计算与情感计算研究</li>
<li>智能系统与智能服务</li>
</ul>
<h3 id="发展方向"><a href="#发展方向" class="headerlink" title="发展方向"></a>发展方向</h3><ul>
<li>知识 + 数据 + 算法 + 算力。</li>
</ul>
<p><img data-src="/ArtificialIntelligence/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/Wolf.jpg" alt="Wolf"></p>
]]></content>
      <categories>
        <category>ArtificialIntelligence</category>
        <category>第一章-人工智能的概述</category>
      </categories>
      <tags>
        <tag>人工智能，笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/LeetCode/1_twosum_easy/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h3><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</p>
<h3 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h3><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]</p>
<h3 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h3><p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]</p>
<h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><p>（1）2 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>（2）-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>（3）-109 &lt;&#x3D; target &lt;&#x3D; 109<br>（4）只会存在一个有效答案</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>两数之和</category>
      </categories>
  </entry>
  <entry>
    <title>CPP语言基础</title>
    <url>/C-CPP/CPP%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C-CPP</category>
        <category>CPP语言基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到我的世界</title>
    <url>/Hello-MyWorld/hello-world/</url>
    <content><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo</span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting</span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub</span>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing</span></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server</span></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating</span></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment</span></p>
]]></content>
      <categories>
        <category>Hello-MyWorld</category>
        <category>欢迎来到我的世界</category>
      </categories>
  </entry>
  <entry>
    <title>学生成绩管理系统</title>
    <url>/C-CPP/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>相信很多同仁在大学学习编程的时候都会被老师要求动手敲出一个学生成绩管理系统或图书馆管理系统之类的程序吧。<br><strong>不得不说，这个程序简直就是大多数初学者的恶梦，毕竟它的内容涉及到了整一个学期学到的所有知识。</strong><br><del>况且，对于像我这种在大学前从来没接触过编程，也不知道代码是啥的绝对萌新来说，更是一次史诗级的灾难。</del> </p>
<p><strong>你见过凌晨四点的教学楼吗？</strong><br><strong>我见过，那时候我刚从里面出来。</strong><br><img data-src="/C-CPP/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1.jpg"></p>
<p><strong>话不多说，说多了都是泪。</strong></p>
<p>实验要求我就不赘述了吧，无非就是录成绩、各种方式查成绩、名次排序、计算均分等。</p>
<p><strong>还是直接上代码吧，大家都是爽快人！</strong></p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define N 30
#define M 10
#define X 6

/*学生信息结构体，包括学号，姓名，各学科分数，总分，均分*/
typedef struct student
&#123;
  long number;
  char name[M];
  int score[X];
  int stutotal;
  float stuaverage;
&#125;STUDENT;/*对学生信息结构体取别名“STUDENT”*/

/*实现两个结构体的交换，注意，结构体是可以直接赋值的*/
void Swap(STUDENT *a,STUDENT *b)
&#123;
  STUDENT temp;
  temp=*a;
  *a=*b;
  *b=temp;
&#125;

/*由用户用键盘依次输入学生信息*/
void Input(STUDENT stu[],int n,int x)
&#123;
    printf(&quot;\n\n&quot;);
    int i,j;
    for(i=0;i&lt;n;i++)
    &#123;
        printf(&quot;Number:\t&quot;);
        scanf(&quot;%ld&quot;,&amp;stu[i].number);
        getchar();/*清除缓冲区中的回车字符，防止被读入学生姓名*/
        printf(&quot;Name:\t&quot;);
        gets(stu[i].name);
        for(j=0;j&lt;x;j++)
        &#123;
            do&#123;
                printf(&quot;Score %d:&quot;,j+1);
                scanf(&quot;%d&quot;,&amp;stu[i].score[j]);
            &#125;while(stu[i].score[j]&lt;0||stu[i].score[j]&gt;100);/*防止录入异常成绩*/
        &#125;
    &#125;
&#125;

/*计算各学科的总分和均分*/
void SubCalculate(STUDENT stu[],int subtotal[],float subaverage[],int n,int x)
&#123;
    int i,j;
    for(j=0;j&lt;x;j++)
    &#123;
        subtotal[j]=0;/*学科总成绩初始化为0*/
        for(i=0;i&lt;n;i++)
        &#123;
            subtotal[j]=subtotal[j]+stu[i].score[j];
        &#125;
        subaverage[j]=(float)subtotal[j]/n;/*将整型数强转为浮点数后进行浮点数运算，确保数据的准确性*/
        printf(&quot;(subject %d)Total:%d\t\tAverage:%6.2f\n&quot;,j+1,subtotal[j],subaverage[j]);
    &#125;
 &#125;

/*计算每个学生的总分和均分*/
void StuCalculate(STUDENT stu[],int n,int x)
&#123;
    int i,j;
    for(i=0;i&lt;n;i++)
    &#123;
        stu[i].stutotal=0;/*学生总成绩初始化为0*/
        for(j=0;j&lt;x;j++)
        &#123;
            stu[i].stutotal=stu[i].stutotal+stu[i].score[j];
        &#125;
        stu[i].stuaverage=(float)stu[i].stutotal/x;/*将整型数强转为浮点数后进行浮点数运算，确保数据的准确性*/
        printf(&quot;(student %d)Total:%d\t\tAverage:%6.2f\n&quot;,i+1,stu[i].stutotal,stu[i].stuaverage);
    &#125;
&#125;

/*将学生成绩按从高到低的顺序排列*/
void SortStuScoreUpdown(STUDENT stu[],int n)
&#123;
    for (int i = 0; i &lt; n - 1; ++i)
    &#123;
        for (int j = i + 1; j &lt; n; ++j)
        &#123;
            if (stu[i].stutotal &lt; stu[j].stutotal) Swap(&amp;stu[i], &amp;stu[j]);/*如果前面的学生的总成绩小于后面的学生的总成绩，则交换两个学生信息结构体位置*/
        &#125;
      &#125;
&#125;

/*将学生成绩按从低到高的顺序排列*/
void SortStuScoreDownup(STUDENT stu[],int n)
&#123;
        for (int i = 0; i &lt; n - 1; ++i)
    &#123;
        for (int j = i + 1; j &lt; n; ++j)
        &#123;
            if (stu[i].stutotal &gt; stu[j].stutotal) Swap(&amp;stu[i], &amp;stu[j]);/*如果前面的学生的总成绩大于后面的学生的总成绩，则交换两个学生信息结构体位置*/
        &#125;
      &#125;
&#125;

/*将学生学号按从小到大排列*/
void SortNumberDownup(STUDENT stu[],int n)
&#123;
        for (int i = 0; i &lt; n - 1; ++i)
    &#123;
        for (int j = i + 1; j &lt; n; ++j)
        &#123;
            if (stu[i].number &gt; stu[j].number) Swap(&amp;stu[i], &amp;stu[j]);/*如果前面的学生的学号大于后面的学生的学号，则交换两个学生信息结构体位置*/
        &#125;
      &#125;
&#125;

/*将学生姓名按字典顺序排列*/
void SortName(STUDENT stu[],int n)
&#123;
    for (int i = 0; i &lt; n - 1; ++i)
    &#123;
        for (int j = i + 1; j &lt; n; ++j)
        &#123;
            if (strcmp(stu[i].name,stu[j].name)&gt;0) Swap(&amp;stu[i], &amp;stu[j]);/*如果前面的学生的字母序位大于后面的学生的字母序位，则交换两个学生信息结构体位置*/
        &#125;
      &#125;
&#125;

/*按学号查找学生并输出学生信息*/
void SearchNumber(STUDENT stu[],int n,int x)
&#123;
    int i,j,flag=0;/*未找到学生时flag初始化为0*/
    long temp;
    printf(&quot;Input the number:\t&quot;);
    scanf(&quot;%ld&quot;,&amp;temp);
    getchar();
    SortStuScoreUpdown(stu,n);/*将学生按照成绩从高到低排序以获得学生的排名情况*/
    for(i=0;i&lt;n;i++)/*将录入的学生学号与待查学号进行一一比对*/
    &#123;
        if(stu[i].number==temp)/*找到与待查学号一致的学号*/
        &#123;
            flag=1;/*找到学号对应的学生时，flag被赋值为1*/
            printf(&quot;Name:     \tNumber:      \tPosition:\tTotalscore:\tAveragescore:\t  Subjectscores:\n&quot;);
            printf(&quot;%-10s\t%-13ld\t%9d\t%11d\t%13.2f\t&quot;,stu[i].name,stu[i].number,i+1,stu[i].stutotal,stu[i].stuaverage);
            for(j=0;j&lt;x;j++)
            &#123;
                printf(&quot;%4d&quot;,stu[i].score[j]);
            &#125;
            printf(&quot;\n&quot;);
            break;
        &#125;
    &#125;
    if(flag==0)/*未找到学号对应学生时，flag的值仍为0*/
    &#123;
        printf(&quot;\nNot find!\n&quot;);
    &#125;
&#125;

/*按姓名查找学生并输出学生信息*/
void SearchName(STUDENT stu[],int n,int x)
&#123;
    int i,j,flag=0;/*未找到学生时flag初始化为0*/
    char tep[M];
    printf(&quot;Input the name:\t&quot;);
  scanf(&quot; %s&quot;,tep);
    SortStuScoreUpdown(stu,n);/*将学生按照成绩从高到低排序以获得学生的排名情况*/
    for(i=0;i&lt;n;i++)/*将录入的学生姓名与待查姓名进行一一比对*/
    &#123;
        if(strcmp(stu[i].name,tep)==0)/*找到与待查姓名字母顺序完全一致的姓名*/
        &#123;
            flag=1;/*找到学号对应的学生时，flag被赋值为1*/
            printf(&quot;Name:     \tNumber:      \tPosition:\tTotalscore:\tAveragescore:\t  Subjectscores:\n&quot;);
            printf(&quot;%-10s\t%-13ld\t%9d\t%11d\t%13.2f\t&quot;,stu[i].name,stu[i].number,i+1,stu[i].stutotal,stu[i].stuaverage);
            for(j=0;j&lt;x;j++)
            &#123;
                printf(&quot;%4d&quot;,stu[i].score[j]);
            &#125;
            printf(&quot;\n&quot;);
            break;
        &#125;
    &#125;
    if(flag==0)/*未找到学号对应学生时，flag的值仍为0*/
    &#123;
        printf(&quot;\nNot find!\n&quot;);
    &#125;
&#125;

/*统计并打印出各学科各阶段人数及占比*/
void Analysis(STUDENT stu[],int n,int x)
&#123;
    int a[N]=&#123;0&#125;,b[N]=&#123;0&#125;,c[N]=&#123;0&#125;,d[N]=&#123;0&#125;,e[N]=&#123;0&#125;;
    int i,j;
    for(j=0;j&lt;x;j++)
    &#123;
        for(i=0;i&lt;n;i++)
        &#123;
            if    (100&gt;=stu[i].score[j]&amp;&amp;90&lt;=stu[i].score[j])    a[j]++;
            else if(89&gt;=stu[i].score[j]&amp;&amp;80&lt;=stu[i].score[j])    b[j]++;
            else if(79&gt;=stu[i].score[j]&amp;&amp;70&lt;=stu[i].score[j])    c[j]++;
            else if(69&gt;=stu[i].score[j]&amp;&amp;60&lt;=stu[i].score[j])    d[j]++;
            else                                                           e[j]++;
        &#125;
    &#125;
    for(j=0;j&lt;x;j++)
    &#123;
        printf(&quot;Subject No.%d:\n&quot;,j+1);
        printf(&quot;Excellent:%d\tpercent:%.2f%%\n&quot;,a[j],(float)100*a[j]/n);
        printf(&quot;Good:     %d\tpercent:%.2f%%\n&quot;,b[j],(float)100*b[j]/n);
        printf(&quot;Medium:   %d\tpercent:%.2f%%\n&quot;,c[j],(float)100*c[j]/n);
        printf(&quot;Pass:     %d\tpercent:%.2f%%\n&quot;,d[j],(float)100*d[j]/n);
        printf(&quot;Failed:   %d\tpercent:%.2f%%\n&quot;,e[j],(float)100*e[j]/n);
        printf(&quot;\n&quot;);
    &#125;
    printf(&quot;\n&quot;);
&#125;

/*输出各学生的学生信息及各课程的总分和均分*/
void List(STUDENT stu[],int subtotal[],float subaverage[],int n,int x)
&#123;
    int i,j;
    printf(&quot;Name:     \tNumber:      \tTotalscore:\tAveragescore:\tSub 1:Sub 2:Sub 3:Sub 4:Sub 5:Sub 6:\n&quot;);
    for(i=0;i&lt;n;i++)
    &#123;
        printf(&quot;%-10s\t%-13ld\t%11d\t%13.2f\t&quot;,stu[i].name,stu[i].number,stu[i].stutotal,stu[i].stuaverage);
        for(j=0;j&lt;x;j++)
        &#123;
            printf(&quot;%6d&quot;,stu[i].score[j]);
        &#125;
        printf(&quot;\n&quot;);
    &#125;
     printf(&quot;          \t             \t           \t           \t&quot;);
     for(j=0;j&lt;x;j++)
     &#123;
      printf(&quot;%6d&quot;,subtotal[j]);
     &#125;
      printf(&quot;\n&quot;);
      printf(&quot;         \t             \t           \t          \t&quot;);
      for(j=0;j&lt;x;j++)
      &#123;
          printf(&quot;%6.2f&quot;,subaverage[j]);
      &#125;
&#125;

/*打印姓名，学号，总分，均分及各学科的分数*/
void Print1(STUDENT stu[],int n,int x)
&#123;
    int i,j;
    printf(&quot;Name:     \tNumber:\t      Totalscore:\tAveragescore:\tSubjectscore:\n&quot;);
    for(i=0;i&lt;n;i++)
    &#123;
        printf(&quot;%-10s\t%-13ld\t%9d\t%13.2f\t&quot;,stu[i].name,stu[i].number,stu[i].stutotal,stu[i].stuaverage);
        for(j=0;j&lt;x;j++)
        &#123;
            printf(&quot;%-6d&quot;,stu[i].score[j]);
        &#125;
        printf(&quot;\n&quot;);
    &#125;
&#125;

/*打印各课程的总分和均分*/
void Print2(int subtotal[],float subaverage[],int x)
&#123;
  int i;
  for(i=0;i&lt;x;i++)
  &#123;
    printf(&quot;subtotal No.%d: %-6d\tsubaverage No.%d: %-6.2f\n&quot;,i+1,subtotal[i],i+1,subaverage[i]);
  &#125;
&#125;

/*将信息写入文件并保存*/
void WritetoFile(STUDENT stu[],int subtotal[],float subaverage[],int n,int x)
&#123;
  FILE *fp;
  int i,j;
  if((fp=fopen(&quot;score.txt&quot;,&quot;w&quot;))==NULL)/*检验文件是否打开成功*/
  &#123;
    printf(&quot;Failure to open score.txt!\n&quot;);
    exit(0);
  &#125;
  fprintf(fp,&quot;%d\t%d\n&quot;,n,x);
  for(i=0;i&lt;n;i++)
  &#123;
    fprintf(fp,&quot;%-10s\t%-13ld\t%11d\t%13.2f\t&quot;,stu[i].name,stu[i].number,stu[i].stutotal,stu[i].stuaverage);
     for(j=0;j&lt;x;j++)
        &#123;
            fprintf(fp,&quot;%-6d\n&quot;,stu[i].score[j]);
        &#125;
  &#125;
  for(j=0;j&lt;x;j++)
  &#123;
      fprintf(fp,&quot;%d\t%f\n&quot;,subtotal[j],subaverage[j]);
  &#125;
  fclose(fp);
&#125;

/*从文件中读取出信息*/
void ReadfromFile(STUDENT stu[],int subtotal[],float subaverage[],int *n,int *x)
&#123;
  FILE *fp;
  int i,j;
  if((fp=fopen(&quot;score.txt&quot;,&quot;r&quot;))==NULL)/*检验文件是否打开成功*/
  &#123;
    printf(&quot;Failure to open score.txt!\n&quot;);
    exit(0);
  &#125;
   fscanf(fp,&quot;%d\t%d\n&quot;,n,x);
  for(i=0;i&lt;*n;i++)
    &#123;
      fscanf(fp,&quot;%10s&quot;,stu[i].name);
      fscanf(fp,&quot;%13ld&quot;,&amp;stu[i].number);
      fscanf(fp,&quot;%11d&quot;,&amp;stu[i].stutotal);
      fscanf(fp,&quot;%f&quot;,&amp;stu[i].stuaverage);
      for(j=0;j&lt;*x;j++)
      &#123;
        fscanf(fp,&quot;%6d&quot;,&amp;stu[i].score[j]);
      &#125;
    &#125;
    for(j=0;j&lt;*x;j++)
    &#123;
        fscanf(fp,&quot;%d\t%f&quot;,&amp;subtotal[j],&amp;subaverage[j]);
    &#125;
    fclose(fp);
&#125;

int main()
&#123;
    int m,n,x;
    int subtotal[X];
    float subaverage[X];
    STUDENT stu[N];
    do&#123;
        printf(&quot;Input the total number of students:&quot;);
        scanf(&quot;%d&quot;,&amp;n);
        printf(&quot;Input the total number of subjects:&quot;);
        scanf(&quot;%d&quot;,&amp;x);
    &#125;while(n&lt;=0||n&gt;30||x&lt;1||x&gt;6);/*检测学生总人数及学科总数是否符合要求*/
 KG:printf(&quot;\n\n1.Input record\n2.Calculate total and average score of every course\n3.Calculate total and average score of every student\n&quot;);
      printf(&quot;4.Sort in descending order by total score of every student\n5.Sort in ascending order by total score of every student\n&quot;);
      printf(&quot;6.Sort in ascending order by number\n7.Sort in dictionary order by name\n8.Search by number\n&quot;);
      printf(&quot;9.Search by name\n10.Statistic analysis for every course\n11.List record\n&quot;);
      printf(&quot;12.Write to a file\n13.Read from a file\n0.Exit\n\nPlease enter your choice:&quot;);
      scanf(&quot;%d&quot;,&amp;m);/*打印出菜单栏以供用户选择操作*/
    switch(m)/*利用switch语句实现菜单中的各个功能*/
    &#123;
      case 1: Input(stu,n,x);
               break;
      case 2: SubCalculate(stu,subtotal,subaverage,n,x);
               break;
      case 3:StuCalculate(stu,n,x);
               break;
      case 4: SortStuScoreUpdown(stu,n);
               Print1(stu,n,x);
              break;
      case 5: SortStuScoreDownup(stu,n);
              Print1(stu,n,x);
             break;
      case 6: SortNumberDownup(stu,n);
              Print1(stu,n,x);
            break;
      case 7: SortName(stu,n);
              Print1(stu,n,x);
            break;
      case 8: SearchNumber(stu,n,x);
            break;
      case 9: SearchName(stu,n,x);
            break;
      case 10: Analysis(stu,n,x);
            break;
      case 11: List(stu,subtotal,subaverage,n,x);
            break;
      case 12:WritetoFile(stu,subtotal,subaverage,n,x);
            break;
      case 13:ReadfromFile(stu,subtotal,subaverage,&amp;n,&amp;x);
                Print1(stu,n,x);
                Print2(subtotal,subaverage,x);
            break;
      case 0: exit(0);
    &#125;
   if(m!=0||m&lt;0||m&gt;13) goto KG;/*检测用户选择是否出错，并利用goto语句实现跳转*/
   return 0;
&#125;
</code></pre>
<p>以上就是该实验的全部代码。（<del>毫无保留，直接裸奔！！！</del> ）</p>
<p><img data-src="/C-CPP/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2.jpg"></p>
<p>实验数据我就不给了吧。</p>
<p><strong>本人王者荣耀迷和KPL迷，实验数据全是英雄名和选手名（说实话，选手们的ID确实好听），估计助教在看实验的时候都笑出猪叫了。（<del>助教笑出猪叫？？？</del> 啪，又来套娃！）</strong></p>
<p>有相同兴趣的小伙伴们可以找我一起观赛掉分。<del>本人厨艺精湛，饭多管饱！！！</del> </p>
<p><img data-src="/C-CPP/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/3.jpg"></p>
<p><strong>敲黑板！！！</strong></p>
<p><strong>如果大佬们不幸看了我的代码，欢迎指导！！！（毕竟这时大一刚学的时候写的，估计bug一堆，很多代码也不是最优的）<br>如果萌新们不幸看了我的代码，欢迎交流！！！（如果你也备受这个实验困扰，希望这篇文章能够帮助到你）</strong></p>
<p><strong>最后，有被学生成绩管理系统和图书馆管理系统折磨过的同仁，举个爪子示意一下，让我知道我并不孤单！</strong></p>
<p><img data-src="/C-CPP/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/Wolf.jpg" alt="Wolf"></p>
]]></content>
      <categories>
        <category>C-CPP</category>
        <category>学生成绩管理系统</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>八股文之操作系统</title>
    <url>/StereotypedWriting/OperatingSystem/</url>
    <content><![CDATA[<h1 id="简要概述一下什么是操作系统？"><a href="#简要概述一下什么是操作系统？" class="headerlink" title="简要概述一下什么是操作系统？"></a>简要概述一下什么是操作系统？</h1><ul>
<li>操作系统是<strong>管理计算机硬件和软件资源</strong>的计算机程序，提供一个计算机用户与计算机硬件系统之间的接口（向上对用户程序提供接口，向下接管硬件资源）。</li>
<li>操作系统本质上也是一个软件，作为最接近硬件的<strong>系统软件，负责处理器管理、存储器管理、设备驱动管理、文件系统管理和提供用户接口。</strong></li>
</ul>
<h1 id="操作系统的分类有哪些？"><a href="#操作系统的分类有哪些？" class="headerlink" title="操作系统的分类有哪些？"></a>操作系统的分类有哪些？</h1><ul>
<li>操作系统一般可分为<strong>批处理操作系统、分时操作系统和实时操作系统。</strong></li>
<li>若一个操作系统兼顾批处理和分时的功能，则称该系统为<strong>通用操作系统</strong>，常见的通用操作系统有：Windows、Linux、MacOS等。</li>
</ul>
<h1 id="什么是内核态和用户态？"><a href="#什么是内核态和用户态？" class="headerlink" title="什么是内核态和用户态？"></a>什么是内核态和用户态？</h1><ul>
<li>为了<strong>避免操作系统和关键数据被用户程序破坏</strong>，将处理器的执行状态分为内核态和用户态。</li>
<li>内核态是操作系统管理程序执行时所处的状态，<strong>能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。</strong></li>
<li>用户态是用户程序执行时处理器所处的状态，<strong>不能执行特权指令，只能访问用户地址空间。</strong></li>
<li>用户程序运行在用户态，操作系统内核运行在内核态。</li>
</ul>
<h1 id="如何实现内核态和用户态的切换？"><a href="#如何实现内核态和用户态的切换？" class="headerlink" title="如何实现内核态和用户态的切换？"></a>如何实现内核态和用户态的切换？</h1><p>处理器从用户态切换到内核态的方法有三种：<strong>系统调用、异常、外部中断。</strong></p>
<ul>
<li>系统调用，操作系统的最小功能单位，是操作系统提供的<strong>用户接口，是软中断。</strong></li>
<li>异常，也叫做<strong>内中断，是由错误引起的</strong>，如文件损坏、缺页故障等。</li>
<li>外部中断，通过两根信号线来通知处理器<strong>外设的状态变化，是硬中断。</strong></li>
</ul>
<h1 id="软中断和硬中断的区别与联系？"><a href="#软中断和硬中断的区别与联系？" class="headerlink" title="软中断和硬中断的区别与联系？"></a>软中断和硬中断的区别与联系？</h1><ul>
<li>硬中断是有<strong>外设硬件</strong>发出的，<strong>需要有中断控制器</strong>的参与。其过程是外设侦测到变化，告知中断控制器，中断控制器通过CPU或内存的中断脚通CPU，然后<strong>硬件</strong>进行程序计数器及堆栈寄存器的现场保存工作（引发上下文切换），并根据中断向量调用<strong>硬中断处理程序</strong>进行中断处理。</li>
<li>软中断则通常是由<strong>硬中断处理程序或者进程调度程序等软件程序</strong>发出的中断信号，<strong>无需中断控制器</strong>的参与，直接以一个CPU指令之形式指示<strong>CPU</strong>进行程序计数器及堆栈寄存器之现场保存工作(亦会引发上下文切换)，并调用相应的<strong>软中断处理程序</strong>进行中断处理(即我们通常所言之系统调用)。</li>
<li>硬中断直接以硬件的方式引发，处理速度快。软中断以软件指令的方式引发，适合于对响应速度要求不是特别严格的场景。</li>
<li>硬中断通过设置 CPU 的屏蔽位可进行屏蔽，软中断则由于是指令之方式给出，不能屏蔽（<strong>硬中断可以被屏蔽，软中断不可以被屏蔽</strong>）。</li>
<li>硬中断和软中断**均会引起上下文切换(进程&#x2F;线程之切换)**，进程切换的过程是差不多的。</li>
</ul>
<h1 id="并发和并行的区别？"><a href="#并发和并行的区别？" class="headerlink" title="并发和并行的区别？"></a>并发和并行的区别？</h1><ul>
<li>并发：宏观上看多个程序在同时运行，比如在单核CPU上的多任务，但微观上看程序的指令是<strong>交替运行</strong>的，<strong>CPU在任何时刻最多只能同时运行一条指令</strong>。</li>
<li>并行：严格意义上的同时运行，比如多核CPU，程序的指令是<strong>同时运行</strong>的，<strong>CPU在任何时刻最多能够同时运行多条指令</strong>。</li>
<li>并发<strong>不能</strong>提高计算机的性能，而并行<strong>能够</strong>提高计算机的性能。</li>
</ul>
<h1 id="什么是进程、线程、协程？"><a href="#什么是进程、线程、协程？" class="headerlink" title="什么是进程、线程、协程？"></a>什么是进程、线程、协程？</h1><ul>
<li>进程：进程是<strong>系统进行资源分配和管理的基本单位</strong>。每个进程都有自己<strong>独立的内存空间</strong>，不同进程之间可以进行通信。由于进程比较重量，占据独立的内存，所以进程上下文的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对来说比较安全。</li>
<li>线程：线程是进程的一个实体，是<strong>CPU调度和分派的基本单位</strong>，它是比进程更小的能够独立运行的单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（栈、寄存器、程序计数器），但是它可<strong>与同属一个进程的其他线程共享进程所拥有的全部资源</strong>。线程间的通信主要通过共享内存，上下文的切换开销比较少，但相比进程不够稳定，容易丢失数据。</li>
<li>协程：协程是<strong>一种用户态的轻量级线程</strong>，协程的<strong>调度完全由用户控制</strong>。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方。在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则<strong>基本没有内核切换的开销，可以不加锁地访问全局变量</strong>，所以上下文的切换非常快。</li>
</ul>
<h1 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a>进程和线程的区别？</h1><ul>
<li><strong>一个程序至少有一个进程，一个进程至少有一个线程。</strong></li>
<li><strong>从系统调度上看：进程是资源分配和管理的基本单位，线程是CPU调度和分派的基本单位。</strong></li>
<li><strong>从上下文切换上看：线程上下文的切换要比进程上下文的切换快得多。</strong></li>
<li><strong>从系统开销上看：创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间、I&#x2F;O设备等，而创建或撤销线程时，系统只需要为之分配或回收少量资源，如栈、寄存器等，所以进程切换的开销要远大于线程切换的开销。</strong></li>
</ul>
<h1 id="协程和线程的区别？"><a href="#协程和线程的区别？" class="headerlink" title="协程和线程的区别？"></a>协程和线程的区别？</h1><ul>
<li>一个线程可以有多个协程，一个进程也可以有多个协程。线程和进程都是同步机制，而协程是异步机制。</li>
<li>协程是由程序自身控制的，没有线程切换的开销，执行效率非常高。</li>
<li>协程不需要多线程的锁机制：在协程中控制共享资源不需要加锁，只需要判断状态即可，所以执行效率比多线程高很多。</li>
<li>线程是抢占式的，而协程是非抢占式的，需要用户释放使用权切换到其他协程，因此同一时间只有一个协程拥有运行权，相当于单线程。</li>
<li>协程不被操作系统内核管理，而完全由程序控制。线程是被分割的CPU资源，协程是组织好的代码流程，线程是协程的资源。但协程不会直接使用线程，协程直接利用的是执行器来关联任意线程或线程池。</li>
</ul>
<h1 id="进程的基本操作有哪些？"><a href="#进程的基本操作有哪些？" class="headerlink" title="进程的基本操作有哪些？"></a>进程的基本操作有哪些？</h1><ul>
<li>fork()创建子进程：<strong>fork()函数调用一次，返回两次，在父进程中返回子进程的PID，而在子进程中返回0</strong>，可以利用这个特点来判断一个进程是父进程还是子进程。<br>（1）新创建子进程几乎但不完全与父进程相同：子进程得到与父进程用户级<strong>虚拟地址空间相同（但是独立的）一份副本</strong>，包括代码和数据段、堆、共享库以及用户栈；子进程还获得与父进程所有<strong>打开文件的描述符相同的一份副本</strong>，这意味着子进程可以读写父进程中任何打开的文件。<br>（2）父进程与子进程最大的区别在于它们的进程ID（PID）不同。</li>
<li>exec()执行新程序：<strong>exec()函数可以替换当前进程的代码，执行一个新的程序，而不是继续执行当前程序</strong>。exec()函数可以接受一个参数，这个参数是一个字符串，表示要执行的新程序的路径，如果参数是一个相对路径，那么它会被解析为当前进程的工作目录下的路径。</li>
<li>wait()等待子进程结束：<strong>wait()函数可以等待子进程结束，并返回子进程的返回值。</strong></li>
<li>waitpid()等待子进程结束：<strong>waitpid()函数可以等待指定的子进程结束，并返回子进程的返回值。</strong></li>
<li>exit()退出当前进程：<strong>exit()函数可以退出当前进程，并返回一个整数。</strong></li>
</ul>
]]></content>
      <categories>
        <category>StereotypedWriting</category>
        <category>OperatingSystem</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>荣耀笔试题</title>
    <url>/WrittenExamination/Honor_20220412/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔试一共三道编程题，分数依次为100、200、300，需要按顺序依次完成，只有做完这一道题，才能进入下一道题，无法跳题，使用的是牛客网，允许跳出界面使用自己的IDE。</p>
<h1 id="题目一：字符串分割"><a href="#题目一：字符串分割" class="headerlink" title="题目一：字符串分割"></a>题目一：字符串分割</h1><p>给定一系列的字符串，字符串的个数为N，每个字符串的长度不超过100。长度小于8的字符串用零补足，长度大于等于8的字符串，按8位位一组的形式不断分割，最后剩余部分用零补足。</p>
<p>输入：</p>
<p>第一行包括一个整数N和N个原始字符串。</p>
<p>输出：</p>
<p>第一行包括分割后的字符串按字典序从小到大排列。</p>
<p>输入示例：</p>
<p>2 abc 123456789</p>
<p>输出示例：</p>
<p>12345678 90000000 abc00000</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这一题比较简单，只需要按照题目的描述做即可。</p>
<pre><code class="python">inp = input().split()
n = int(inp[0])
ls = []
for i in range(1, n+1):
    string = inp[i]
    while len(string) &gt; 8:
        ls.append(string[:8])
        string = string[8:]
    ls.append(string + &quot;0&quot;*(8-len(string)))
ls.sort()
print(&quot; &quot;.join(ls))
</code></pre>
<h1 id="题目二：蜜蜂采蜜"><a href="#题目二：蜜蜂采蜜" class="headerlink" title="题目二：蜜蜂采蜜"></a>题目二：蜜蜂采蜜</h1><p>平原上，一群蜜蜂离开蜂巢采蜜，要连续采集5片花丛后归巢。<br>已知5片花丛相对蜂巢的坐标，请你帮它们规划一下到访花丛的顺序，以使飞行总距离最短。</p>
<p>输入：</p>
<p>以蜂巢为平面坐标原点的5片花丛A、B、C、D、E的坐标，坐标值为整数。</p>
<p>输出：</p>
<p>从出发到返回蜂巢最短路径的长度取整值，取整办法为舍弃小数点后面的值。</p>
<p>输入示例：</p>
<p>200 0 200 10 200 50 200 30 200 25</p>
<p>输出示例：</p>
<p>456</p>
<p>说明：</p>
<p>样例中的10个数，相邻两个分别为一组，表示一个花丛相对蜂巢的坐标：A(x1, y1)、B(x2, y2)、C(x3, y3)、D(x4, y4)、E(x5, y5)，分表代表x1,y1,x2,y2,x3,y3,x4,y4,x5,y5。</p>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>本题实际上是一道旅行商问题（TSP），经典的TSP可以描述为：一个商品推销员要去若干个城市推销商品，该推销员从一个城市出发，需要经过所有城市后，回到出发地。应如何选择行进路线，以使总的行程最短。从图论的角度来看，该问题实质是在一个带权完全无向图中，找一个权值最小的Hamilton回路。由于该问题的可行解是所有顶点的全排列，随着顶点数的增加，会产生组合爆炸，它是一个NP完全问题。</p>
<p>常见的解法有暴力破解、深度优先遍历，动态规划等。</p>
<p>高级的解法有模拟退火算法，遗传算法，粒子群算法、神经网络等</p>
<h2 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h2><p>暴力破解，求出五片花丛所有可能的到访顺序（全排列），取飞行总距离最短的路径即可。</p>
<pre><code class="python">from math import sqrt, floor
from xmlrpc.client import MAXINT
inp = list(map(int, input().split()))
mincost = MAXINT
ls = [(inp[i*2], inp[i*2+1]) for i in range(5)]
matrix = [[0 for i in range(5)] for j in range(5)]
for i in range(5):
    for j in range(5):
        matrix[i][j] = sqrt((ls[i][0]-ls[j][0])**2 + (ls[i][1]-ls[j][1])**2)

def Perm(nums, begin, end):
    global mincost, ls, matrix, path
    if begin &gt;= end:
        cost = 0
        for i in range(4):
            cost += matrix[nums[i]][nums[i+1]]
        cost = cost + sqrt((ls[nums[0]][0]**2) + (ls[nums[0]][1]**2)) + sqrt((ls[nums[-1]][0]**2) + (ls[nums[-1]][1]**2))
        if cost &lt; mincost:
            path = nums
            mincost = cost
        return
    else:
        for num in range(begin, end):
            nums[begin], nums[num] = nums[num], nums[begin]
            Perm(nums, begin+1, end)
            nums[begin], nums[num] = nums[num], nums[begin]

nums = [i for i in range(5)]
Perm(nums, 0, len(nums))
print(floor(mincost))
</code></pre>
<h2 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h2><p>采用深度优先遍历来寻找最短路径，并在遍历过程中通过不断剪枝来简化求解过程，广义上来讲也是全排列的一种。</p>
<pre><code class="python">from math import sqrt, floor
from xmlrpc.client import MAXINT

def DFS(u, cnt, cost):
    global mincost, matrix, visited
    if cost &gt; mincost:
        return
    if cnt == 6:
        cost = cost + sqrt((ls[u][0]**2) + (ls[u][1]**2)) + sqrt((ls[0][0]**2) + (ls[0][1]**2))
        if cost &lt; mincost:
            mincost = cost
    visited[u] = 1
    for v in range(6):
        if not visited[v]:
            DFS(v, cnt+1, cost + matrix[u][v])
    visited[u] = 0

inp = list(map(int, input().split()))
mincost = MAXINT
visited = [0 for i in range(6)]
ls = [(inp[i*2], inp[i*2+1]) for i in range(5)]
ls.insert(0, (0, 0))
matrix = [[0 for i in range(6)] for j in range(6)]
for i in range(6):
    for j in range(6):
        matrix[i][j] = sqrt((ls[i][0]-ls[j][0])**2 + (ls[i][1]-ls[j][1])**2)

DFS(0, 1, 0)
print(floor(mincost))
</code></pre>
<h1 id="惨痛经历"><a href="#惨痛经历" class="headerlink" title="惨痛经历"></a>惨痛经历</h1><p>因为邮件上写着系统开放时间为18:00-21:00（不同于美团写着笔试时间为16:00-18:00），所以我习惯性得以为笔试时间为三个小时，当我悠哉游哉地把第二题做完返回系统时，笔试已经结束了，因此只提交了第一题，直接人麻了。。。所以，各位小伙伴无论是在比赛还是在测试，一定先看好时间！！！当然，对于秒AK的大佬来说，时间根本不是事，那就当我没说。</p>
<p><img data-src="/WrittenExamination/Honor_20220412/Honor_20220412/Wolf.jpg" alt="Wolf"></p>
]]></content>
      <categories>
        <category>WrittenExamination</category>
        <category>Honor_20220412</category>
      </categories>
      <tags>
        <tag>牛客网</tag>
        <tag>荣耀</tag>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>美团笔试题</title>
    <url>/WrittenExamination/MeiTuan_20220409/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔试一共五道编程题（四+一），一为专项编程题，估计不同岗位有题目不一样，使用的是赛码网，允许跳出界面使用自己的IDE。</p>
<p>在此感谢<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlYm9ydHQ/dHlwZT1ibG9n">筱羊冰冰</span>提供的部分题目及题解。</p>
<h1 id="题目一：数圈游戏"><a href="#题目一：数圈游戏" class="headerlink" title="题目一：数圈游戏"></a>题目一：数圈游戏</h1><p>给定一个整数n，计算该整数含有的圆圈个数。数字0-9对应的圈数如下：<br>0: 1<br>1: 0<br>2: 0<br>3: 0<br>4: 0<br>5: 0<br>6: 1<br>7: 0<br>8: 2<br>9: 1</p>
<p>输入：<br>第一行为一个整数n，表示数圈游戏的数字。</p>
<p>输入示例：<br>60498<br>输出示例：<br>5</p>
<p>限制：<br>80%的测试用例：n&lt;&#x3D;10000<br>100%的测试用例：n&lt;&#x3D;100000000</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>该题较为简单，一次遍历累加即可。</p>
<h1 id="题目二：士兵排队"><a href="#题目二：士兵排队" class="headerlink" title="题目二：士兵排队"></a>题目二：士兵排队</h1><p>给定一定数量的士兵，将士兵按照身高从小到大排列，身高相同者按照姓名的字典序从小到大排列。</p>
<p>输入：<br>第一行为一个整数n，表示士兵的数量。<br>第二行为n个士兵的身高，单位为cm。<br>第三行为n个士兵的姓名。</p>
<p>输入示例：<br>4<br>176 170 176 176<br>bamma tom alpha beta</p>
<p>输出示例：<br>tom alpha bamma beta</p>
<p>限制：<br>士兵身高 hi &lt;&#x3D; 300<br>士兵姓名长度 ni &lt;&#x3D; 20</p>
<h2 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h2><p>将每一个人的身高和名字按照 (身高，名字) 的格式存储，然后进行两次排序，先按照身高排序，再按照名字排序即可。（利用了python排序算法的稳定性！）</p>
<pre><code class="python">n = int(input())
heights = list(map(str, input().split()))
names = list(map(str, input().split()))
ls = []
for i in range(n):
    ls.append((heights[i], names[i]))
# lambda函数指定排序规则
ls.sort(key=lambda x:x[1])
ls.sort(key=lambda x:x[0])
for i in range(n):
    print(ls[i][1], end=&#39; &#39;)
</code></pre>
<h2 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h2><p>因为身高的限制为 hi &lt;&#x3D; 300，所以身高最高只能为三位数，那么我们可以把所有身高都通过补前置零的方式化为三位数，然后再与名字拼接成一个字符串，这样只需要一次排序就能够得出结果。</p>
<pre><code class="python">n = int(input())
heights = list(map(str, input().split()))
names = list(map(str, input().split()))
for i in range(n):
    # str.zfill()自动填充
    heights[i] = heights[i].zfill(3) + names[i]
heights.sort()
for i in range(n):
    print(heights[i][3:], end=&#39; &#39;)
</code></pre>
<h1 id="题目三：路径搜索"><a href="#题目三：路径搜索" class="headerlink" title="题目三：路径搜索"></a>题目三：路径搜索</h1><p>给定一个地图，询问是否存在一条从起点到终点的直接通路。注意，通路是双向的。</p>
<p>输入：<br>第一行包括两个整数n和m，分别表示地图上点的数量和通路的数量。<br>第二行包括m个整数，表示地图上通路的一端。<br>第三行包括m个整数，表示地图上通路的另一端。<br>第四行包括k个整数，表示询问的次数。<br>接下来的k行每行包括两个整数，分别表示起点和终点。</p>
<p>输入示例：<br>4 5<br>1 2 1 3 1<br>2 3 3 4 4<br>4<br>1 3<br>2 4<br>2 1<br>3 2</p>
<p>输出示例：<br>Yes<br>No<br>Yes<br>Yes</p>
<h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>筱羊冰冰：上来就看错了，然后花了好久写了类似并查集的东西，然后用不上……<br>（果然大佬就是不一样，上来直接手撕并查集）<br>这道题只需要检查有无指定通路就行了，不过要特别注意查询范围，因为通路是双向的而且要求的是直接通路。</p>
<pre><code class="python">n, m = map(int, input().split())
lsu = list(map(int, input().split()))
lsv = list(map(int, input().split()))
k = int(input())
ways = set((lsu[i], lsv[i]) for i in range(m))
out = []
for _ in range(k):
    u, v = map(int, input().split())
    if (u, v) in ways or (v, u) in ways:
        out.append(&#39;Yes&#39;)
    else:
        out.append(&#39;No&#39;)
print(&#39;\n&#39;.join(out))
</code></pre>
<h1 id="题目四：井字棋"><a href="#题目四：井字棋" class="headerlink" title="题目四：井字棋"></a>题目四：井字棋</h1><p>给定一个2x2的棋盘和n中不同的颜色，要求每行每列均不能出现相同的颜色，计算总共有多少种填充方案。</p>
<p>输入：<br>第一行包括一个整数n，表示颜色的数量。</p>
<p>输出：<br>输出一个整数，表示有多少种填充方案。</p>
<p>输入示例：<br>2</p>
<p>输出示例：<br>2</p>
<p>限制：<br>颜色的种类n &lt;&#x3D; 10</p>
<h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><p>筱羊冰冰：有一说一，感觉就属这个题有意思吧。我当时看完，感觉就有一点像排列组合(业余玩家，不太清楚具体的类型)。<br>n种颜色，如果颜色足够(指大于四种)，我们其实也只能取出四种来操作，所以只需要一个<br>$$<br>C_n^4<br>$$<br>所以我们其实只需要考虑四种以内的情况。</p>
<p>两种颜色：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>和</th>
<th>2</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>1</td>
<td></td>
<td>1</td>
<td>2</td>
</tr>
</tbody></table>
<p>三种颜色：<br>我们自然可以想到，拿两种颜色就可以填上面的两种<br>$$<br>C_3^2 * 2<br>$$<br>然后，如果是三种颜色都要，有12种，肯定是有一个重复的，那么对角线重复就有两种情况，剩下的其实就是将三个数字填入三个位置，<br>$$<br>A_3^3<br>$$<br>就是6 + 6*2 &#x3D; 18。</p>
<p>到这里其实就应该明白了，我们只需要知道 i 种颜色有多少种即可，因为 i &#x3D; 2, 3, 4，我们完全可以直接写出来，剩下的就是一个组合问题，再给出一个阶乘列表。</p>
<pre><code class="python"># ls[i]为i种颜色都使用，对应的可能数
# 四种颜色忘了说了，不过就是个A44
ls = [0, 0, 2, 12, 24]
# ls_jc[i] = i!
ls_jc = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]
ret = 0
n = int(input())
if n &lt;= 1:
    # 他在系统公告中，提示了0的问题
    ret = 0
elif n &lt;= 4:
    for i in range(2, n+1):
        ret += ls[i] * ls_jc[n] // (ls_jc[i] * ls_jc[n-i])
        # 还有一个限制就是输出大小，这里原题目是有的
        ret %= 1000000007
else:
    for i in range(2, 5):
        ret += ls[i] * ls_jc[n] // (ls_jc[i] * ls_jc[n-i])
        ret %= 1000000007
print(ret)
</code></pre>
<h2 id="小插曲："><a href="#小插曲：" class="headerlink" title="小插曲："></a>小插曲：</h2><p>当时有一块写错了，然后跑出来只有27%，自己就去看了一下范围是小于等于十，那么案例至少有10个吧。<br>然后自己因为有边界检测，负数、0、1、2都能正确，那么至少对三个，反推出案例应该是11个，那么就是3往上有问题，所以将矛头对准了ls[3]，果然是算少了，改成12，啪的一下，很快就过了……</p>
<h1 id="题目五：堆积木"><a href="#题目五：堆积木" class="headerlink" title="题目五：堆积木"></a>题目五：堆积木</h1><p>给定一个已有的字符串和一个目标字符串，可以从右边删除一个字符，也可以往左边插入一个字符，删除和插入操作的次数没有限制，问最少操作多少次可以使已有字符串变成目标字符串。</p>
<table>
<thead>
<tr>
<th>输入</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>原串长度</td>
</tr>
<tr>
<td>1 5 3 4 6</td>
<td>原串</td>
</tr>
<tr>
<td>5</td>
<td>目标串长度</td>
</tr>
<tr>
<td>2 1 5 3 4</td>
<td>目标串</td>
</tr>
</tbody></table>
<h2 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h2><p>筱羊冰冰：这个题，其实看明白了就没那么难，其实就是找最长公共子序列。</p>
<pre><code class="python">from collections import deque
l_old = int(input())
old = input().split()
l_new = int(input())
new = input().split()
length = 0
# 这里没啥原因，就是deque的头插尾插都比较快，O(1)的
s1, s2 = deque(), deque()
judge = 0
while True:
    s1.append(old[length])
    s2.appendleft(new[-length-1])
    length += 1
    if s1 == s2:
        judge = 1
        break
    elif length == min(l_old, l_new):
        break
if judge:
    print(l_old+l_new - length*2)
else:
    print(l_old+l_new)
</code></pre>
<h2 id="重大失误"><a href="#重大失误" class="headerlink" title="重大失误"></a>重大失误</h2><p>上面的代码其实没考虑，如果有多对子串相同，要找出最长的……<br>不过感觉测试案例比较拉，所以显示还是ac了的。</p>
<p><img data-src="/WrittenExamination/MeiTuan_20220409/MeiTuan_20220409/Wolf.jpg" alt="Wolf"></p>
]]></content>
      <categories>
        <category>WrittenExamination</category>
        <category>MeiTuan_20220409</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
        <tag>赛码网</tag>
        <tag>美团</tag>
      </tags>
  </entry>
</search>
