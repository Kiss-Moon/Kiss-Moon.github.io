{
    "version": "https://jsonfeed.org/version/1",
    "title": "Keep Coding",
    "subtitle": "",
    "icon": "https://www.liangmeng.xyz/images/favicon.ico",
    "description": "花落微凉梦清幽",
    "home_page_url": "https://www.liangmeng.xyz",
    "items": [
        {
            "id": "https://www.liangmeng.xyz/ComputerNetwork/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/",
            "url": "https://www.liangmeng.xyz/ComputerNetwork/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/",
            "title": "计算机网络的基本概念",
            "date_published": "2022-04-26T13:47:00.000Z",
            "content_html": "",
            "tags": [
                "计算机网络",
                "计算机网络的基本概念",
                "笔记",
                "计算机网络"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/WrittenExamination/Tencent_20220424/",
            "url": "https://www.liangmeng.xyz/WrittenExamination/Tencent_20220424/",
            "title": "腾讯20220424",
            "date_published": "2022-04-25T18:00:00.000Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>笔试一共五道编程题，满分是100分，时间是两个小时，可以跳题，使用的平台是牛客网，允许跳出界面使用本地IDE。</p>\n<h1 id=\"题目一：构建数字\"><a href=\"#题目一：构建数字\" class=\"headerlink\" title=\"题目一：构建数字\"></a>题目一：构建数字</h1><p>给定n个长度均为m的数字字符串，从上往下构建成m个新的数，去掉前置0后按照从小到大的顺序输出。</p>\n<p>输入：</p>\n<p>第一行包括一个整数n。</p>\n<p>接下来n行每行包括一个长度为m的数字字符串。</p>\n<p>输出：</p>\n<p>第一行包括新构建的数按从小到大排列。</p>\n<p>输入示例：</p>\n<p>3</p>\n<p>0121</p>\n<p>1502</p>\n<p>2138</p>\n<p>输出示例：</p>\n<p>12 128 151 203</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>该题比较简单，可以直接暴力求解，需要注意的是前置0的处理。</p>\n<pre><code class=\"python\">n = int(input())\nnums = []\nfor i in range(n):\n    num = input()\n    nums.append(num)\n\nans = []\nfor i in range(len(nums[0])):\n    a = &quot;&quot;\n    for j in range(n):\n        a += nums[j][i]\n    # int()函数会直接去掉前置0\n    ans.append(int(a))\n\nans.sort()\nfor i in range(len(ans)):\n    print(ans[i], end=&quot; &quot;)\n</code></pre>\n<h1 id=\"题目二：淘汰数字\"><a href=\"#题目二：淘汰数字\" class=\"headerlink\" title=\"题目二：淘汰数字\"></a>题目二：淘汰数字</h1><p>给定一个数组，下标从1~n，每次淘汰下标为非质数的数字，剩下的数形成新的数组，重复上述过程，直到数组内只剩下一个数字。</p>\n<p><strong>本题为核心代码模式，只需要补充解法类的实现代码即可。</strong></p>\n<p>输入：</p>\n<p>第一行包括一个长度为n的数组。</p>\n<p>输出：</p>\n<p>第一行包括一个整数。</p>\n<p>输入示例1：</p>\n<p>[1, 2, 3, 4]</p>\n<p>输出示例1：</p>\n<p>3</p>\n<p>输入示例2：</p>\n<p>[3, 1 , 1 , 4 , 5, 6]</p>\n<p>输出示例2：</p>\n<p>5</p>\n<h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>本题也是直接暴力求解，重点是求出n内的所有质数。</p>\n<pre><code class=\"python\">from math import sqrt, ceil\nclass Solution:\n    def isP(self, x):\n        m = ceil(sqrt(x))+1\n        for j in range(2, m):\n            if x%j == 0:\n                return False\n        return True\n\n    def getNumber(self , a):\n        # write code here\n        n = len(a)\n        pnums = [2]\n        for i in range(3, n):\n            if self.isP(i):\n                pnums.append(i)\n        while n != 1:\n            k = 0\n            for i in range(len(pnums)):\n                if pnums[i] &gt; n:\n                    break\n                a[k] = a[pnums[i]-1]\n                k += 1\n            n = k\n        return a[0]\n    \na = [1,2,3,4] # [3,1,1,4,5,6]\nprint(Solution().getNumber(a))\n</code></pre>\n<h1 id=\"题目三：士兵分配\"><a href=\"#题目三：士兵分配\" class=\"headerlink\" title=\"题目三：士兵分配\"></a>题目三：士兵分配</h1><p>给定一定数量的士兵，编号为1<del>n，用长度为n的0&#x2F;1串s表示，其中0代表该士兵只会进攻，1代表该士兵只会防御，且其攻击力或防御力等于其编号。将士兵分组，编号为1</del>pos的士兵为进攻组，该组的攻击力之和用w表示，编号为pos+1~n的士兵为防御组，该组的防御力之和用v表示，求|w-v|的最小值。注意：pos可以取0，当pos取0时，表示将所有士兵分到防御组，而进攻组没有士兵。</p>\n<p>输入：</p>\n<p>第一行包括一个整数n，表示士兵的数量。</p>\n<p>第二行包括一个0&#x2F;1字符串s，表示士兵的状态。</p>\n<p>输出：</p>\n<p>第一行包括一个整数，表示|w-v|的最小值。</p>\n<p>输入示例1：</p>\n<p>4</p>\n<p>0011</p>\n<p>输出示例1：</p>\n<p>1</p>\n<p>输入示例2：</p>\n<p>7</p>\n<p>1000101</p>\n<p>输出示例2：</p>\n<p>2</p>\n<h2 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>思路一：暴力求解。遍历整个字符串，在每一个位置对其进行分割，得到左右两个子串，然后分别统计左右两边的攻击力或防御力，与此同时不断刷新差值绝对值的最小值。这种方法的算法复杂度较高，无法AC。</p>\n<p>思路二：逐个分配。可以先假设所有的士兵都在右边，左边没有士兵，即pos为0的情况，此时w和v均可知。然后遍历整个字符串，将士兵逐个从右边分配到左边，如果分配的士兵为0，那么w加上该士兵的编号，v不变；如果分配的士兵为1，那么v减去该士兵的编号，w不变，与此同时不断刷新差值绝对值的最小值即可。</p>\n<p>以下为思路二的代码：</p>\n<pre><code class=\"python\">n = int(input())\ns = input()\n# 因为编号为1~n，且pos的取值范围为0~n\n# 所以添加两个占位符可以简化问题的求解过程\ns = &quot;-&quot; + s + &quot;-&quot;\nw = 0\nv = 0\nfor i in range(n+2):\n    if s[i] == &quot;1&quot;:\n        v += i\nres = v\nfor i in range(n+2):\n    if s[i] == &quot;0&quot;:\n        w += i\n    if s[i] == &quot;1&quot;:\n        v -= i\n    res = min(res, abs(w-v))\nprint(res)\n</code></pre>\n<h1 id=\"题目四：合并链表\"><a href=\"#题目四：合并链表\" class=\"headerlink\" title=\"题目四：合并链表\"></a>题目四：合并链表</h1><p>给出一个链表数组，该链表数组均是某一个环状链表的一部分，请将这些链表组合并成环状链表，然后需要找到一个位置，使得从这个位置将环切开后，按照顺序或逆序遍历这个环，形成的链字典序尽量小，并返回这条链。</p>\n<ul>\n<li><p>链表字典序的定义：对于两个链表a、b，从头节点到尾节点遍历，找到第一个不相同的节点值并比较大小，如果a[i].val &lt; b[i].val，则认为a的字典序小于b的字典序。例如：链表{1,2,3} &lt; 链表{1,2,4},     链表{3,4,5} &lt; 链表{6,7}。</p>\n</li>\n<li><p>环状链表不存在相同的节点值。  </p>\n</li>\n<li><p>该题环状链表节点个数最小为2  </p>\n</li>\n<li><p>每个链表都是在环状链表上的顺时针的一部分。  </p>\n</li>\n<li><p>给定的链表数组一定能组成一个环状链表。</p>\n</li>\n</ul>\n<p>输入示例1：</p>\n<p>[{1, 2, 3}, {2, 3, 4}, {4, 1}]</p>\n<p>输出示例1：</p>\n<p>{1, 2, 3, 4}</p>\n<p>输入示例2：</p>\n<p>[{3, 7, 4}, {7, 4, 5, 1, 10, 3}]</p>\n<p>输出示例2：</p>\n<p>{1, 5, 4, 7, 3, 10}</p>\n<h2 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>用字典存每个下标的前驱和后继，即可还原环状链表。接下来考虑切口位置，可将其转化为确定头节点和遍历方向的问题。要使字典序最小，那么头节点必须是链表里面的最小值（确定头节点），而下一节点为头节点的前驱节点和后继节点中较小的一个（确定遍历方向）。</p>\n<p>本题的解法并不难，难的是如何处理输入，将其合并成一个环状链表。系统中采用的核心代码模式，只需补充解法类的实现代码即可，这里给出的是完整代码。</p>\n<pre><code class=\"python\">from re import compile\nfrom xmlrpc.client import MAXINT\ninp = input()\nlss = compile(&#39;\\d+&#39;).findall(inp)\nring = dict()\nhead = MAXINT\nfor i in range(len(lss)-1):\n    ring[int(lss[i])] = int(lss[i+1])\n    head = min(head, int(lss[i]))\n\nrering = &#123;v : k for k, v in ring.items()&#125;\npre = rering[head]\nnex = ring[head]\nres = &#39;&#123;&#39; + str(head) + &#39;,&#39;\nif pre &lt; nex:\n    for i in range(len(rering)-1):\n        res += str(rering[head]) + &#39;,&#39;\n        head = rering[head]\nif pre &gt; nex:\n    for i in range(len(ring)-1):\n        res += str(ring[head]) + &#39;,&#39;\n        head = ring[head]\nprint(res[:-1] + &#39;&#125;&#39;)\n</code></pre>\n<h1 id=\"题目五：买卖股票\"><a href=\"#题目五：买卖股票\" class=\"headerlink\" title=\"题目五：买卖股票\"></a>题目五：买卖股票</h1><p>现在有一个长度为n的价格数组a，表示某只股票每天的价格。每天最多可以买入或卖出该只股票的一股，买入或者卖出没有手续费，且卖出股票前必须手里已经有股票才能卖出，但是持有的股票数目不受限制，并且初始资金为m元，在任何时刻都不能进行透支，即资金必须始终大于等于0。请问在n天结束之后，拥有的最大总资产是多少？其中总资产 &#x3D; 股票数目 * 股票价格 + 现金。</p>\n<p>输入：</p>\n<p>第一行包括两个整数n和m，分别表示天数和初始资金。</p>\n<p>第二行包括n个整数，分别表示该只股票每天的价格。</p>\n<p>输入示例：</p>\n<p>6 2</p>\n<p>2 3 1 1 1 2</p>\n<p>输出示例：</p>\n<p>6</p>\n<h2 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>动态规划，01背包的变种。定义dp[i][j]代表前i天，手上当前持有j只股票的最大现金数，那么可以根据每天选择买入还是卖出达成转移。</p>\n<pre><code class=\"python\">n, m = map(int, input().split())\nprices = list(map(int, input().split()))\nprices.insert(0, -1e16)\ndp = [[-1e16 for i in range(n+2)] for j in range(n+2)]\ndp[0][0] = m\nfor i in range(1, n+1):\n    for j in range(n+1):\n        # 今天不买不卖的情况\n        nodo = dp[i-1][j]\n        # 今天买入一股的情况\n        buy = -1e16\n        if j &gt; 0 and dp[i-1][j-1] &gt;= prices[i]:\n            buy = dp[i-1][j-1]-prices[i]\n        # 昨天卖出一股的情况\n        sell = dp[i-1][j+1]+prices[i]\n        # 取资金数目最大的一种\n        dp[i][j] = max(nodo, buy, sell)\n\n\nres = -1e16\nfor i in range(n+1):\n    res = max(res, dp[n][i] + i*prices[n])\n\nprint(res)\n</code></pre>\n<p><img data-src=\"/WrittenExamination/Tencent_20220424/Tencent_20220424/Wolf.jpg\" alt=\"Wolf\"></p>\n",
            "tags": [
                "企业笔试",
                "腾讯笔试题",
                "算法",
                "牛客网",
                "笔试",
                "腾讯"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/ArtificialIntelligence/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/",
            "url": "https://www.liangmeng.xyz/ArtificialIntelligence/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/",
            "title": "第一章-人工智能的概述",
            "date_published": "2022-04-23T09:19:00.000Z",
            "content_html": "<h1 id=\"人工智能概述\"><a href=\"#人工智能概述\" class=\"headerlink\" title=\"人工智能概述\"></a>人工智能概述</h1><h2 id=\"人工智能的定义\"><a href=\"#人工智能的定义\" class=\"headerlink\" title=\"人工智能的定义\"></a>人工智能的定义</h2><h3 id=\"什么是智能\"><a href=\"#什么是智能\" class=\"headerlink\" title=\"什么是智能\"></a>什么是智能</h3><ul>\n<li>自然智能：指人类和一些动物所具有的智力和行为能力。</li>\n<li>人类的自然智能（简称智能）：指人类在认识客观世界中，由思维过程和脑力活动所表现出的综合能力。</li>\n</ul>\n<h3 id=\"智能的不同观点\"><a href=\"#智能的不同观点\" class=\"headerlink\" title=\"智能的不同观点\"></a>智能的不同观点</h3><ul>\n<li>思维理论：<strong>智能来源于思维活动，智能的核心是思维，人的一切知识都是思维的产物</strong>。可望通过对思维规律和思维方法的研究来揭示智能的本质。</li>\n<li>知识阈值理论：<strong>智能取决于知识的数量及其可运用程度</strong>。一个系统所具有的可运用知识越多，其智能就会越高。</li>\n<li>进化理论：智能取决于感知和行为，取决于对外界复杂环境的适应，智能不需要知识、不需要表示、不需要推理，<strong>智能可由逐步进化来实现</strong>。（MIT，Brooks，人造机器虫研究）</li>\n</ul>\n<h3 id=\"智能的层次结构\"><a href=\"#智能的层次结构\" class=\"headerlink\" title=\"智能的层次结构\"></a>智能的层次结构</h3><ul>\n<li>高层智能：以大脑皮层（抑制中枢）为主，主要完成记忆、思维等活动。</li>\n<li>中层智能：以丘脑（间脑，感觉中枢）为主，主要完成感知活动。</li>\n<li>低层智能：以小脑、脊髓为主，主要完成动作反应活动。</li>\n<li><strong>思维理论和知识阈值理论对应高层智能，而进化理论对应中层智能和低层智能</strong>。</li>\n</ul>\n<h3 id=\"智能包含的能力\"><a href=\"#智能包含的能力\" class=\"headerlink\" title=\"智能包含的能力\"></a>智能包含的能力</h3><ul>\n<li><p>感知能力：<strong>人类获得外界信息的基本途径</strong>。</p>\n<p>感知–动作方式：对简单、紧急的信息。</p>\n<p>感知–思维–动作方式：对复杂的信息。</p>\n</li>\n<li><p>记忆和思维的能力：</p>\n<p>记忆：对感知到的外界信息和由思维产生的内部知识的<strong>存储</strong>过程。</p>\n<p>思维：对已存储信息或知识的本质属性、内部规律的<strong>认识</strong>过程。</p>\n<p>思维方式：</p>\n<ul>\n<li>抽象思维（逻辑思维）：根据<strong>逻辑规则</strong>对信息和知识进行处理的理性思维方式。</li>\n<li>形象思维（直感思维）：根据<strong>感性形象认识材料</strong>对客观现象进行处理的一种思维方式。</li>\n<li>灵感思维（顿悟思维）：是一种显意识和潜意识相互作用的思维方式。</li>\n</ul>\n</li>\n<li><p>学习和自适应能力：</p>\n<p>学习：<strong>是一个具有特定目的的知识获取过程，是人的一种本能</strong>。不同人的学习方法、能力不同。</p>\n<p>自适应：<strong>是一种通过自我调节适应外界环境的过程，是人的一种本能</strong>。不同人的适应能力不同。</p>\n</li>\n<li><p>行为能力：<strong>对感知的外界信息做出动作反应的能力</strong>。</p>\n<p>信息来源：由感知直接获得的外界信息或经过思维加工后的信息。</p>\n<p>实现过程’：通过脊髓来控制，由语言、表情、体姿等来实现。</p>\n</li>\n</ul>\n<h3 id=\"什么是人工智能\"><a href=\"#什么是人工智能\" class=\"headerlink\" title=\"什么是人工智能\"></a>什么是人工智能</h3><ul>\n<li>学科的名称。</li>\n<li>人工方法实现的智能。</li>\n<li>计算机模拟实现的智能。</li>\n<li>人造的智能机器或系统。</li>\n<li>模仿、延伸以及扩展人的智能。</li>\n</ul>\n<h3 id=\"人工智能典型的4种定义方法\"><a href=\"#人工智能典型的4种定义方法\" class=\"headerlink\" title=\"人工智能典型的4种定义方法\"></a>人工智能典型的4种定义方法</h3><ul>\n<li>类人思维方法（认知模型方法）：1978年贝尔曼，人工智能是那些与人的思维、决策、问题求解和学习等有关活动的自动化。</li>\n<li>类人行为方法（图灵测试方法）：1990年库兹韦勒，人工智能是一种创建机器的技艺，这种机器能够执行需要人的智能才能完成的功能。</li>\n<li>理性思维方法（思维法则方法）：1985年查尼艾克、麦克德莫特，人工智能是通过计算模型来进行心智能力研究的。</li>\n<li>理性行为方法（理性智能体方法）：1998年尼尔森，人工智能关心的是人工制品种的智能行为，即人工智能就是研究和建造理性智能体。</li>\n<li><strong>理性思维方法与理性行为方法的关系：</strong><ul>\n<li>前者强调正确思维，后者强调合理行动。</li>\n<li>理性行为可以依据理性思维进行。</li>\n<li>理性行为不一定要依据理性思维进行。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"人工智能的一般解释\"><a href=\"#人工智能的一般解释\" class=\"headerlink\" title=\"人工智能的一般解释\"></a>人工智能的一般解释</h3><ul>\n<li>从能力的角度：人工智能是指<strong>用人工的方法在机器上实现的智能</strong>，是智能机器所执行的通常与人类智能有关的功能，如判断、推理、证明、识别、感知、理解、设计、思考、规划、学习和问题求解等思维活动。</li>\n<li>从学科的角度：人工智能是<strong>一门研究如何构造智能机器或智能系统，去模拟、延伸和扩展人类智能的学科</strong>，是计算机科学中涉及研究、设计和应用智能机器的一个分支。</li>\n</ul>\n<h3 id=\"人工智能的研究目标\"><a href=\"#人工智能的研究目标\" class=\"headerlink\" title=\"人工智能的研究目标\"></a>人工智能的研究目标</h3><ul>\n<li><p>1978年斯洛曼，三个主要目标：</p>\n<ul>\n<li><p>对智能行为有效解释的理论分析。</p>\n</li>\n<li><p>解释人类智能。</p>\n</li>\n<li><p>构造具有智能的人工制品。</p>\n</li>\n</ul>\n</li>\n<li><p>远期目标：<strong>用自动机重现人类的思维过程和智能行为</strong>。</p>\n<p>揭示人类智能的根本机理，用智能机器去模拟、延伸和扩展人类的智能。涉及到脑科学、认知科学、计算机科学、系统科学、控制论等多种学科，并依赖于它们的共同发展。</p>\n</li>\n<li><p>近期目标：<strong>建造智能计算机代替人类的部分智力劳动</strong>。</p>\n<p>研究如何使现有的计算机更聪明，即使它能够运用知识去处理问题，能够模拟人类的智能行为。</p>\n</li>\n<li><p><strong>远期目标和近期目标的相互关系：</strong></p>\n<ul>\n<li>远期目标为近期目标指明了方向。</li>\n<li>近期目标则为远期目标奠定了理论和技术基础。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"人工智能的发展简史\"><a href=\"#人工智能的发展简史\" class=\"headerlink\" title=\"人工智能的发展简史\"></a>人工智能的发展简史</h2><h3 id=\"简史总结\"><a href=\"#简史总结\" class=\"headerlink\" title=\"简史总结\"></a>简史总结</h3><p><img data-src=\"/ArtificialIntelligence/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/1.png\" alt=\"1\"></p>\n<h2 id=\"人工智能的研究内容\"><a href=\"#人工智能的研究内容\" class=\"headerlink\" title=\"人工智能的研究内容\"></a>人工智能的研究内容</h2><h3 id=\"研究内容\"><a href=\"#研究内容\" class=\"headerlink\" title=\"研究内容\"></a>研究内容</h3><ul>\n<li>如何获取知识？</li>\n<li>如何将获取的知识以计算机内部代码形式加以合理表示？</li>\n<li>如何运用知识进行推理，解决实际问题？</li>\n</ul>\n<h2 id=\"人工智能研究方法与途径\"><a href=\"#人工智能研究方法与途径\" class=\"headerlink\" title=\"人工智能研究方法与途径\"></a>人工智能研究方法与途径</h2><h3 id=\"三大学派\"><a href=\"#三大学派\" class=\"headerlink\" title=\"三大学派\"></a>三大学派</h3><ul>\n<li>符号主义：运用计算机科学的方法（逻辑演绎）。<ul>\n<li>智能的基础是<strong>知识</strong>，其核心是<strong>知识表示和知识推理</strong>。</li>\n<li><strong>知识可用符号表示，也可用符号进行推理</strong>，因而可以建立基于知识的人类智能和机器智能的统一的理论体系。</li>\n<li><strong>功能模拟，构造能够模拟大脑功能的智能系统</strong>。</li>\n</ul>\n</li>\n<li>联结主义：运用仿生学的方法（网络连接机制）。<ul>\n<li>智能行为的基元是<strong>神经元</strong>，而不是符号。</li>\n<li>思维过程是<strong>神经元的联结活动过程</strong>，而不是符号运算过程，反对符号主义关于物理符号系统的假设。</li>\n<li><strong>结构模拟，构造模拟大脑结构的神经网络系统</strong>。</li>\n</ul>\n</li>\n<li>行为主义：运用进化论的思想（控制论和机器学习方法）。<ul>\n<li>智能取决于<strong>感知和行动</strong>，即“感知-动作”模型。</li>\n<li>智能不需要知识、不需要表示、不需要推理，人工智能可以像人类智能那样<strong>逐步进化</strong>。</li>\n<li><strong>行为模拟，构造具有进化能力的智能系统</strong>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"人工智能的研究领域\"><a href=\"#人工智能的研究领域\" class=\"headerlink\" title=\"人工智能的研究领域\"></a>人工智能的研究领域</h2><h3 id=\"研究领域\"><a href=\"#研究领域\" class=\"headerlink\" title=\"研究领域\"></a>研究领域</h3><ul>\n<li>机器思维：<strong>推理（确定性推理、不确定性推理）和搜索（状态空间搜索、与&#x2F;或树搜索、博弈树搜索）</strong>。</li>\n<li>机器感知：计算机视觉、模式识别和自然语言处理。</li>\n<li>机器行为：智能控制&#x2F;制造。</li>\n<li>机器学习：符号学习和神经学习。</li>\n<li>计算智能：神经计算、进化计算和模糊计算。</li>\n<li>分布智能：并行求解。</li>\n<li>智能系统：专家系统和智能决策支持系统。</li>\n</ul>\n<h2 id=\"人工智能的研究现状与发展方向\"><a href=\"#人工智能的研究现状与发展方向\" class=\"headerlink\" title=\"人工智能的研究现状与发展方向\"></a>人工智能的研究现状与发展方向</h2><h3 id=\"研究现状\"><a href=\"#研究现状\" class=\"headerlink\" title=\"研究现状\"></a>研究现状</h3><ul>\n<li>多学科交叉研究</li>\n<li>多学派和多技术融合研究</li>\n<li>分布智能研究</li>\n<li>群体智能研究</li>\n<li>社会智能研究</li>\n<li>集成智能研究</li>\n<li>认知计算与情感计算研究</li>\n<li>智能系统与智能服务</li>\n</ul>\n<h3 id=\"发展方向\"><a href=\"#发展方向\" class=\"headerlink\" title=\"发展方向\"></a>发展方向</h3><ul>\n<li>知识 + 数据 + 算法 + 算力。</li>\n</ul>\n<p><img data-src=\"/ArtificialIntelligence/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%A6%82%E8%BF%B0/Wolf.jpg\" alt=\"Wolf\"></p>\n",
            "tags": [
                "人工智能",
                "第一章-人工智能的概述",
                "笔记",
                "人工智能"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/StereotypedWriting/OperatingSystem/",
            "url": "https://www.liangmeng.xyz/StereotypedWriting/OperatingSystem/",
            "title": "计算机八股文之操作系统",
            "date_published": "2022-04-14T16:00:00.000Z",
            "content_html": "<h1 id=\"简要概述一下什么是操作系统？\"><a href=\"#简要概述一下什么是操作系统？\" class=\"headerlink\" title=\"简要概述一下什么是操作系统？\"></a>简要概述一下什么是操作系统？</h1><ul>\n<li>操作系统是<strong>管理计算机硬件和软件资源</strong>的计算机程序，提供一个计算机用户与计算机硬件系统之间的接口（向上对用户程序提供接口，向下接管硬件资源）。</li>\n<li>操作系统本质上也是一个软件，作为最接近硬件的<strong>系统软件，负责处理器管理、存储器管理、设备驱动管理、文件系统管理和提供用户接口。</strong></li>\n</ul>\n<h1 id=\"操作系统的分类有哪些？\"><a href=\"#操作系统的分类有哪些？\" class=\"headerlink\" title=\"操作系统的分类有哪些？\"></a>操作系统的分类有哪些？</h1><ul>\n<li>操作系统一般可分为<strong>批处理操作系统、分时操作系统和实时操作系统。</strong></li>\n<li>若一个操作系统兼顾批处理和分时的功能，则称该系统为<strong>通用操作系统</strong>，常见的通用操作系统有：Windows、Linux、MacOS等。</li>\n</ul>\n<h1 id=\"什么是内核态和用户态？\"><a href=\"#什么是内核态和用户态？\" class=\"headerlink\" title=\"什么是内核态和用户态？\"></a>什么是内核态和用户态？</h1><ul>\n<li>为了<strong>避免操作系统和关键数据被用户程序破坏</strong>，将处理器的执行状态分为内核态和用户态。</li>\n<li>内核态是操作系统管理程序执行时所处的状态，<strong>能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。</strong></li>\n<li>用户态是用户程序执行时处理器所处的状态，<strong>不能执行特权指令，只能访问用户地址空间。</strong></li>\n<li>用户程序运行在用户态，操作系统内核运行在内核态。</li>\n</ul>\n<h1 id=\"如何实现内核态和用户态的切换？\"><a href=\"#如何实现内核态和用户态的切换？\" class=\"headerlink\" title=\"如何实现内核态和用户态的切换？\"></a>如何实现内核态和用户态的切换？</h1><p>处理器从用户态切换到内核态的方法有三种：<strong>系统调用、异常、外部中断。</strong></p>\n<ul>\n<li>系统调用，操作系统的最小功能单位，是操作系统提供的<strong>用户接口，是软中断。</strong></li>\n<li>异常，也叫做<strong>内中断，是由错误引起的</strong>，如文件损坏、缺页故障等。</li>\n<li>外部中断，通过两根信号线来通知处理器<strong>外设的状态变化，是硬中断。</strong></li>\n</ul>\n<h1 id=\"软中断和硬中断的区别与联系？\"><a href=\"#软中断和硬中断的区别与联系？\" class=\"headerlink\" title=\"软中断和硬中断的区别与联系？\"></a>软中断和硬中断的区别与联系？</h1><ul>\n<li>硬中断是有<strong>外设硬件</strong>发出的，<strong>需要有中断控制器</strong>的参与。其过程是外设侦测到变化，告知中断控制器，中断控制器通过CPU或内存的中断脚通CPU，然后<strong>硬件</strong>进行程序计数器及堆栈寄存器的现场保存工作（引发上下文切换），并根据中断向量调用<strong>硬中断处理程序</strong>进行中断处理。</li>\n<li>软中断则通常是由<strong>硬中断处理程序或者进程调度程序等软件程序</strong>发出的中断信号，<strong>无需中断控制器</strong>的参与，直接以一个CPU指令之形式指示<strong>CPU</strong>进行程序计数器及堆栈寄存器之现场保存工作(亦会引发上下文切换)，并调用相应的<strong>软中断处理程序</strong>进行中断处理(即我们通常所言之系统调用)。</li>\n<li>硬中断直接以硬件的方式引发，处理速度快。软中断以软件指令的方式引发，适合于对响应速度要求不是特别严格的场景。</li>\n<li>硬中断通过设置 CPU 的屏蔽位可进行屏蔽，软中断则由于是指令之方式给出，不能屏蔽（<strong>硬中断可以被屏蔽，软中断不可以被屏蔽</strong>）。</li>\n<li>硬中断和软中断**均会引起上下文切换(进程&#x2F;线程之切换)**，进程切换的过程是差不多的。</li>\n</ul>\n<h1 id=\"并发和并行的区别？\"><a href=\"#并发和并行的区别？\" class=\"headerlink\" title=\"并发和并行的区别？\"></a>并发和并行的区别？</h1><ul>\n<li>并发：宏观上看多个程序在同时运行，比如在单核CPU上的多任务，但微观上看程序的指令是<strong>交替运行</strong>的，<strong>CPU在任何时刻最多只能同时运行一条指令</strong>。</li>\n<li>并行：严格意义上的同时运行，比如多核CPU，程序的指令是<strong>同时运行</strong>的，<strong>CPU在任何时刻最多能够同时运行多条指令</strong>。</li>\n<li>并发<strong>不能</strong>提高计算机的性能，而并行<strong>能够</strong>提高计算机的性能。</li>\n</ul>\n<h1 id=\"什么是进程、线程、协程？\"><a href=\"#什么是进程、线程、协程？\" class=\"headerlink\" title=\"什么是进程、线程、协程？\"></a>什么是进程、线程、协程？</h1><ul>\n<li>进程：进程是<strong>系统进行资源分配和管理的基本单位</strong>。每个进程都有自己<strong>独立的内存空间</strong>，不同进程之间可以进行通信。由于进程比较重量，占据独立的内存，所以进程上下文的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对来说比较安全。</li>\n<li>线程：线程是进程的一个实体，是<strong>CPU调度和分派的基本单位</strong>，它是比进程更小的能够独立运行的单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（栈、寄存器、程序计数器），但是它可<strong>与同属一个进程的其他线程共享进程所拥有的全部资源</strong>。线程间的通信主要通过共享内存，上下文的切换开销比较少，但相比进程不够稳定，容易丢失数据。</li>\n<li>协程：协程是<strong>一种用户态的轻量级线程</strong>，协程的<strong>调度完全由用户控制</strong>。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方。在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则<strong>基本没有内核切换的开销，可以不加锁地访问全局变量</strong>，所以上下文的切换非常快。</li>\n</ul>\n<h1 id=\"进程和线程的区别？\"><a href=\"#进程和线程的区别？\" class=\"headerlink\" title=\"进程和线程的区别？\"></a>进程和线程的区别？</h1><ul>\n<li><strong>一个程序至少有一个进程，一个进程至少有一个线程。</strong></li>\n<li><strong>从系统调度上看：进程是资源分配和管理的基本单位，线程是CPU调度和分派的基本单位。</strong></li>\n<li><strong>从上下文切换上看：线程上下文的切换要比进程上下文的切换快得多。</strong></li>\n<li><strong>从系统开销上看：创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间、I&#x2F;O设备等，而创建或撤销线程时，系统只需要为之分配或回收少量资源，如栈、寄存器等，所以进程切换的开销要远大于线程切换的开销。</strong></li>\n</ul>\n<h1 id=\"协程和线程的区别？\"><a href=\"#协程和线程的区别？\" class=\"headerlink\" title=\"协程和线程的区别？\"></a>协程和线程的区别？</h1><ul>\n<li>一个线程可以有多个协程，一个进程也可以有多个协程。线程和进程都是同步机制，而协程是异步机制。</li>\n<li>协程是由程序自身控制的，没有线程切换的开销，执行效率非常高。</li>\n<li>协程不需要多线程的锁机制：在协程中控制共享资源不需要加锁，只需要判断状态即可，所以执行效率比多线程高很多。</li>\n<li>线程是抢占式的，而协程是非抢占式的，需要用户释放使用权切换到其他协程，因此同一时间只有一个协程拥有运行权，相当于单线程。</li>\n<li>协程不被操作系统内核管理，而完全由程序控制。线程是被分割的CPU资源，协程是组织好的代码流程，线程是协程的资源。但协程不会直接使用线程，协程直接利用的是执行器来关联任意线程或线程池。</li>\n</ul>\n<h1 id=\"进程的基本操作有哪些？\"><a href=\"#进程的基本操作有哪些？\" class=\"headerlink\" title=\"进程的基本操作有哪些？\"></a>进程的基本操作有哪些？</h1><ul>\n<li>fork()创建子进程：<strong>fork()函数调用一次，返回两次，在父进程中返回子进程的PID，而在子进程中返回0</strong>，可以利用这个特点来判断一个进程是父进程还是子进程。<br>（1）新创建子进程几乎但不完全与父进程相同：子进程得到与父进程用户级<strong>虚拟地址空间相同（但是独立的）一份副本</strong>，包括代码和数据段、堆、共享库以及用户栈；子进程还获得与父进程所有<strong>打开文件的描述符相同的一份副本</strong>，这意味着子进程可以读写父进程中任何打开的文件。<br>（2）父进程与子进程最大的区别在于它们的进程ID（PID）不同。</li>\n<li>exec()执行新程序：<strong>exec()函数可以替换当前进程的代码，执行一个新的程序，而不是继续执行当前程序</strong>。exec()函数可以接受一个参数，这个参数是一个字符串，表示要执行的新程序的路径，如果参数是一个相对路径，那么它会被解析为当前进程的工作目录下的路径。</li>\n<li>wait()等待子进程结束：<strong>wait()函数可以等待子进程结束，并返回子进程的返回值。</strong></li>\n<li>waitpid()等待子进程结束：<strong>waitpid()函数可以等待指定的子进程结束，并返回子进程的返回值。</strong></li>\n<li>exit()退出当前进程：<strong>exit()函数可以退出当前进程，并返回一个整数。</strong></li>\n</ul>\n",
            "tags": [
                "计算机八股文",
                "操作系统",
                "笔记",
                "计算机八股文",
                "操作系统"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/WrittenExamination/Honor_20220412/",
            "url": "https://www.liangmeng.xyz/WrittenExamination/Honor_20220412/",
            "title": "荣耀20220412",
            "date_published": "2022-04-13T14:00:00.000Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>笔试一共三道编程题，分数依次为100、200、300，需要按顺序依次完成，只有做完这一道题，才能进入下一道题，无法跳题，使用的是牛客网，允许跳出界面使用自己的IDE。</p>\n<h1 id=\"题目一：字符串分割\"><a href=\"#题目一：字符串分割\" class=\"headerlink\" title=\"题目一：字符串分割\"></a>题目一：字符串分割</h1><p>给定一系列的字符串，字符串的个数为N，每个字符串的长度不超过100。长度小于8的字符串用零补足，长度大于等于8的字符串，按8位位一组的形式不断分割，最后剩余部分用零补足。</p>\n<p>输入：</p>\n<p>第一行包括一个整数N和N个原始字符串。</p>\n<p>输出：</p>\n<p>第一行包括分割后的字符串按字典序从小到大排列。</p>\n<p>输入示例：</p>\n<p>2 abc 123456789</p>\n<p>输出示例：</p>\n<p>12345678 90000000 abc00000</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这一题比较简单，只需要按照题目的描述做即可。</p>\n<pre><code class=\"python\">inp = input().split()\nn = int(inp[0])\nls = []\nfor i in range(1, n+1):\n    string = inp[i]\n    while len(string) &gt; 8:\n        ls.append(string[:8])\n        string = string[8:]\n    ls.append(string + &quot;0&quot;*(8-len(string)))\nls.sort()\nprint(&quot; &quot;.join(ls))\n</code></pre>\n<h1 id=\"题目二：蜜蜂采蜜\"><a href=\"#题目二：蜜蜂采蜜\" class=\"headerlink\" title=\"题目二：蜜蜂采蜜\"></a>题目二：蜜蜂采蜜</h1><p>平原上，一群蜜蜂离开蜂巢采蜜，要连续采集5片花丛后归巢。<br>已知5片花丛相对蜂巢的坐标，请你帮它们规划一下到访花丛的顺序，以使飞行总距离最短。</p>\n<p>输入：</p>\n<p>以蜂巢为平面坐标原点的5片花丛A、B、C、D、E的坐标，坐标值为整数。</p>\n<p>输出：</p>\n<p>从出发到返回蜂巢最短路径的长度取整值，取整办法为舍弃小数点后面的值。</p>\n<p>输入示例：</p>\n<p>200 0 200 10 200 50 200 30 200 25</p>\n<p>输出示例：</p>\n<p>456</p>\n<p>说明：</p>\n<p>样例中的10个数，相邻两个分别为一组，表示一个花丛相对蜂巢的坐标：A(x1, y1)、B(x2, y2)、C(x3, y3)、D(x4, y4)、E(x5, y5)，分表代表x1,y1,x2,y2,x3,y3,x4,y4,x5,y5。</p>\n<h2 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h2><p>本题实际上是一道旅行商问题（TSP），经典的TSP可以描述为：一个商品推销员要去若干个城市推销商品，该推销员从一个城市出发，需要经过所有城市后，回到出发地。应如何选择行进路线，以使总的行程最短。从图论的角度来看，该问题实质是在一个带权完全无向图中，找一个权值最小的Hamilton回路。由于该问题的可行解是所有顶点的全排列，随着顶点数的增加，会产生组合爆炸，它是一个NP完全问题。</p>\n<p>常见的解法有暴力破解、深度优先遍历，动态规划等。</p>\n<p>高级的解法有模拟退火算法，遗传算法，粒子群算法、神经网络等</p>\n<h2 id=\"思路一：\"><a href=\"#思路一：\" class=\"headerlink\" title=\"思路一：\"></a>思路一：</h2><p>暴力破解，求出五片花丛所有可能的到访顺序（全排列），取飞行总距离最短的路径即可。</p>\n<pre><code class=\"python\">from math import sqrt, floor\nfrom xmlrpc.client import MAXINT\ninp = list(map(int, input().split()))\nmincost = MAXINT\nls = [(inp[i*2], inp[i*2+1]) for i in range(5)]\nmatrix = [[0 for i in range(5)] for j in range(5)]\nfor i in range(5):\n    for j in range(5):\n        matrix[i][j] = sqrt((ls[i][0]-ls[j][0])**2 + (ls[i][1]-ls[j][1])**2)\n\ndef Perm(nums, begin, end):\n    global mincost, ls, matrix, path\n    if begin &gt;= end:\n        cost = 0\n        for i in range(4):\n            cost += matrix[nums[i]][nums[i+1]]\n        cost = cost + sqrt((ls[nums[0]][0]**2) + (ls[nums[0]][1]**2)) + sqrt((ls[nums[-1]][0]**2) + (ls[nums[-1]][1]**2))\n        if cost &lt; mincost:\n            path = nums\n            mincost = cost\n        return\n    else:\n        for num in range(begin, end):\n            nums[begin], nums[num] = nums[num], nums[begin]\n            Perm(nums, begin+1, end)\n            nums[begin], nums[num] = nums[num], nums[begin]\n\nnums = [i for i in range(5)]\nPerm(nums, 0, len(nums))\nprint(floor(mincost))\n</code></pre>\n<h2 id=\"思路二：\"><a href=\"#思路二：\" class=\"headerlink\" title=\"思路二：\"></a>思路二：</h2><p>采用深度优先遍历来寻找最短路径，并在遍历过程中通过不断剪枝来简化求解过程，广义上来讲也是全排列的一种。</p>\n<pre><code class=\"python\">from math import sqrt, floor\nfrom xmlrpc.client import MAXINT\n\ndef DFS(u, cnt, cost):\n    global mincost, matrix, visited\n    if cost &gt; mincost:\n        return\n    if cnt == 6:\n        cost = cost + sqrt((ls[u][0]**2) + (ls[u][1]**2)) + sqrt((ls[0][0]**2) + (ls[0][1]**2))\n        if cost &lt; mincost:\n            mincost = cost\n    visited[u] = 1\n    for v in range(6):\n        if not visited[v]:\n            DFS(v, cnt+1, cost + matrix[u][v])\n    visited[u] = 0\n\ninp = list(map(int, input().split()))\nmincost = MAXINT\nvisited = [0 for i in range(6)]\nls = [(inp[i*2], inp[i*2+1]) for i in range(5)]\nls.insert(0, (0, 0))\nmatrix = [[0 for i in range(6)] for j in range(6)]\nfor i in range(6):\n    for j in range(6):\n        matrix[i][j] = sqrt((ls[i][0]-ls[j][0])**2 + (ls[i][1]-ls[j][1])**2)\n\nDFS(0, 1, 0)\nprint(floor(mincost))\n</code></pre>\n<h1 id=\"惨痛经历\"><a href=\"#惨痛经历\" class=\"headerlink\" title=\"惨痛经历\"></a>惨痛经历</h1><p>因为邮件上写着系统开放时间为18:00-21:00（不同于美团写着笔试时间为16:00-18:00），所以我习惯性得以为笔试时间为三个小时，当我悠哉游哉地把第二题做完返回系统时，笔试已经结束了，因此只提交了第一题，直接人麻了。。。所以，各位小伙伴无论是在比赛还是在测试，一定先看好时间！！！当然，对于秒AK的大佬来说，时间根本不是事，那就当我没说。</p>\n<p><img data-src=\"/WrittenExamination/Honor_20220412/Honor_20220412/Wolf.jpg\" alt=\"Wolf\"></p>\n",
            "tags": [
                "企业笔试",
                "荣耀笔试题",
                "算法",
                "牛客网",
                "荣耀",
                "笔试"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/WrittenExamination/MeiTuan_20220409/",
            "url": "https://www.liangmeng.xyz/WrittenExamination/MeiTuan_20220409/",
            "title": "美团20220409",
            "date_published": "2022-04-10T10:00:00.000Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>笔试一共五道编程题（四+一），一为专项编程题，估计不同岗位有题目不一样，使用的是赛码网，允许跳出界面使用自己的IDE。</p>\n<p>在此感谢<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlYm9ydHQ/dHlwZT1ibG9n\">筱羊冰冰</span>提供的部分题目及题解。</p>\n<h1 id=\"题目一：数圈游戏\"><a href=\"#题目一：数圈游戏\" class=\"headerlink\" title=\"题目一：数圈游戏\"></a>题目一：数圈游戏</h1><p>给定一个整数n，计算该整数含有的圆圈个数。数字0-9对应的圈数如下：<br>0: 1<br>1: 0<br>2: 0<br>3: 0<br>4: 0<br>5: 0<br>6: 1<br>7: 0<br>8: 2<br>9: 1</p>\n<p>输入：<br>第一行为一个整数n，表示数圈游戏的数字。</p>\n<p>输入示例：<br>60498<br>输出示例：<br>5</p>\n<p>限制：<br>80%的测试用例：n&lt;&#x3D;10000<br>100%的测试用例：n&lt;&#x3D;100000000</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>该题较为简单，一次遍历累加即可。</p>\n<h1 id=\"题目二：士兵排队\"><a href=\"#题目二：士兵排队\" class=\"headerlink\" title=\"题目二：士兵排队\"></a>题目二：士兵排队</h1><p>给定一定数量的士兵，将士兵按照身高从小到大排列，身高相同者按照姓名的字典序从小到大排列。</p>\n<p>输入：<br>第一行为一个整数n，表示士兵的数量。<br>第二行为n个士兵的身高，单位为cm。<br>第三行为n个士兵的姓名。</p>\n<p>输入示例：<br>4<br>176 170 176 176<br>bamma tom alpha beta</p>\n<p>输出示例：<br>tom alpha bamma beta</p>\n<p>限制：<br>士兵身高 hi &lt;&#x3D; 300<br>士兵姓名长度 ni &lt;&#x3D; 20</p>\n<h2 id=\"思路一：\"><a href=\"#思路一：\" class=\"headerlink\" title=\"思路一：\"></a>思路一：</h2><p>将每一个人的身高和名字按照 (身高，名字) 的格式存储，然后进行两次排序，先按照身高排序，再按照名字排序即可。（利用了python排序算法的稳定性！）</p>\n<pre><code class=\"python\">n = int(input())\nheights = list(map(str, input().split()))\nnames = list(map(str, input().split()))\nls = []\nfor i in range(n):\n    ls.append((heights[i], names[i]))\n# lambda函数指定排序规则\nls.sort(key=lambda x:x[1])\nls.sort(key=lambda x:x[0])\nfor i in range(n):\n    print(ls[i][1], end=&#39; &#39;)\n</code></pre>\n<h2 id=\"思路二：\"><a href=\"#思路二：\" class=\"headerlink\" title=\"思路二：\"></a>思路二：</h2><p>因为身高的限制为 hi &lt;&#x3D; 300，所以身高最高只能为三位数，那么我们可以把所有身高都通过补前置零的方式化为三位数，然后再与名字拼接成一个字符串，这样只需要一次排序就能够得出结果。</p>\n<pre><code class=\"python\">n = int(input())\nheights = list(map(str, input().split()))\nnames = list(map(str, input().split()))\nfor i in range(n):\n    # str.zfill()自动填充\n    heights[i] = heights[i].zfill(3) + names[i]\nheights.sort()\nfor i in range(n):\n    print(heights[i][3:], end=&#39; &#39;)\n</code></pre>\n<h1 id=\"题目三：路径搜索\"><a href=\"#题目三：路径搜索\" class=\"headerlink\" title=\"题目三：路径搜索\"></a>题目三：路径搜索</h1><p>给定一个地图，询问是否存在一条从起点到终点的直接通路。注意，通路是双向的。</p>\n<p>输入：<br>第一行包括两个整数n和m，分别表示地图上点的数量和通路的数量。<br>第二行包括m个整数，表示地图上通路的一端。<br>第三行包括m个整数，表示地图上通路的另一端。<br>第四行包括k个整数，表示询问的次数。<br>接下来的k行每行包括两个整数，分别表示起点和终点。</p>\n<p>输入示例：<br>4 5<br>1 2 1 3 1<br>2 3 3 4 4<br>4<br>1 3<br>2 4<br>2 1<br>3 2</p>\n<p>输出示例：<br>Yes<br>No<br>Yes<br>Yes</p>\n<h2 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>筱羊冰冰：上来就看错了，然后花了好久写了类似并查集的东西，然后用不上……<br>（果然大佬就是不一样，上来直接手撕并查集）<br>这道题只需要检查有无指定通路就行了，不过要特别注意查询范围，因为通路是双向的而且要求的是直接通路。</p>\n<pre><code class=\"python\">n, m = map(int, input().split())\nlsu = list(map(int, input().split()))\nlsv = list(map(int, input().split()))\nk = int(input())\nways = set((lsu[i], lsv[i]) for i in range(m))\nout = []\nfor _ in range(k):\n    u, v = map(int, input().split())\n    if (u, v) in ways or (v, u) in ways:\n        out.append(&#39;Yes&#39;)\n    else:\n        out.append(&#39;No&#39;)\nprint(&#39;\\n&#39;.join(out))\n</code></pre>\n<h1 id=\"题目四：井字棋\"><a href=\"#题目四：井字棋\" class=\"headerlink\" title=\"题目四：井字棋\"></a>题目四：井字棋</h1><p>给定一个2x2的棋盘和n中不同的颜色，要求每行每列均不能出现相同的颜色，计算总共有多少种填充方案。</p>\n<p>输入：<br>第一行包括一个整数n，表示颜色的数量。</p>\n<p>输出：<br>输出一个整数，表示有多少种填充方案。</p>\n<p>输入示例：<br>2</p>\n<p>输出示例：<br>2</p>\n<p>限制：<br>颜色的种类n &lt;&#x3D; 10</p>\n<h2 id=\"思路：-2\"><a href=\"#思路：-2\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>筱羊冰冰：有一说一，感觉就属这个题有意思吧。我当时看完，感觉就有一点像排列组合(业余玩家，不太清楚具体的类型)。<br>n种颜色，如果颜色足够(指大于四种)，我们其实也只能取出四种来操作，所以只需要一个<br>$$<br>C_n^4<br>$$<br>所以我们其实只需要考虑四种以内的情况。</p>\n<p>两种颜色：</p>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>2</th>\n<th>和</th>\n<th>2</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2</td>\n<td>1</td>\n<td></td>\n<td>1</td>\n<td>2</td>\n</tr>\n</tbody></table>\n<p>三种颜色：<br>我们自然可以想到，拿两种颜色就可以填上面的两种<br>$$<br>C_3^2 * 2<br>$$<br>然后，如果是三种颜色都要，有12种，肯定是有一个重复的，那么对角线重复就有两种情况，剩下的其实就是将三个数字填入三个位置，<br>$$<br>A_3^3<br>$$<br>就是6 + 6*2 &#x3D; 18。</p>\n<p>到这里其实就应该明白了，我们只需要知道 i 种颜色有多少种即可，因为 i &#x3D; 2, 3, 4，我们完全可以直接写出来，剩下的就是一个组合问题，再给出一个阶乘列表。</p>\n<pre><code class=\"python\"># ls[i]为i种颜色都使用，对应的可能数\n# 四种颜色忘了说了，不过就是个A44\nls = [0, 0, 2, 12, 24]\n# ls_jc[i] = i!\nls_jc = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\nret = 0\nn = int(input())\nif n &lt;= 1:\n    # 他在系统公告中，提示了0的问题\n    ret = 0\nelif n &lt;= 4:\n    for i in range(2, n+1):\n        ret += ls[i] * ls_jc[n] // (ls_jc[i] * ls_jc[n-i])\n        # 还有一个限制就是输出大小，这里原题目是有的\n        ret %= 1000000007\nelse:\n    for i in range(2, 5):\n        ret += ls[i] * ls_jc[n] // (ls_jc[i] * ls_jc[n-i])\n        ret %= 1000000007\nprint(ret)\n</code></pre>\n<h2 id=\"小插曲：\"><a href=\"#小插曲：\" class=\"headerlink\" title=\"小插曲：\"></a>小插曲：</h2><p>当时有一块写错了，然后跑出来只有27%，自己就去看了一下范围是小于等于十，那么案例至少有10个吧。<br>然后自己因为有边界检测，负数、0、1、2都能正确，那么至少对三个，反推出案例应该是11个，那么就是3往上有问题，所以将矛头对准了ls[3]，果然是算少了，改成12，啪的一下，很快就过了……</p>\n<h1 id=\"题目五：堆积木\"><a href=\"#题目五：堆积木\" class=\"headerlink\" title=\"题目五：堆积木\"></a>题目五：堆积木</h1><p>给定一个已有的字符串和一个目标字符串，可以从右边删除一个字符，也可以往左边插入一个字符，删除和插入操作的次数没有限制，问最少操作多少次可以使已有字符串变成目标字符串。</p>\n<table>\n<thead>\n<tr>\n<th>输入</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>5</td>\n<td>原串长度</td>\n</tr>\n<tr>\n<td>1 5 3 4 6</td>\n<td>原串</td>\n</tr>\n<tr>\n<td>5</td>\n<td>目标串长度</td>\n</tr>\n<tr>\n<td>2 1 5 3 4</td>\n<td>目标串</td>\n</tr>\n</tbody></table>\n<h2 id=\"思路：-3\"><a href=\"#思路：-3\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>筱羊冰冰：这个题，其实看明白了就没那么难，其实就是找最长公共子序列。</p>\n<pre><code class=\"python\">from collections import deque\nl_old = int(input())\nold = input().split()\nl_new = int(input())\nnew = input().split()\nlength = 0\n# 这里没啥原因，就是deque的头插尾插都比较快，O(1)的\ns1, s2 = deque(), deque()\njudge = 0\nwhile True:\n    s1.append(old[length])\n    s2.appendleft(new[-length-1])\n    length += 1\n    if s1 == s2:\n        judge = 1\n        break\n    elif length == min(l_old, l_new):\n        break\nif judge:\n    print(l_old+l_new - length*2)\nelse:\n    print(l_old+l_new)\n</code></pre>\n<h2 id=\"重大失误\"><a href=\"#重大失误\" class=\"headerlink\" title=\"重大失误\"></a>重大失误</h2><p>上面的代码其实没考虑，如果有多对子串相同，要找出最长的……<br>不过感觉测试案例比较拉，所以显示还是ac了的。</p>\n<p><img data-src=\"/WrittenExamination/MeiTuan_20220409/MeiTuan_20220409/Wolf.jpg\" alt=\"Wolf\"></p>\n",
            "tags": [
                "企业笔试",
                "美团笔试题",
                "算法",
                "笔试",
                "赛码网",
                "美团"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/CCPP/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/",
            "url": "https://www.liangmeng.xyz/CCPP/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/",
            "title": "学生成绩管理系统",
            "date_published": "2022-04-07T06:43:36.000Z",
            "content_html": "<p>相信很多同仁在大学学习编程的时候都会被老师要求动手敲出一个学生成绩管理系统或图书馆管理系统之类的程序吧。<br><strong>不得不说，这个程序简直就是大多数初学者的恶梦，毕竟它的内容涉及到了整一个学期学到的所有知识。</strong><br><del>况且，对于像我这种在大学前从来没接触过编程，也不知道代码是啥的绝对萌新来说，更是一次史诗级的灾难。</del> </p>\n<p><strong>你见过凌晨四点的教学楼吗？</strong><br><strong>我见过，那时候我刚从里面出来。</strong><br><img data-src=\"https://img-blog.csdnimg.cn/20210325191305561.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br><strong>话不多说，说多了都是泪。</strong></p>\n<p>实验要求我就不赘述了吧，无非就是录成绩、各种方式查成绩、名次排序、计算均分等。</p>\n<p><strong>还是直接上代码吧，大家都是爽快人！</strong></p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#define N 30\n#define M 10\n#define X 6\n\n/*学生信息结构体，包括学号，姓名，各学科分数，总分，均分*/\ntypedef struct student\n&#123;\n  long number;\n  char name[M];\n  int score[X];\n  int stutotal;\n  float stuaverage;\n&#125;STUDENT;/*对学生信息结构体取别名“STUDENT”*/\n\n/*实现两个结构体的交换，注意，结构体是可以直接赋值的*/\nvoid Swap(STUDENT *a,STUDENT *b)\n&#123;\n  STUDENT temp;\n  temp=*a;\n  *a=*b;\n  *b=temp;\n&#125;\n\n/*由用户用键盘依次输入学生信息*/\nvoid Input(STUDENT stu[],int n,int x)\n&#123;\n    printf(&quot;\\n\\n&quot;);\n    int i,j;\n    for(i=0;i&lt;n;i++)\n    &#123;\n        printf(&quot;Number:\\t&quot;);\n        scanf(&quot;%ld&quot;,&amp;stu[i].number);\n        getchar();/*清除缓冲区中的回车字符，防止被读入学生姓名*/\n        printf(&quot;Name:\\t&quot;);\n        gets(stu[i].name);\n        for(j=0;j&lt;x;j++)\n        &#123;\n            do&#123;\n                printf(&quot;Score %d:&quot;,j+1);\n                scanf(&quot;%d&quot;,&amp;stu[i].score[j]);\n            &#125;while(stu[i].score[j]&lt;0||stu[i].score[j]&gt;100);/*防止录入异常成绩*/\n        &#125;\n    &#125;\n&#125;\n\n/*计算各学科的总分和均分*/\nvoid SubCalculate(STUDENT stu[],int subtotal[],float subaverage[],int n,int x)\n&#123;\n    int i,j;\n    for(j=0;j&lt;x;j++)\n    &#123;\n        subtotal[j]=0;/*学科总成绩初始化为0*/\n        for(i=0;i&lt;n;i++)\n        &#123;\n            subtotal[j]=subtotal[j]+stu[i].score[j];\n        &#125;\n        subaverage[j]=(float)subtotal[j]/n;/*将整型数强转为浮点数后进行浮点数运算，确保数据的准确性*/\n        printf(&quot;(subject %d)Total:%d\\t\\tAverage:%6.2f\\n&quot;,j+1,subtotal[j],subaverage[j]);\n    &#125;\n &#125;\n\n/*计算每个学生的总分和均分*/\nvoid StuCalculate(STUDENT stu[],int n,int x)\n&#123;\n    int i,j;\n    for(i=0;i&lt;n;i++)\n    &#123;\n        stu[i].stutotal=0;/*学生总成绩初始化为0*/\n        for(j=0;j&lt;x;j++)\n        &#123;\n            stu[i].stutotal=stu[i].stutotal+stu[i].score[j];\n        &#125;\n        stu[i].stuaverage=(float)stu[i].stutotal/x;/*将整型数强转为浮点数后进行浮点数运算，确保数据的准确性*/\n        printf(&quot;(student %d)Total:%d\\t\\tAverage:%6.2f\\n&quot;,i+1,stu[i].stutotal,stu[i].stuaverage);\n    &#125;\n&#125;\n\n/*将学生成绩按从高到低的顺序排列*/\nvoid SortStuScoreUpdown(STUDENT stu[],int n)\n&#123;\n    for (int i = 0; i &lt; n - 1; ++i)\n    &#123;\n        for (int j = i + 1; j &lt; n; ++j)\n        &#123;\n            if (stu[i].stutotal &lt; stu[j].stutotal) Swap(&amp;stu[i], &amp;stu[j]);/*如果前面的学生的总成绩小于后面的学生的总成绩，则交换两个学生信息结构体位置*/\n        &#125;\n      &#125;\n&#125;\n\n/*将学生成绩按从低到高的顺序排列*/\nvoid SortStuScoreDownup(STUDENT stu[],int n)\n&#123;\n        for (int i = 0; i &lt; n - 1; ++i)\n    &#123;\n        for (int j = i + 1; j &lt; n; ++j)\n        &#123;\n            if (stu[i].stutotal &gt; stu[j].stutotal) Swap(&amp;stu[i], &amp;stu[j]);/*如果前面的学生的总成绩大于后面的学生的总成绩，则交换两个学生信息结构体位置*/\n        &#125;\n      &#125;\n&#125;\n\n/*将学生学号按从小到大排列*/\nvoid SortNumberDownup(STUDENT stu[],int n)\n&#123;\n        for (int i = 0; i &lt; n - 1; ++i)\n    &#123;\n        for (int j = i + 1; j &lt; n; ++j)\n        &#123;\n            if (stu[i].number &gt; stu[j].number) Swap(&amp;stu[i], &amp;stu[j]);/*如果前面的学生的学号大于后面的学生的学号，则交换两个学生信息结构体位置*/\n        &#125;\n      &#125;\n&#125;\n\n/*将学生姓名按字典顺序排列*/\nvoid SortName(STUDENT stu[],int n)\n&#123;\n    for (int i = 0; i &lt; n - 1; ++i)\n    &#123;\n        for (int j = i + 1; j &lt; n; ++j)\n        &#123;\n            if (strcmp(stu[i].name,stu[j].name)&gt;0) Swap(&amp;stu[i], &amp;stu[j]);/*如果前面的学生的字母序位大于后面的学生的字母序位，则交换两个学生信息结构体位置*/\n        &#125;\n      &#125;\n&#125;\n\n/*按学号查找学生并输出学生信息*/\nvoid SearchNumber(STUDENT stu[],int n,int x)\n&#123;\n    int i,j,flag=0;/*未找到学生时flag初始化为0*/\n    long temp;\n    printf(&quot;Input the number:\\t&quot;);\n    scanf(&quot;%ld&quot;,&amp;temp);\n    getchar();\n    SortStuScoreUpdown(stu,n);/*将学生按照成绩从高到低排序以获得学生的排名情况*/\n    for(i=0;i&lt;n;i++)/*将录入的学生学号与待查学号进行一一比对*/\n    &#123;\n        if(stu[i].number==temp)/*找到与待查学号一致的学号*/\n        &#123;\n            flag=1;/*找到学号对应的学生时，flag被赋值为1*/\n            printf(&quot;Name:     \\tNumber:      \\tPosition:\\tTotalscore:\\tAveragescore:\\t  Subjectscores:\\n&quot;);\n            printf(&quot;%-10s\\t%-13ld\\t%9d\\t%11d\\t%13.2f\\t&quot;,stu[i].name,stu[i].number,i+1,stu[i].stutotal,stu[i].stuaverage);\n            for(j=0;j&lt;x;j++)\n            &#123;\n                printf(&quot;%4d&quot;,stu[i].score[j]);\n            &#125;\n            printf(&quot;\\n&quot;);\n            break;\n        &#125;\n    &#125;\n    if(flag==0)/*未找到学号对应学生时，flag的值仍为0*/\n    &#123;\n        printf(&quot;\\nNot find!\\n&quot;);\n    &#125;\n&#125;\n\n/*按姓名查找学生并输出学生信息*/\nvoid SearchName(STUDENT stu[],int n,int x)\n&#123;\n    int i,j,flag=0;/*未找到学生时flag初始化为0*/\n    char tep[M];\n    printf(&quot;Input the name:\\t&quot;);\n  scanf(&quot; %s&quot;,tep);\n    SortStuScoreUpdown(stu,n);/*将学生按照成绩从高到低排序以获得学生的排名情况*/\n    for(i=0;i&lt;n;i++)/*将录入的学生姓名与待查姓名进行一一比对*/\n    &#123;\n        if(strcmp(stu[i].name,tep)==0)/*找到与待查姓名字母顺序完全一致的姓名*/\n        &#123;\n            flag=1;/*找到学号对应的学生时，flag被赋值为1*/\n            printf(&quot;Name:     \\tNumber:      \\tPosition:\\tTotalscore:\\tAveragescore:\\t  Subjectscores:\\n&quot;);\n            printf(&quot;%-10s\\t%-13ld\\t%9d\\t%11d\\t%13.2f\\t&quot;,stu[i].name,stu[i].number,i+1,stu[i].stutotal,stu[i].stuaverage);\n            for(j=0;j&lt;x;j++)\n            &#123;\n                printf(&quot;%4d&quot;,stu[i].score[j]);\n            &#125;\n            printf(&quot;\\n&quot;);\n            break;\n        &#125;\n    &#125;\n    if(flag==0)/*未找到学号对应学生时，flag的值仍为0*/\n    &#123;\n        printf(&quot;\\nNot find!\\n&quot;);\n    &#125;\n&#125;\n\n/*统计并打印出各学科各阶段人数及占比*/\nvoid Analysis(STUDENT stu[],int n,int x)\n&#123;\n    int a[N]=&#123;0&#125;,b[N]=&#123;0&#125;,c[N]=&#123;0&#125;,d[N]=&#123;0&#125;,e[N]=&#123;0&#125;;\n    int i,j;\n    for(j=0;j&lt;x;j++)\n    &#123;\n        for(i=0;i&lt;n;i++)\n        &#123;\n            if    (100&gt;=stu[i].score[j]&amp;&amp;90&lt;=stu[i].score[j])    a[j]++;\n            else if(89&gt;=stu[i].score[j]&amp;&amp;80&lt;=stu[i].score[j])    b[j]++;\n            else if(79&gt;=stu[i].score[j]&amp;&amp;70&lt;=stu[i].score[j])    c[j]++;\n            else if(69&gt;=stu[i].score[j]&amp;&amp;60&lt;=stu[i].score[j])    d[j]++;\n            else                                                           e[j]++;\n        &#125;\n    &#125;\n    for(j=0;j&lt;x;j++)\n    &#123;\n        printf(&quot;Subject No.%d:\\n&quot;,j+1);\n        printf(&quot;Excellent:%d\\tpercent:%.2f%%\\n&quot;,a[j],(float)100*a[j]/n);\n        printf(&quot;Good:     %d\\tpercent:%.2f%%\\n&quot;,b[j],(float)100*b[j]/n);\n        printf(&quot;Medium:   %d\\tpercent:%.2f%%\\n&quot;,c[j],(float)100*c[j]/n);\n        printf(&quot;Pass:     %d\\tpercent:%.2f%%\\n&quot;,d[j],(float)100*d[j]/n);\n        printf(&quot;Failed:   %d\\tpercent:%.2f%%\\n&quot;,e[j],(float)100*e[j]/n);\n        printf(&quot;\\n&quot;);\n    &#125;\n    printf(&quot;\\n&quot;);\n&#125;\n\n/*输出各学生的学生信息及各课程的总分和均分*/\nvoid List(STUDENT stu[],int subtotal[],float subaverage[],int n,int x)\n&#123;\n    int i,j;\n    printf(&quot;Name:     \\tNumber:      \\tTotalscore:\\tAveragescore:\\tSub 1:Sub 2:Sub 3:Sub 4:Sub 5:Sub 6:\\n&quot;);\n    for(i=0;i&lt;n;i++)\n    &#123;\n        printf(&quot;%-10s\\t%-13ld\\t%11d\\t%13.2f\\t&quot;,stu[i].name,stu[i].number,stu[i].stutotal,stu[i].stuaverage);\n        for(j=0;j&lt;x;j++)\n        &#123;\n            printf(&quot;%6d&quot;,stu[i].score[j]);\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n     printf(&quot;          \\t             \\t           \\t           \\t&quot;);\n     for(j=0;j&lt;x;j++)\n     &#123;\n      printf(&quot;%6d&quot;,subtotal[j]);\n     &#125;\n      printf(&quot;\\n&quot;);\n      printf(&quot;         \\t             \\t           \\t          \\t&quot;);\n      for(j=0;j&lt;x;j++)\n      &#123;\n          printf(&quot;%6.2f&quot;,subaverage[j]);\n      &#125;\n&#125;\n\n/*打印姓名，学号，总分，均分及各学科的分数*/\nvoid Print1(STUDENT stu[],int n,int x)\n&#123;\n    int i,j;\n    printf(&quot;Name:     \\tNumber:\\t      Totalscore:\\tAveragescore:\\tSubjectscore:\\n&quot;);\n    for(i=0;i&lt;n;i++)\n    &#123;\n        printf(&quot;%-10s\\t%-13ld\\t%9d\\t%13.2f\\t&quot;,stu[i].name,stu[i].number,stu[i].stutotal,stu[i].stuaverage);\n        for(j=0;j&lt;x;j++)\n        &#123;\n            printf(&quot;%-6d&quot;,stu[i].score[j]);\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n&#125;\n\n/*打印各课程的总分和均分*/\nvoid Print2(int subtotal[],float subaverage[],int x)\n&#123;\n  int i;\n  for(i=0;i&lt;x;i++)\n  &#123;\n    printf(&quot;subtotal No.%d: %-6d\\tsubaverage No.%d: %-6.2f\\n&quot;,i+1,subtotal[i],i+1,subaverage[i]);\n  &#125;\n&#125;\n\n/*将信息写入文件并保存*/\nvoid WritetoFile(STUDENT stu[],int subtotal[],float subaverage[],int n,int x)\n&#123;\n  FILE *fp;\n  int i,j;\n  if((fp=fopen(&quot;score.txt&quot;,&quot;w&quot;))==NULL)/*检验文件是否打开成功*/\n  &#123;\n    printf(&quot;Failure to open score.txt!\\n&quot;);\n    exit(0);\n  &#125;\n  fprintf(fp,&quot;%d\\t%d\\n&quot;,n,x);\n  for(i=0;i&lt;n;i++)\n  &#123;\n    fprintf(fp,&quot;%-10s\\t%-13ld\\t%11d\\t%13.2f\\t&quot;,stu[i].name,stu[i].number,stu[i].stutotal,stu[i].stuaverage);\n     for(j=0;j&lt;x;j++)\n        &#123;\n            fprintf(fp,&quot;%-6d\\n&quot;,stu[i].score[j]);\n        &#125;\n  &#125;\n  for(j=0;j&lt;x;j++)\n  &#123;\n      fprintf(fp,&quot;%d\\t%f\\n&quot;,subtotal[j],subaverage[j]);\n  &#125;\n  fclose(fp);\n&#125;\n\n/*从文件中读取出信息*/\nvoid ReadfromFile(STUDENT stu[],int subtotal[],float subaverage[],int *n,int *x)\n&#123;\n  FILE *fp;\n  int i,j;\n  if((fp=fopen(&quot;score.txt&quot;,&quot;r&quot;))==NULL)/*检验文件是否打开成功*/\n  &#123;\n    printf(&quot;Failure to open score.txt!\\n&quot;);\n    exit(0);\n  &#125;\n   fscanf(fp,&quot;%d\\t%d\\n&quot;,n,x);\n  for(i=0;i&lt;*n;i++)\n    &#123;\n      fscanf(fp,&quot;%10s&quot;,stu[i].name);\n      fscanf(fp,&quot;%13ld&quot;,&amp;stu[i].number);\n      fscanf(fp,&quot;%11d&quot;,&amp;stu[i].stutotal);\n      fscanf(fp,&quot;%f&quot;,&amp;stu[i].stuaverage);\n      for(j=0;j&lt;*x;j++)\n      &#123;\n        fscanf(fp,&quot;%6d&quot;,&amp;stu[i].score[j]);\n      &#125;\n    &#125;\n    for(j=0;j&lt;*x;j++)\n    &#123;\n        fscanf(fp,&quot;%d\\t%f&quot;,&amp;subtotal[j],&amp;subaverage[j]);\n    &#125;\n    fclose(fp);\n&#125;\n\nint main()\n&#123;\n    int m,n,x;\n    int subtotal[X];\n    float subaverage[X];\n    STUDENT stu[N];\n    do&#123;\n        printf(&quot;Input the total number of students:&quot;);\n        scanf(&quot;%d&quot;,&amp;n);\n        printf(&quot;Input the total number of subjects:&quot;);\n        scanf(&quot;%d&quot;,&amp;x);\n    &#125;while(n&lt;=0||n&gt;30||x&lt;1||x&gt;6);/*检测学生总人数及学科总数是否符合要求*/\n KG:printf(&quot;\\n\\n1.Input record\\n2.Calculate total and average score of every course\\n3.Calculate total and average score of every student\\n&quot;);\n      printf(&quot;4.Sort in descending order by total score of every student\\n5.Sort in ascending order by total score of every student\\n&quot;);\n      printf(&quot;6.Sort in ascending order by number\\n7.Sort in dictionary order by name\\n8.Search by number\\n&quot;);\n      printf(&quot;9.Search by name\\n10.Statistic analysis for every course\\n11.List record\\n&quot;);\n      printf(&quot;12.Write to a file\\n13.Read from a file\\n0.Exit\\n\\nPlease enter your choice:&quot;);\n      scanf(&quot;%d&quot;,&amp;m);/*打印出菜单栏以供用户选择操作*/\n    switch(m)/*利用switch语句实现菜单中的各个功能*/\n    &#123;\n      case 1: Input(stu,n,x);\n               break;\n      case 2: SubCalculate(stu,subtotal,subaverage,n,x);\n               break;\n      case 3:StuCalculate(stu,n,x);\n               break;\n      case 4: SortStuScoreUpdown(stu,n);\n               Print1(stu,n,x);\n              break;\n      case 5: SortStuScoreDownup(stu,n);\n              Print1(stu,n,x);\n             break;\n      case 6: SortNumberDownup(stu,n);\n              Print1(stu,n,x);\n            break;\n      case 7: SortName(stu,n);\n              Print1(stu,n,x);\n            break;\n      case 8: SearchNumber(stu,n,x);\n            break;\n      case 9: SearchName(stu,n,x);\n            break;\n      case 10: Analysis(stu,n,x);\n            break;\n      case 11: List(stu,subtotal,subaverage,n,x);\n            break;\n      case 12:WritetoFile(stu,subtotal,subaverage,n,x);\n            break;\n      case 13:ReadfromFile(stu,subtotal,subaverage,&amp;n,&amp;x);\n                Print1(stu,n,x);\n                Print2(subtotal,subaverage,x);\n            break;\n      case 0: exit(0);\n    &#125;\n   if(m!=0||m&lt;0||m&gt;13) goto KG;/*检测用户选择是否出错，并利用goto语句实现跳转*/\n   return 0;\n&#125;\n</code></pre>\n<p>以上就是该实验的全部代码。（<del>毫无保留，直接裸奔！！！</del> ）</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210325193106921.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>实验数据我就不给了吧。</p>\n<p><strong>本人王者荣耀迷和KPL迷，实验数据全是英雄名和选手名（说实话，选手们的ID确实好听），估计助教在看实验的时候都笑出猪叫了。（<del>助教笑出猪叫？？？</del> 啪，又来套娃！）</strong></p>\n<p>有相同兴趣的小伙伴们可以找我一起观赛掉分。<del>本人厨艺精湛，饭多管饱！！！</del> </p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210325194414574.jpg#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><strong>敲黑板！！！</strong></p>\n<p><strong>如果大佬们不幸看了我的代码，欢迎指导！！！（毕竟这时大一刚学的时候写的，估计bug一堆，很多代码也不是最优的）<br>如果萌新们不幸看了我的代码，欢迎交流！！！（如果你也备受这个实验困扰，希望这篇文章能够帮助到你）</strong></p>\n<p><strong>最后，有被学生成绩管理系统和图书馆管理系统折磨过的同仁，举个爪子示意一下，让我知道我并不孤单！</strong></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/2021032519443410.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "C/CPP语言",
                "学生成绩管理系统",
                "C语言",
                "实验"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/Hello-MyWorld/hello-world/",
            "url": "https://www.liangmeng.xyz/Hello-MyWorld/hello-world/",
            "title": "欢迎来到我的世界",
            "date_published": "2022-04-06T14:56:44.788Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": [
                "我的世界",
                "欢迎来到我的世界",
                "helloWorld"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/LeetCode/%E5%89%91%E6%8C%87Offer/53-II/",
            "url": "https://www.liangmeng.xyz/LeetCode/%E5%89%91%E6%8C%87Offer/53-II/",
            "title": "53-II",
            "date_published": "2021-06-07T13:15:00.000Z",
            "content_html": "<h2 id=\"题目简述\"><a href=\"#题目简述\" class=\"headerlink\" title=\"题目简述\"></a>题目简述</h2><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<h2 id=\"题解示例\"><a href=\"#题解示例\" class=\"headerlink\" title=\"题解示例\"></a>题解示例</h2><p>示例 1:</p>\n<p>输入: [0,1,3]<br>输出: 2<br>示例 2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p>\n<h2 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h2><p>1 &lt;&#x3D; 数组长度 &lt;&#x3D; 10000</p>\n<h2 id=\"标记难度\"><a href=\"#标记难度\" class=\"headerlink\" title=\"标记难度\"></a>标记难度</h2><p>通过次数：126,612<br>提交次数：284,562<br>通过率：44.5%</p>\n<h2 id=\"问题简析\"><a href=\"#问题简析\" class=\"headerlink\" title=\"问题简析\"></a>问题简析</h2><p>对该数组进行<strong>二分查找</strong>即可。<br>若计算得到的中值与数组中值相等，则缺失的数字在右区间中；<br>若计算得到的中值与数组中值不相等，则缺失的数字在左区间中；</p>\n<p>最简单的方法便是遍历数组，如此则未能将<strong>数组有序</strong>的条件合理利用，其时间复杂度也相对较大。</p>\n<h2 id=\"python3代码\"><a href=\"#python3代码\" class=\"headerlink\" title=\"python3代码\"></a>python3代码</h2><pre><code class=\"python\">class Solution:\n    def missingNumber(self, nums: List[int]) -&gt; int:\n        i, j = 0, len(nums)-1     \n        while i &lt;= j:\n            mid = (i+j) // 2\n            if nums[mid] == mid:\n                i = mid+1\n            else:\n                j = mid-1\n        return i\n</code></pre>\n<h2 id=\"C语言代码\"><a href=\"#C语言代码\" class=\"headerlink\" title=\"C语言代码\"></a>C语言代码</h2><pre><code class=\"c\">int missingNumber(int* nums, int numsSize)&#123;\n    int left = 0, right = numsSize-1, mid;\n    while (left &lt;= right) \n    &#123;\n        mid = left + (right - left) / 2;\n        if (nums[mid] != mid) \n        &#123;\n            right = mid - 1;\n        &#125; \n        else\n        &#123;\n            left = mid + 1;\n        &#125;\n    &#125;\n    return left;\n&#125;\n</code></pre>\n<h2 id=\"C-代码（Copy）\"><a href=\"#C-代码（Copy）\" class=\"headerlink\" title=\"C++代码（Copy）\"></a>C++代码（Copy）</h2><pre><code class=\"cpp\">class Solution &#123;\npublic:\n    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int left = 0, right = nums.size() - 1;\n\n        while (left &lt;= right)\n        &#123;\n            int mid = (left + right) &gt;&gt; 1;\n            if (nums[mid] == mid) left = mid + 1;\n            else right = mid - 1;\n        &#125;\n\n        return left;    //注意最后left不等于right，只能返回left\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"大佬专属代码\"><a href=\"#大佬专属代码\" class=\"headerlink\" title=\"大佬专属代码\"></a>大佬专属代码</h2><pre><code class=\"python\">return (len(nums)+1)*len(nums)/2 -sum(nums)\n</code></pre>\n<p><strong>敲黑板！！！</strong><br><strong>有序数组二分法！！！有序数组二分法！！！有序数组二分法！！！（重要的事情说三遍）</strong></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210607210749915.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "力扣题库",
                "剑指0ffer",
                "53-II"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/11-%E6%9C%9F%E6%9C%9B%E4%B8%AA%E6%95%B0%E7%BB%9F%E8%AE%A1/",
            "url": "https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/11-%E6%9C%9F%E6%9C%9B%E4%B8%AA%E6%95%B0%E7%BB%9F%E8%AE%A1/",
            "title": "11-期望个数统计",
            "date_published": "2021-06-06T09:16:00.000Z",
            "content_html": "<h2 id=\"题目简述\"><a href=\"#题目简述\" class=\"headerlink\" title=\"题目简述\"></a>题目简述</h2><p>某互联网公司一年一度的春招开始了，一共有 n 名面试者入选。每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。</p>\n<p>小 A 和小 B 负责审核面试者，他们均有所有面试者的简历，并且将各自根据面试者能力值从大到小的顺序浏览。由于简历事先被打乱过，能力值相同的简历的出现顺序是从它们的全排列中等可能地取一个。现在给定 n 名面试者的能力值 scores，设 X 代表小 A 和小 B 的浏览顺序中出现在同一位置的简历数，求 X 的期望。</p>\n<p>提示：离散的非负随机变量的期望计算公式为   E(X) &#x3D; Σ(k&#x3D;1, ∞) kPr(X &#x3D; k)。在本题中，由于 X 的取值为 0 到 n 之间，期望计算公式可以是E(X) &#x3D; Σ(k&#x3D;1, n) kPr(X &#x3D; k)。</p>\n<h2 id=\"题解示例\"><a href=\"#题解示例\" class=\"headerlink\" title=\"题解示例\"></a>题解示例</h2><p>示例 1：</p>\n<p>输入：scores &#x3D; [1,2,3]</p>\n<p>输出：3</p>\n<p>解释：由于面试者能力值互不相同，小 A 和小 B 的浏览顺序一定是相同的。X的期望是 3 。</p>\n<p>示例 2：</p>\n<p>输入：scores &#x3D; [1,1]</p>\n<p>输出：1</p>\n<p>解释：设两位面试者的编号为 0, 1。由于他们的能力值都是 1，小 A 和小 B 的浏览顺序都为从全排列 [[0,1],[1,0]] 中等可能地取一个。如果小 A 和小 B 的浏览顺序都是 [0,1] 或者 [1,0] ，那么出现在同一位置的简历数为 2 ，否则是 0 。所以 X 的期望是 (2+0+2+0) * 1&#x2F;4 &#x3D; 1</p>\n<p>示例 3：</p>\n<p>输入：scores &#x3D; [1,1,2]</p>\n<p>输出：2</p>\n<h2 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h2><p>1 &lt;&#x3D; scores.length &lt;&#x3D; 10^5<br>0 &lt;&#x3D; scores[i] &lt;&#x3D; 10^6</p>\n<h2 id=\"标记难度\"><a href=\"#标记难度\" class=\"headerlink\" title=\"标记难度\"></a>标记难度</h2><p>难度：简单<br>通过次数：6051<br>提交次数：8963<br>通过率：67.5%</p>\n<h2 id=\"问题解析\"><a href=\"#问题解析\" class=\"headerlink\" title=\"问题解析\"></a>问题解析</h2><p>数组中的元素可以分为两种：单元素和多元素。</p>\n<p>对于单元素，由于两位面试官都是根据能力值从大到小的顺序浏览，假设数组元素按数值非递c增的顺序排列，那么其在数组中的顺序一定是相同的，即单元素在两位面试官的浏览顺序中一定是出现在同一位置的，则单元素的数学期望为1。</p>\n<p>对于多元素，假设该元素出现m次，编号为0，1，2，…，m-1。假设m &#x3D; 3，则全排列有如下6种情况：（0,1,2），（0,2,1），（1,0,2），（1,2,0），（2,0,1），（2,1,0），现两个面试官分别从六种顺序里挑选一种，易知每个位置编号相同的概率均为1&#x2F;3，那么可以得出两位面试官在同一位置选取同一元素的概率为1&#x2F;n，则多元素的数学期望为1&#x2F;n × n &#x3D; 1。</p>\n<p>可以得出，无论是单元素还是多元素，其数学期望均为1，即整个数组的数学期望等于数组中数值不同的元素的个数和。</p>\n<h2 id=\"python3代码\"><a href=\"#python3代码\" class=\"headerlink\" title=\"python3代码\"></a>python3代码</h2><pre><code class=\"python\">class Solution:\n    def expectNumber(self, scores: List[int]) -&gt; int:\n        return len(set(scores))\n</code></pre>\n<h2 id=\"C语言代码\"><a href=\"#C语言代码\" class=\"headerlink\" title=\"C语言代码\"></a>C语言代码</h2><pre><code class=\"c\">int expectNumber(int* scores, int scoresSize)&#123;\n    int hash[1000000] = &#123;0&#125;;\n    int result = 0;\n    for (int i = 0; i &lt; scoresSize; ++i) &#123;\n        if (hash[scores[i]] == 0) &#123;\n            hash[scores[i]]++;\n            result++;\n        &#125;\n    &#125;\n    return result;\n&#125;\n</code></pre>\n<h2 id=\"C-代码\"><a href=\"#C-代码\" class=\"headerlink\" title=\"C++代码\"></a>C++代码</h2><pre><code class=\"cpp\">class Solution &#123;\npublic:\n    int expectNumber(vector&lt;int&gt;&amp; scores) &#123;\n        return set&lt;int&gt;(scores.begin(), scores.end()).size();\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"大佬专属代码\"><a href=\"#大佬专属代码\" class=\"headerlink\" title=\"大佬专属代码\"></a>大佬专属代码</h2><pre><code class=\"python\"># 暂时没看到任何“出类拔萃”的代码\n</code></pre>\n<p><strong>敲黑板！！！</strong><br><strong>这道题关键在于看懂题目，只能说：概率论yyds！！！</strong></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210606171417228.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "力扣题库",
                "难度简单",
                "期望个数统计"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E4%B8%AD%E7%AD%89/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/",
            "url": "https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E4%B8%AD%E7%AD%89/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/",
            "title": "54-螺旋矩阵",
            "date_published": "2021-06-04T09:34:00.000Z",
            "content_html": "<h2 id=\"题目简述\"><a href=\"#题目简述\" class=\"headerlink\" title=\"题目简述\"></a>题目简述</h2><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>\n<h2 id=\"题解示例\"><a href=\"#题解示例\" class=\"headerlink\" title=\"题解示例\"></a>题解示例</h2><p>示例 1：<br>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br><img data-src=\"https://img-blog.csdnimg.cn/20210604152606550.png\" alt=\"在这里插入图片描述\"><br>示例 2：<br>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]<br><img data-src=\"https://img-blog.csdnimg.cn/20210604152628828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h2><p>m &#x3D; matrix.length<br>n &#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 10<br>-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100</p>\n<h2 id=\"标记难度\"><a href=\"#标记难度\" class=\"headerlink\" title=\"标记难度\"></a>标记难度</h2><p>难度：中等<br>通过次数：158025<br>提交次数：335,777<br>通过率：47.1%</p>\n<h2 id=\"问题解析\"><a href=\"#问题解析\" class=\"headerlink\" title=\"问题解析\"></a>问题解析</h2><p>本题主要考察矩阵的遍历，还涉及到递归、矩阵转置等知识。</p>\n<p>最直观的方法就是按圈遍历矩阵，从外到里一圈一圈遍历，即先遍历矩阵的最外圈，然后递归地遍历其子矩阵的最外圈。要注意的是，单行或单列需要特殊处理。</p>\n<h2 id=\"python3代码\"><a href=\"#python3代码\" class=\"headerlink\" title=\"python3代码\"></a>python3代码</h2><pre><code class=\"python\">class Solution(object):\n    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: \n        row, col = len(matrix), len(matrix[0])\n        def getOutermostCircle(row_start, row_end, col_start, col_end): \n            if row_start &gt; row_end or col_start &gt; col_end:# 防错\n                return []\n            elif row_start == row_end: #单行\n                circle = []\n                for j in range(col_start, col_end+1): # 上边\n                    circle.append(matrix[row_start][j])\n                return circle\n                # return matrix[row_start][col_start:col_end+1]\n            elif col_start == col_end: #单列\n                circle = []\n                for i in range(row_start, row_end+1):\n                    circle.append(matrix[i][col_start])\n                return circle\n            else: # 多行多列\n                circle = []\n                for j in range(col_start, col_end+1): # 上边\n                    circle.append(matrix[row_start][j])\n                    # circle.extend(matrix[row_start][col_start:col_end+1])\n                for i in range(row_start+1, row_end): # 右边\n                    circle.append(matrix[i][col_end])\n                for j in range(col_end, col_start-1, -1): # 下边\n                    circle.append(matrix[row_end][j])\n                    # circle.extend(reversed(matrix[row_end][col_start:col_end+1]))\n                for i in range(row_end-1, row_start, -1): # 左边\n                    circle.append(matrix[i][col_start])\n                return circle + getOutermostCircle(row_start+1, row_end-1, col_start+1, col_end-1) # 拼接\n\n        return getOutermostCircle(0, row-1, 0, col-1)\n</code></pre>\n<h2 id=\"C语言代码（官方）\"><a href=\"#C语言代码（官方）\" class=\"headerlink\" title=\"C语言代码（官方）\"></a>C语言代码（官方）</h2><pre><code class=\"c\">int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) &#123;\n    if (matrixSize == 0 || matrixColSize[0] == 0) &#123;\n        *returnSize = 0;\n        return NULL;\n    &#125;\n\n    int rows = matrixSize, columns = matrixColSize[0];\n    int total = rows * columns;\n    int* order = malloc(sizeof(int) * total);\n    *returnSize = 0;\n\n    int left = 0, right = columns - 1, top = 0, bottom = rows - 1;\n    while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;\n        for (int column = left; column &lt;= right; column++) &#123;\n            order[(*returnSize)++] = matrix[top][column];\n        &#125;\n        for (int row = top + 1; row &lt;= bottom; row++) &#123;\n            order[(*returnSize)++] = matrix[row][right];\n        &#125;\n        if (left &lt; right &amp;&amp; top &lt; bottom) &#123;\n            for (int column = right - 1; column &gt; left; column--) &#123;\n                order[(*returnSize)++] = matrix[bottom][column];\n            &#125;\n            for (int row = bottom; row &gt; top; row--) &#123;\n                order[(*returnSize)++] = matrix[row][left];\n            &#125;\n        &#125;\n        left++;\n        right--;\n        top++;\n        bottom--;\n    &#125;\n    return order;\n&#125;\n</code></pre>\n<h2 id=\"C-（官方）\"><a href=\"#C-（官方）\" class=\"headerlink\" title=\"C++（官方）\"></a>C++（官方）</h2><pre><code class=\"cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        if (matrix.size() == 0 || matrix[0].size() == 0) &#123;\n            return &#123;&#125;;\n        &#125;\n\n        int rows = matrix.size(), columns = matrix[0].size();\n        vector&lt;int&gt; order;\n        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;\n        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;\n            for (int column = left; column &lt;= right; column++) &#123;\n                order.push_back(matrix[top][column]);\n            &#125;\n            for (int row = top + 1; row &lt;= bottom; row++) &#123;\n                order.push_back(matrix[row][right]);\n            &#125;\n            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;\n                for (int column = right - 1; column &gt; left; column--) &#123;\n                    order.push_back(matrix[bottom][column]);\n                &#125;\n                for (int row = bottom; row &gt; top; row--) &#123;\n                    order.push_back(matrix[row][left]);\n                &#125;\n            &#125;\n            left++;\n            right--;\n            top++;\n            bottom--;\n        &#125;\n        return order;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"大佬专属代码\"><a href=\"#大佬专属代码\" class=\"headerlink\" title=\"大佬专属代码\"></a>大佬专属代码</h2><pre><code class=\"python\">def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:\n        res = []\n        while matrix:\n            res += matrix.pop(0)\n            matrix = list(zip(*matrix))[::-1]\n        return res\n</code></pre>\n<p><strong>敲黑板！！！</strong><br><strong>熟练掌握矩阵、列表的各种函数或方法！！！</strong></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210604172806704.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "力扣题库",
                "难度中等",
                "螺旋矩阵"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/22-%E9%BB%91%E7%99%BD%E6%96%B9%E6%A0%BC%E7%94%BB/",
            "url": "https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/22-%E9%BB%91%E7%99%BD%E6%96%B9%E6%A0%BC%E7%94%BB/",
            "title": "22-黑白方格画",
            "date_published": "2021-06-02T13:40:00.000Z",
            "content_html": "<h2 id=\"题目简述\"><a href=\"#题目简述\" class=\"headerlink\" title=\"题目简述\"></a>题目简述</h2><p>小扣注意到秋日市集上有一个创作黑白方格画的摊位。摊主给每个顾客提供一个固定在墙上的白色画板，画板不能转动。画板上有 n * n 的网格。绘画规则为，小扣可以选择任意多行以及任意多列的格子涂成黑色（<strong>选择的整行、整列均需涂成黑色</strong>），<strong>所选行数、列数均可为 0</strong>。</p>\n<p>小扣希望最终的成品上需要有 k 个黑色格子，请返回小扣共有多少种涂色方案。</p>\n<p>注意：两个方案中任意一个相同位置的格子颜色不同，就视为不同的方案。</p>\n<h2 id=\"题解示例\"><a href=\"#题解示例\" class=\"headerlink\" title=\"题解示例\"></a>题解示例</h2><p>示例 1：</p>\n<p>输入：n &#x3D; 2, k &#x3D; 2</p>\n<p>输出：4</p>\n<p>解释：一共有四种不同的方案：<br>第一种方案：涂第一列；<br>第二种方案：涂第二列；<br>第三种方案：涂第一行；<br>第四种方案：涂第二行。</p>\n<p>示例 2：</p>\n<p>输入：n &#x3D; 2, k &#x3D; 1</p>\n<p>输出：0</p>\n<p>解释：不可行，因为第一次涂色至少会涂两个黑格。</p>\n<p>示例 3：</p>\n<p>输入：n &#x3D; 2, k &#x3D; 4</p>\n<p>输出：1</p>\n<p>解释：共有 2*2&#x3D;4 个格子，仅有一种涂色方案。</p>\n<h2 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h2><p>1 &lt;&#x3D; n &lt;&#x3D; 6<br>0 &lt;&#x3D; k &lt;&#x3D; n * n</p>\n<h2 id=\"标记难度\"><a href=\"#标记难度\" class=\"headerlink\" title=\"标记难度\"></a>标记难度</h2><p>难度：简单<br>通过次数：8065<br>提交次数：24485<br>通过率：32.9%</p>\n<h2 id=\"问题解析\"><a href=\"#问题解析\" class=\"headerlink\" title=\"问题解析\"></a>问题解析</h2><p>本题主要考察组合和阶乘。</p>\n<p>假设选择涂黑i行、j列，那么此时黑色方块共有 <strong>i*n + j*n - i*j</strong> 块，其中 <strong>i*j</strong> 为行和列重合的块数。</p>\n<p>而在n行中取i行、在n列中取j列，即数学中的组合数，其值可以分别为 <strong>n! &#x2F; (i!(n-i)!)</strong>  、 <strong>n! &#x2F; (j!(n-j)!)</strong> ，这便涉及到阶乘的计算了。</p>\n<p>要注意的是，当不涂或者涂满时，方法都只有一种。</p>\n<h2 id=\"python3代码\"><a href=\"#python3代码\" class=\"headerlink\" title=\"python3代码\"></a>python3代码</h2><pre><code class=\"python\">class Solution:\n    def paintingPlan(self, n: int, k: int) -&gt; int:\n        if k == 0 or k == n*n:\n            return 1\n        result = 0\n        for i in range(1, n):\n            for j in range(1, n):\n                if n*i + n*j - i*j == k:\n                    result += math.factorial(n)/(math.factorial(i) * math.factorial(n-i))*math.factorial(n)/(math.factorial(j) * math.factorial(n-j))           \n        return int(result)\n</code></pre>\n<p>其中，阶乘的求解可以用递归，也可以用循环，或者直接用库函数，可以分别运行来比较其时间复杂度和空间复杂度。</p>\n<p>另外，组合的求解方式也非常多样化，可以利用阶乘函数计算，也可以直接进行数值计算。</p>\n<pre><code class=\"python\"># 递归\ndef factorial(n):\n    if n == 1:\n        return 1\n    else:\n        return n * factorial(n-1)\n\n# 循环\ndef factorial(n):\n    fact = 1\n    for i in range(2, n+1):\n        fact *= i\n    return fact\n\n# 利用阶乘\ndef C(n, a):\n    return factorial(n)/(factorial(a) * factorial(n-a))\n    \n# 直接计算\ndef C(n, a):\n    result = 1\n    for i in range(n, n-a, -1):\n           result *= i\n    for j in range(1, a+1):\n        result /= j\n    return result\n\n# 防溢出防除不尽\ndef C(n, a):\n    result = 1\n    for i in range(1, a+1):\n        result *= (n+1-i)/i\n    return result    \n</code></pre>\n<h2 id=\"C语言代码\"><a href=\"#C语言代码\" class=\"headerlink\" title=\"C语言代码\"></a>C语言代码</h2><pre><code class=\"c\">int factorial(int n)\n&#123;\n       if(n == 1) \n    &#123; \t\n        return 1;\n    &#125;\n       return n * factorial(n-1);\n&#125;\nint C(int n, int a)\n&#123;\n       return factorial(n) / (factorial(a) * factorial(n-a));\n&#125;\nint paintingPlan(int n, int k)&#123;\n    int result = 0, i, j;\n    if(k == 0 || k == n*n)\n    &#123;\n        return 1;\n      &#125;\n    for(i = 1; i &lt;= n; ++i)\n    &#123;\n        for&#123;j = 1; j &lt;= n; ++j)\n        &#123;\n            if((n*i + n*j - i*j) == k)\n            &#123;\n                result += C(n, i) * C(n, j);\n            &#125;\n        &#125;\n    &#125;\n    return result;\n&#125;\n</code></pre>\n<h2 id=\"C-代码（Copy）\"><a href=\"#C-代码（Copy）\" class=\"headerlink\" title=\"C++代码（Copy）\"></a>C++代码（Copy）</h2><pre><code class=\"cpp\">class Solution &#123;\npublic:\n    //预处理组合数\n    int C[10][10];\n    void Init()&#123;\n        for(int i = 0; i &lt; 10; i++)&#123;\n            for(int j = 0; j &lt;= i; j++)&#123;\n                if(!j) C[i][j] = 1;\n                else C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n            &#125;\n        &#125;\n    &#125;\n    int paintingPlan(int n, int k) &#123;\n        if(k == 0) return 1;\n        if(k &lt; n) return 0;\n        if(k == n * n) return 1;\n        Init();\n        int ans = 0;\n        for(int i = 0 ; i &lt;= n; i++)&#123;\n            for(int j = 0; j &lt;= n; j++)&#123;\n                if(n * i + n * j - i * j == k)&#123;\n                    ans += C[n][i] * C[n][j];\n                &#125;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"大佬专属代码\"><a href=\"#大佬专属代码\" class=\"headerlink\" title=\"大佬专属代码\"></a>大佬专属代码</h2><pre><code class=\"c\">int paintingPlan(int n, int k)\n&#123;\n    int p=0;\n    if(k==0)\n        p=1;\n    if(n==1)\n    &#123;\n        if(k==1)\n            p=1;\n    &#125;\n    if(n==2)\n    &#123;\n        if(k==2)\n            p=4;\n        if(k==3)\n            p=4;\n        if(k==4)\n            p=1;\n    &#125;\n    if(n==3)\n    &#123;\n        if(k==3)\n            p=6;\n        if(k==5)\n            p=9;\n        if(k==6)\n            p=6;\n        if(k==7)\n           p=18;\n        if(k==8)\n            p=9;\n        if(k==9)\n            p=1;\n    &#125;\n    if(n==4)\n    &#123;\n        if(k==4)\n            p=8;\n        if(k==7)\n            p=16;\n        if(k==8)\n            p=12;\n        if(k==10)\n            p=48;\n        if(k==12)\n            p=44;\n        if(k==13)\n            p=32;\n        if(k==14)\n            p=48;\n        if(k==15)\n            p=16;\n        if(k==16)\n            p=1;\n    &#125;\n    if(n==5)\n    &#123;\n        if(k==5)\n            p=10;\n        if(k==9)\n            p=25;\n        if(k==10)\n            p=20;\n        if(k==13)\n            p=100;\n        if(k==15)\n            p=20;\n        if(k==16)\n            p=100;\n        if(k==17)\n            p=200;\n        if(k==21)\n            p=150;\n        if(k==19)\n            p=200;\n        if(k==20)\n            p=10;\n        if(k==25)\n            p=1;\n        if(k==24)\n            p=25;\n        if(k==23)\n            p=100;\n        if(k==22)\n            p=100;\n    &#125;\n    if(n==6)\n    &#123;\n        if(k==36)\n            p=1;\n        if(k==35)\n            p=36;\n        if(k==34)\n            p=180;\n        if(k==33)\n            p=240;\n        if(k==32)\n            p=405;\n        if(k==31)\n            p=72;\n        if(k==30)\n            p=612;\n        if(k==28)\n            p=450;\n        if(k==27)\n            p=400;\n        if(k==26)\n            p=180;\n        if(k==24)\n            p=630;\n        if(k==21)\n            p=240;\n        if(k==20)\n            p=225;\n        if(k==18)\n            p=40;\n        if(k==16)\n            p=180;\n        if(k==12)\n            p=30;\n        if(k==11)\n            p=36;\n        if(k==6)\n            p=12;\n    &#125;\n    return p;\n&#125;\n</code></pre>\n<p><strong>敲黑板！！！<br>排列、组合、阶乘的各种实现代码必须做到信手拈来，还要考虑其时间复杂度、空间复杂度、是否溢出、是否除不尽等！！！</strong></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210602213721831.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "力扣题库",
                "难度简单",
                "黑白方格画"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/833-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E6%8A%95%E5%BD%B1%E9%9D%A2%E7%A7%AF/",
            "url": "https://www.liangmeng.xyz/LeetCode/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95/833-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E6%8A%95%E5%BD%B1%E9%9D%A2%E7%A7%AF/",
            "title": "833-三维形体投影面积",
            "date_published": "2021-06-02T13:40:00.000Z",
            "content_html": "<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><p>在 n x n 的网格 grid 中，我们放置了一些与 x，y，z 三轴对齐的 1 x 1 x 1 立方体。每个值 v &#x3D; grid[i] [j] 表示 v 个正方体叠放在单元格 (i, j) 上。现在，我们查看这些立方体在 xy 、yz 和 zx 平面上的投影。投影就像影子，将三维形体映射到一个二维平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。返回所有三个投影的总面积 。</p>\n<p>输入示例1：</p>\n<p>[[1, 2], [3, 4]]</p>\n<p>输出示例1：</p>\n<p>17</p>\n<p>解释：</p>\n<p>该立体图形的俯视图如下，数字代表该处有多少块立方体。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n</tr>\n</tbody></table>\n<p>投影面积 &#x3D; 4（俯视图） + 7（主视图） + 6（左视图）&#x3D; 17</p>\n<p>输入示例2：</p>\n<p>[[2]]</p>\n<p>输出示例2：</p>\n<p>5</p>\n<p>输入示例3：</p>\n<p>[[1, 0], [0, 2]]</p>\n<p>输出示例3：</p>\n<p>8</p>\n<p>限制条件：</p>\n<p>n &#x3D;&#x3D; grid.length &#x3D;&#x3D; grid[i].length</p>\n<p>1 &lt;&#x3D; n &lt;&#x3D; 50</p>\n<p>0 &lt;&#x3D; grid[i] [j] &lt;&#x3D; 50</p>\n<h1 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h1><p>S（俯视图） &#x3D; sum(grid[i] [j] &gt; 0)，即矩阵中非零数值的个数。</p>\n<p>S（主视图） &#x3D; sum(max(grid[j]))，即矩阵中每一列最大值的和。</p>\n<p>S（左视图） &#x3D; sum(max(grid[i]))，即矩阵中每一行最大值的和。</p>\n<h1 id=\"个人代码\"><a href=\"#个人代码\" class=\"headerlink\" title=\"个人代码\"></a>个人代码</h1><pre><code class=\"python\">class Solution:\n    def projectionArea(self, grid: List[List[int]]) -&gt; int:\n        xy, xz, yz = 0, 0, 0\n        for i in range(len(grid)):\n            maxr, maxc = 0, 0\n            for j in range(len(grid[i])):\n                if grid[i][j] &gt; 0:\n                    xy += 1\n                maxr = max(maxr, grid[i][j])\n                maxc = max(maxc, grid[j][i])\n\n            xz += maxr\n            yz += maxc     \n        return (xy+xz+yz)  \n</code></pre>\n<h1 id=\"官方代码\"><a href=\"#官方代码\" class=\"headerlink\" title=\"官方代码\"></a>官方代码</h1><pre><code class=\"python\">class Solution:\n    def projectionArea(self, grid: List[List[int]]) -&gt; int:\n        xyArea = sum(v &gt; 0 for row in grid for v in row)\n        # 注意这里为 O(n) 空间复杂度，改为下标枚举则可以 O(1)\n        yzArea = sum(map(max, zip(*grid)))  \n        zxArea = sum(map(max, grid))\n        return xyArea + yzArea + zxArea\n</code></pre>\n<pre><code class=\"c++\">class Solution &#123;\npublic:\n    int projectionArea(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;\n        int n = grid.size();\n        int xyArea = 0, yzArea = 0, zxArea = 0;\n        for (int i = 0; i &lt; n; i++) &#123;\n            int yzHeight = 0, zxHeight = 0;\n            for (int j = 0; j &lt; n; j++) &#123;\n                xyArea += grid[i][j] &gt; 0 ? 1 : 0;\n                yzHeight = max(yzHeight, grid[j][i]);\n                zxHeight = max(zxHeight, grid[i][j]);\n            &#125;\n            yzArea += yzHeight;\n            zxArea += zxHeight;\n        &#125;\n        return xyArea + yzArea + zxArea;\n    &#125;\n&#125;;\n</code></pre>\n<pre><code class=\"c\">#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))\n\nint projectionArea(int** grid, int gridSize, int* gridColSize) &#123;\n    int xyArea = 0, yzArea = 0, zxArea = 0;\n    for (int i = 0; i &lt; gridSize; i++) &#123;\n        int yzHeight = 0, zxHeight = 0;\n        for (int j = 0; j &lt; gridSize; j++) &#123;\n            xyArea += grid[i][j] &gt; 0 ? 1 : 0;\n            yzHeight = MAX(yzHeight, grid[j][i]);\n            zxHeight = MAX(zxHeight, grid[i][j]);\n        &#125;\n        yzArea += yzHeight;\n        zxArea += zxHeight;\n    &#125;\n    return xyArea + yzArea + zxArea;\n&#125;\n</code></pre>\n<p><img data-src=\"https://img-blog.csdnimg.cn/187e682d741b47389088c8f74f117822.png#pic_center\" alt=\"wolf\"></p>\n",
            "tags": [
                "力扣题库",
                "难度简单",
                "三维形体投影面积"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/GameDevelopment/%E8%B4%AA%E5%90%83%E8%9B%87-Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/",
            "url": "https://www.liangmeng.xyz/GameDevelopment/%E8%B4%AA%E5%90%83%E8%9B%87-Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/",
            "title": "贪吃蛇-Python语言实现",
            "date_published": "2021-06-02T03:05:00.000Z",
            "content_html": "<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>贪吃蛇（也叫做贪食蛇）游戏是一款休闲益智类游戏，既简单又耐玩，唯一的目标就是<strong>做这条gai上最长（pang）的蛇（zhu）</strong>！</p>\n<p>玩贪吃蛇最考验的就是走位（<strong>简称蛇皮走位</strong>），各种漂移过人，唉，就是玩儿！</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210601204813403.gif#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"基本设置\"><a href=\"#基本设置\" class=\"headerlink\" title=\"基本设置\"></a>基本设置</h2><pre><code class=\"python\"># 基本设置\nlattice_wh = 20\nsnake_color = (84, 255, 159)\nsnake_head_color = (123, 104, 238)\nfood_color = (255, 64, 64)\n</code></pre>\n<h2 id=\"绘制屏幕\"><a href=\"#绘制屏幕\" class=\"headerlink\" title=\"绘制屏幕\"></a>绘制屏幕</h2><pre><code class=\"bash\"># 绘制屏幕\npygame.init()\nscreen = pygame.display.set_mode((25*lattice_wh, 25*lattice_wh))\npygame.display.set_caption(&quot;贪吃蛇&quot;)\n\n# 帧率，每秒刷新屏幕次数\nFPS = 10\n# 帧率变化系数\nlevel = 1.5\n# 时间对象\nFPSCLOCK = pygame.time.Clock()\n# 游戏结束标志\ngame_over = 0\n# 前进方向\ndirection = 0\n# 进食数量\nnum = 0\n</code></pre>\n<h2 id=\"蛇类\"><a href=\"#蛇类\" class=\"headerlink\" title=\"蛇类\"></a>蛇类</h2><pre><code class=\"python\"># 蛇\nclass Snake():\n    def __init__(self, snake_color, snake_head_color, x, y, lattice_wh):\n        self.color = snake_color\n        self.head_color = snake_head_color\n        # 左上顶点坐标\n        self.pos = (x, y)\n        self.lattice_wh = lattice_wh\n          # 绘制蛇体\n        self.rect = pygame.rect.Rect(x, y, self.lattice_wh, self.lattice_wh)\n        # 左上顶点坐标变化\n        self.pos_change = &#123;\n            # 上移\n            1:(0, -self.lattice_wh),\n            # 下移\n            2:(0, self.lattice_wh),\n            # 左移\n            3:(-self.lattice_wh, 0),\n            # 右移\n            4:(self.lattice_wh, 0)\n        &#125;\n    \n    def move(self, direction):\n        self.rect.x += self.pos_change[direction][0]\n        self.rect.y += self.pos_change[direction][1]\n\n    def forecast(self, direction):\n        return (self.rect.x+self.pos_change[direction][0], self.rect.y+self.pos_change[direction][1])\n</code></pre>\n<h2 id=\"食物类\"><a href=\"#食物类\" class=\"headerlink\" title=\"食物类\"></a>食物类</h2><pre><code class=\"python\"># 食物\nclass Food():\n    def __init__(self, food_color, screen, lattice_wh, x, y):\n        self.screen = screen\n        self.color = food_color\n        self.lattice_wh = lattice_wh\n        # 半径\n        self.radius = lattice_wh/2\n        self.x, self.y = x, y\n\n    def draw(self):\n        # 圆心\n        pos = (self.x+self.lattice_wh/2, self.y+self.lattice_wh/2)\n        # 绘制食物\n        pygame.draw.circle(self.screen, self.color, pos, self.radius, int(self.radius))\n</code></pre>\n<h2 id=\"初始状态\"><a href=\"#初始状态\" class=\"headerlink\" title=\"初始状态\"></a>初始状态</h2><pre><code class=\"python\"># 贪吃蛇\nsnakes = list()\nsnakes.append(Snake(snake_color, snake_head_color, lattice_wh, 24*lattice_wh, lattice_wh))\nsnakes.append(Snake(snake_color, snake_head_color, 0, 24*lattice_wh, lattice_wh))\n\n# 食物\nfood = create_food(food_color, screen, lattice_wh, snakes)\n\n# 游戏状态\ngame_stats = [game_over, direction, num, food]\n</code></pre>\n<h2 id=\"生成食物\"><a href=\"#生成食物\" class=\"headerlink\" title=\"生成食物\"></a>生成食物</h2><pre><code class=\"python\"># 生成食物\ndef create_food(food_color, screen, lattice_wh, snakes):\n    # 食物是否生成成功\n    create_success = 0\n    # 食物位置坐标\n    food_x, food_y = 0, 0\n    while not create_success:\n        food_x, food_y = randint(0, 24), randint(0, 24)\n        food_x *= lattice_wh\n        food_y *= lattice_wh\n        # 检查食物位置是否与贪吃蛇位置重合\n        for snake in snakes:\n            if (food_x, food_y) != (snake.rect.x, snake.rect.y):\n                create_success = 1\n                break\n    # 在指定位置生成食物\n    food = Food(food_color, screen, lattice_wh, food_x, food_y)\n    return food\n</code></pre>\n<h2 id=\"响应键鼠\"><a href=\"#响应键鼠\" class=\"headerlink\" title=\"响应键鼠\"></a>响应键鼠</h2><pre><code class=\"python\"># 响应键鼠\ndef check_events(game_stats):\n    for event in pygame.event.get():\n        # 退出游戏\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        # 控制移动方向，注意不能直接反向移动\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_UP and game_stats[1] != 2:\n                game_stats[1] = 1\n            elif event.key == pygame.K_DOWN and game_stats[1] != 1:\n                game_stats[1] = 2\n            elif event.key == pygame.K_LEFT and game_stats[1] != 4:\n                game_stats[1] = 3\n            elif event.key == pygame.K_RIGHT and game_stats[1] != 3:\n                game_stats[1] = 4\n            else:\n                game_stats[1] = game_stats[1]\n</code></pre>\n<h2 id=\"更新屏幕\"><a href=\"#更新屏幕\" class=\"headerlink\" title=\"更新屏幕\"></a>更新屏幕</h2><pre><code class=\"python\"># 更新屏幕\ndef update(screen, lattice_wh, snakes, game_stats):\n    screen.fill((255, 255, 255))\n    # 绘制蛇头\n    pygame.draw.rect(screen, snakes[0].head_color, snakes[0].rect)\n    # 绘制蛇身\n    for i in range(1, len(snakes)):\n        pygame.draw.rect(screen, snakes[i].color, snakes[i].rect)\n    # 绘制横线\n    for i in range(25):\n        pygame.draw.line(screen, (105, 105, 105), (0, lattice_wh*i), (500, lattice_wh*i))\n    # 绘制竖线\n    for i in range(25):\n        pygame.draw.line(screen, (105, 105, 105), (lattice_wh*i, 0), (lattice_wh*i, 500))\n    # 绘制食物\n    game_stats[3].draw()\n    # 更新屏幕\n    pygame.display.flip()\n</code></pre>\n<h2 id=\"移动进食\"><a href=\"#移动进食\" class=\"headerlink\" title=\"移动进食\"></a>移动进食</h2><pre><code class=\"python\"># 移动进食\ndef going(screen, game_stats, snakes, snake_head_color, snake_color, food_color, lattice_wh):\n    if not game_stats[1]:\n        return\n    # 蛇头下一前进位置\n    (x, y) = snakes[0].forecast(game_stats[1])\n    # 检查是否触碰边界\n    if x == -lattice_wh or x == 25*lattice_wh or y == -lattice_wh or y == 25*lattice_wh:\n        game_stats[0] = 1\n        return\n    # 检查是否触碰食物\n    if (x, y) == (game_stats[3].x, game_stats[3].y):\n        # 更新蛇头\n        new_head = Snake(snake_color, snake_head_color, x, y, lattice_wh)\n        snakes.insert(0, new_head)\n        # 更新分数\n        game_stats[2] += 1\n        # 重新生成食物\n        game_stats[3] = create_food(food_color, screen, lattice_wh, snakes)\n        return\n    # 检查是否触碰蛇身\n    for snake in snakes:\n        if (x, y) == (snake.rect.x, snake.rect.y):\n            game_stats[0] = 1\n            return\n    # 更新所有蛇身位置\n    for i in range(len(snakes)-1, 0, -1):\n        snakes[i].rect.x = snakes[i-1].rect.x\n        snakes[i].rect.y = snakes[i-1].rect.y\n    # 更新蛇头位置\n    snakes[0].move(game_stats[1])\n</code></pre>\n<h2 id=\"游戏入口\"><a href=\"#游戏入口\" class=\"headerlink\" title=\"游戏入口\"></a>游戏入口</h2><pre><code class=\"python\"># 游戏入口\nwhile not game_stats[0]:\n    update(screen, lattice_wh, snakes, game_stats)\n    check_events(game_stats)\n    going(screen, game_stats, snakes, snake_head_color, snake_color, food_color, lattice_wh)\n    FPSCLOCK.tick(FPS * level ** num if FPS * level ** num &lt; 60 else 60)\n</code></pre>\n<h2 id=\"snake-py\"><a href=\"#snake-py\" class=\"headerlink\" title=\"snake.py\"></a>snake.py</h2><pre><code class=\"python\">import pygame\n\n# 蛇\nclass Snake():\n    def __init__(self, snake_color, snake_head_color, x, y, lattice_wh):\n        self.color = snake_color\n        self.head_color = snake_head_color\n        # 左上顶点坐标\n        self.pos = (x, y)\n        self.lattice_wh = lattice_wh\n        # 绘制蛇体\n        self.rect = pygame.rect.Rect(x, y, self.lattice_wh, self.lattice_wh)\n        # 左上顶点坐标变化\n        self.pos_change = &#123;\n            # 上移\n            1:(0, -self.lattice_wh),\n            # 下移\n            2:(0, self.lattice_wh),\n            # 左移\n            3:(-self.lattice_wh, 0),\n            # 右移\n            4:(self.lattice_wh, 0)\n        &#125;\n\n    # 移动\n    def move(self, direction):\n        self.rect.x += self.pos_change[direction][0]\n        self.rect.y += self.pos_change[direction][1]\n\n    # 下一前进位置\n    def forecast(self, direction):\n        return (self.rect.x+self.pos_change[direction][0], self.rect.y+self.pos_change[direction][1])\n</code></pre>\n<h2 id=\"food-py\"><a href=\"#food-py\" class=\"headerlink\" title=\"food.py\"></a>food.py</h2><pre><code class=\"python\">import pygame\n\n# 食物\nclass Food():\n    def __init__(self, food_color, screen, lattice_wh, x, y):\n        self.screen = screen\n        self.color = food_color\n        self.lattice_wh = lattice_wh\n        # 半径\n        self.radius = lattice_wh/2\n        self.x, self.y = x, y\n\n    def draw(self):\n        # 圆心\n        pos = (self.x+self.lattice_wh/2, self.y+self.lattice_wh/2)\n        # 绘制食物\n        pygame.draw.circle(self.screen, self.color, pos, self.radius, int(self.radius))\n</code></pre>\n<h2 id=\"function-py\"><a href=\"#function-py\" class=\"headerlink\" title=\"function.py\"></a>function.py</h2><pre><code class=\"python\">import pygame\nimport sys\nfrom random import randint\nfrom food import Food\nfrom snake import Snake\n\n# 生成食物\ndef create_food(food_color, screen, lattice_wh, snakes):\n    # 食物是否生成成功\n    create_success = 0\n    # 食物位置坐标\n    food_x, food_y = 0, 0\n    while not create_success:\n        food_x, food_y = randint(0, 24), randint(0, 24)\n        food_x *= lattice_wh\n        food_y *= lattice_wh\n        # 检查食物位置是否与贪吃蛇位置重合\n        for snake in snakes:\n            if (food_x, food_y) != (snake.rect.x, snake.rect.y):\n                create_success = 1\n                break\n    # 在指定位置生成食物\n    food = Food(food_color, screen, lattice_wh, food_x, food_y)\n    return food\n\n# 响应事件\ndef check_events(game_stats):\n    for event in pygame.event.get():\n        # 退出游戏\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        # 控制移动方向，注意不能直接反向移动\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_UP and game_stats[1] != 2:\n                game_stats[1] = 1\n            elif event.key == pygame.K_DOWN and game_stats[1] != 1:\n                game_stats[1] = 2\n            elif event.key == pygame.K_LEFT and game_stats[1] != 4:\n                game_stats[1] = 3\n            elif event.key == pygame.K_RIGHT and game_stats[1] != 3:\n                game_stats[1] = 4\n            else:\n                game_stats[1] = game_stats[1]\n\n# 更新屏幕\ndef update(screen, lattice_wh, snakes, game_stats):\n    screen.fill((255, 255, 255))\n    # 绘制蛇头\n    pygame.draw.rect(screen, snakes[0].head_color, snakes[0].rect)\n    # 绘制蛇身\n    for i in range(1, len(snakes)):\n        pygame.draw.rect(screen, snakes[i].color, snakes[i].rect)\n    # 绘制横线\n    for i in range(25):\n        pygame.draw.line(screen, (105, 105, 105), (0, lattice_wh*i), (500, lattice_wh*i))\n    # 绘制竖线\n    for i in range(25):\n        pygame.draw.line(screen, (105, 105, 105), (lattice_wh*i, 0), (lattice_wh*i, 500))\n    # 绘制食物\n    game_stats[3].draw()\n    # 更新屏幕\n    pygame.display.flip()\n\n# 移动进食\ndef going(screen, game_stats, snakes, snake_head_color, snake_color, food_color, lattice_wh):\n    if not game_stats[1]:\n        return\n    # 蛇头下一前进位置\n    (x, y) = snakes[0].forecast(game_stats[1])\n    # 检查是否触碰边界\n    if x == -lattice_wh or x == 25*lattice_wh or y == -lattice_wh or y == 25*lattice_wh:\n        game_stats[0] = 1\n        return\n    # 检查是否触碰食物\n    if (x, y) == (game_stats[3].x, game_stats[3].y):\n        # 更新蛇头\n        new_head = Snake(snake_color, snake_head_color, x, y, lattice_wh)\n        snakes.insert(0, new_head)\n        # 更新分数\n        game_stats[2] += 1\n        # 重新生成食物\n        game_stats[3] = create_food(food_color, screen, lattice_wh, snakes)\n        return\n    # 检查是否触碰蛇身\n    for snake in snakes:\n        if (x, y) == (snake.rect.x, snake.rect.y):\n            game_stats[0] = 1\n            return\n    # 更新所有蛇身位置\n    for i in range(len(snakes)-1, 0, -1):\n        snakes[i].rect.x = snakes[i-1].rect.x\n        snakes[i].rect.y = snakes[i-1].rect.y\n    # 更新蛇头位置\n    snakes[0].move(game_stats[1])\n</code></pre>\n<h2 id=\"main-py\"><a href=\"#main-py\" class=\"headerlink\" title=\"main.py\"></a>main.py</h2><pre><code class=\"python\">import pygame\nfrom function import *\nfrom snake import Snake\n\n# 基本设置\nlattice_wh = 20\nsnake_color = (84, 255, 159)\nsnake_head_color = (123, 104, 238)\nfood_color = (255, 64, 64)\n\n# 绘制屏幕\npygame.init()\nscreen = pygame.display.set_mode((25*lattice_wh, 25*lattice_wh))\npygame.display.set_caption(&quot;贪吃蛇&quot;)\n\n# 帧率，每秒刷新屏幕次数\nFPS = 10\n# 帧率变化系数\nlevel = 1.5\n# 时间对象\nFPSCLOCK = pygame.time.Clock()\n\n# 游戏结束标志\ngame_over = 0\n\n# 前进方向\ndirection = 0\n# 进食数量\nnum = 0\n\n# 贪吃蛇\nsnakes = list()\nsnakes.append(Snake(snake_color, snake_head_color, lattice_wh, 24*lattice_wh, lattice_wh))\nsnakes.append(Snake(snake_color, snake_head_color, 0, 24*lattice_wh, lattice_wh))\n\n# 食物\nfood = create_food(food_color, screen, lattice_wh, snakes)\n\n# 游戏状态\ngame_stats = [game_over, direction, num, food]\n\n# 游戏入口\nwhile not game_stats[0]:\n    update(screen, lattice_wh, snakes, game_stats)\n    check_events(game_stats)\n    going(screen, game_stats, snakes, snake_head_color, snake_color, food_color, lattice_wh)\n    FPSCLOCK.tick(FPS * level ** num if FPS * level ** num &lt; 60 else 60)\n</code></pre>\n<p><strong>敲黑板！！！在控制蛇的移动方向时，易忽略蛇不能直接反向移动这一问题；另外，在生成食物时，要检查食物的位置与蛇的位置是否重合，如果两者位置重合，此时需要生成新的食物。</strong></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210601212016193.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"wolf\"></p>\n",
            "tags": [
                "游戏开发",
                "贪吃蛇-Python语言实现",
                "Python",
                "贪吃蛇",
                "游戏"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/Electrotechnics/%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/",
            "url": "https://www.liangmeng.xyz/Electrotechnics/%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/",
            "title": "集成运算放大器的应用",
            "date_published": "2021-06-01T14:30:00.000Z",
            "content_html": "<h2 id=\"实验目的\"><a href=\"#实验目的\" class=\"headerlink\" title=\"实验目的\"></a>实验目的</h2><p>(1)\t掌握集成运算放大器的基本运算功能及正确使用。<br>(2)\t掌握集成运算放大器常用单元电路的设计和调试方法。<br>(3)\t掌握在仿真实验平台中导入和调试新元件的方法。</p>\n<h2 id=\"实验原理\"><a href=\"#实验原理\" class=\"headerlink\" title=\"实验原理\"></a>实验原理</h2><ol>\n<li><pre><code>实验原理\n</code></pre>\n集成运算放大器是由高开环电压放大倍数的多级直接耦合放大器组成。从工作原理上，集成运算放大器可分为线性应用和非线性应用两个方面。在线性工作区内，其输出电压uo与输入电压ui的线性放大的关系为uo&#x3D;Auo（u+-u-）&#x3D;Auoui，由于集成运算放大器的放大倍数Auo高达104~107，若使uo为有限值，必须引入深度负反馈，使线性区加宽，构成集成运算放大器的线性运算电路。<br>  在工程应用情况下，将集成运放视为理想运放，就是将集成运放的各项技术指标理想化，满足下列条件的运算放大器称为理想运放，即<br>  (1)开环电压放大倍数Auo&#x3D;∞<br>  (2)输入阻抗ri&#x3D;∞<br>  (3)输出阻抗ro&#x3D;0<br>  (4)带宽fBW&#x3D;∞<br>  (5)失调与漂移均为零<br>  理想运放工作在线性区的分析依据是，输入端的虚短（u+&#x3D;u-），输入端的虚断（i+&#x3D;i-&#x3D;0）和输入端的虚地（同相端接地时，u-&#x3D;0）。<br>理想运放工作在非线性区的分析依据是：<br>u+&gt;u-, uo&#x3D;+UOM          u-&gt;u+, uo&#x3D;-UOM</li>\n<li><pre><code>原理图\n</code></pre>\n(1)\t电压跟随器，原理图如下：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601221504560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>(2)\t反向比例运算电路，原理图如下：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601221520539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ol>\n<p>(3)\t同向比例运算电路，原理图如下：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601221537472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>(4)\t减法器的设计，原理图如下：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601221601987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>(5)\t电压比较器，原理图如下：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601221621297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>(6)\t矩形波发生器，原理图如下：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601221637847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"实验过程与原始数据\"><a href=\"#实验过程与原始数据\" class=\"headerlink\" title=\"实验过程与原始数据\"></a>实验过程与原始数据</h2><ol>\n<li><pre><code>电压跟随器\n</code></pre>\n(1)\t实验过程：在画布中插入三个电压源和一个理想运放，将输入电压ui设置为直流1V，然后按照原理图将各元件连接起来。运行电路图并测量输出电压uo。<br>(2)\t原始数据：ui&#x3D;1V<br><img data-src=\"https://img-blog.csdnimg.cn/20210601221710662.png\" alt=\"在这里插入图片描述\"></li>\n<li><pre><code>反向比例运算电路\n</code></pre>\n(1)\t实验过程：在画布中插入三个电压源、一个理想运放和三个电阻，将R1赋为20kΩ，R2赋为16.667kΩ，RF赋为100kΩ，然后按照原理图将各元件连接起来。不断改变输入电压ui，运行电路图并测量输出电压uo。<br>(2)\t原始数据：R1&#x3D;20kΩ，R2&#x3D;16.667kΩ，RF&#x3D;100kΩ<br><img data-src=\"https://img-blog.csdnimg.cn/20210601221728721.png\" alt=\"在这里插入图片描述\"></li>\n<li><pre><code>同向比例运算电路\n</code></pre>\n(1)\t实验过程：在画布中插入三个电压源、一个理想运放和三个电阻，将<br>R1赋为20kΩ，R2赋为16.667kΩ，RF赋为100kΩ，然后按照原理图将各元件连接起来。不断改变输入电压ui，运行电路图并测量输出电压uo。<br>(2)\t原始数据：R1&#x3D;20kΩ，R2&#x3D;16.667kΩ，RF&#x3D;100kΩ<br><img data-src=\"https://img-blog.csdnimg.cn/20210601221744385.png\" alt=\"在这里插入图片描述\"></li>\n<li><pre><code>减法器的设计\n</code></pre>\n(1)\t实验过程：在画布中插入四个电压源、一个理想运放和四个电阻，将R1赋为10kΩ，R2赋为10kΩ，R3赋为100kΩ，RF赋为100kΩ，然后按照原理图将各元件连接起来。不断改变输入电压ui1和ui2，运行电路图并测量输出电压uo。该减法器可实现关系式uo&#x3D;10（ui2-ui1）。<br>(2)\t原始数据：R1&#x3D;10kΩ，R2&#x3D;10kΩ，R3&#x3D;100Kω,RF&#x3D;100kΩ<br><img data-src=\"https://img-blog.csdnimg.cn/2021060122180757.png\" alt=\"在这里插入图片描述\"></li>\n<li><pre><code>电压比较器\n</code></pre>\n(1)\t实验过程：在画布中插入三个电源、一个理想运放和两个电阻，将R1赋为10kΩ，R2赋为10kΩ，ui赋为交流1V，频率为1kHz，然后按照原理图将各元件连接起来。运行电路图，画出输出电压uo的波形和传输特性。<br>(2)\t原始数据：R1&#x3D;10kΩ,R2&#x3D;10kΩ,ui&#x3D;1V，频率为1kHz<br><img data-src=\"https://img-blog.csdnimg.cn/20210601221824228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n<li><pre><code>矩形波发生器\n</code></pre>\n(1)\t实验过程：在画布中插入两个电源、一个理想运放、一个电容和四个电阻，按照原理图将各元件连接起来。不断改变R1、R2、R3、RF的阻值和C的容抗，运行电路并测量输出电压的周期、频率和幅度。<br>(2)\t原始数据：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601221842497.png\" alt=\"在这里插入图片描述\"><h2 id=\"实验结果及分析\"><a href=\"#实验结果及分析\" class=\"headerlink\" title=\"实验结果及分析\"></a>实验结果及分析</h2></li>\n<li><pre><code>电压跟随器\n</code></pre>\n(1)\t实验结果：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601221904795.png\" alt=\"在这里插入图片描述\"><br>(2)\t分析：输出电压uo等于输入电压ui，即电压跟随器不具有放大效应。</li>\n<li><pre><code>反向比例运算电路\n</code></pre>\n(1)\t实验结果：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601221918182.png\" alt=\"在这里插入图片描述\"><br>(2)\t分析：在一定范围内，输出电压和输入电压满足uo&#x3D;-5ui，即输出电压与输入电压成正比，且其相位相反。当ui超过某一定值时，uo不再增大。</li>\n<li><pre><code>同向比例运算电路\n</code></pre>\n(1)\t实验结果：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601221938255.png\" alt=\"在这里插入图片描述\"><br>(2)\t分析：在一定范围内，输出电压与输入电压满足uo&#x3D;6ui，即输出电压与输入电压成正比，且其相位相同。当ui超过一定值时，uo不再增大。</li>\n<li><pre><code>减法器的设计\n</code></pre>\n(1)\t实验结果：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601221953204.png\" alt=\"在这里插入图片描述\"><br>(2)\t分析：在一定范围内，输出电压与输入电压满足uo&#x3D;10（ui2-ui1），即输出电压与输入电压的差值成正比。当差值超过一定值时，uo不再增大。</li>\n<li><pre><code>电压比较器\n</code></pre>\n(1)\t实验结果：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601222004269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/20210601222009349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n<li><pre><code>矩形波发生器\n</code></pre>\n(1)\t实验结果<br><img data-src=\"https://img-blog.csdnimg.cn/20210601222021793.png\" alt=\"在这里插入图片描述\"><h2 id=\"思考题\"><a href=\"#思考题\" class=\"headerlink\" title=\"思考题\"></a>思考题</h2>(1)\t不能。因为输出电压的幅值受到供能直流电源电压的限制，即输出电压的最大值不超过供能直流电源的电压。<br>(2)\t可将两个二极管串联在运放的正、负电源电路中，如果正接负、负接正，则二极管不导通，运放不工作，从而保护运放。电路图如下：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601222039316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><h2 id=\"实验体会与建议\"><a href=\"#实验体会与建议\" class=\"headerlink\" title=\"实验体会与建议\"></a>实验体会与建议</h2></li>\n<li><pre><code>体会：在本次实验中我掌握了多种集成运算放大电路的原理和常用单元电路的设计和调试方法，且能够利用仿真实验平台分析输出电压的波形和传输特性。另外，通过这次实验，我对集成运算放大电路的理论分析更加清晰准确，进一步提高了我对电路各项参数进行理论计算的能力。\n</code></pre>\n</li>\n<li><pre><code>本次实验难度中等偏易，且其对电路分析的能力要求不够高，可以适当提升实验难度。\n</code></pre>\n</li>\n</ol>\n<p><strong>敲黑板！！！</strong></p>\n<p><strong>叠加定理与戴维南定理&#x2F;RLC串联谐振电路&#x2F;单管交流电压放大电路&#x2F;集成放大器的应用完整实验报告</strong><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9LaXNzTW9vbl8vMTkzMjI4OTY=\">https://download.csdn.net/download/KissMoon_&#x2F;19322896</span></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210601222244974.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "电工与电子技术",
                "集成运算放大器的应用",
                "实验",
                "电工与电子技术"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/Electrotechnics/%E5%8D%95%E7%AE%A1%E4%BA%A4%E6%B5%81%E7%94%B5%E5%8E%8B%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF/",
            "url": "https://www.liangmeng.xyz/Electrotechnics/%E5%8D%95%E7%AE%A1%E4%BA%A4%E6%B5%81%E7%94%B5%E5%8E%8B%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF/",
            "title": "单管交流电压放大电路",
            "date_published": "2021-06-01T14:29:00.000Z",
            "content_html": "<h2 id=\"实验目的\"><a href=\"#实验目的\" class=\"headerlink\" title=\"实验目的\"></a>实验目的</h2><p>(1)\t掌握晶体管放大电路静态工作点的调试方法。<br>(2)\t了解静态工作点的改变对放大电路性能的影响。<br>(3)\t了解饱和失真和截止失真对放大电路输出电压波形的影响。<br>(4)\t进一步熟悉仿真实验平台的各种基本操作。</p>\n<h2 id=\"实验原理\"><a href=\"#实验原理\" class=\"headerlink\" title=\"实验原理\"></a>实验原理</h2><p>(1)\t实验原理：单管交流电压放大电路的最典型电路是共发射极分压偏置式交流电压放大电路，原理图如下。在原理图中，晶体管为非线性元件，要使放大器不产生非线性失真，就必须建立一个合适的静态工作点，使晶体管工作在放大区。若Q点过低（IB小，则IC小，UCE大），晶体管进入截止区，产生截止失真；Q点过高（IB、IC大，UCE小），晶体管将进入饱和区，产生饱和失真。调节基极电阻RP即可调整静态工作点。电压放大倍数为<br><img data-src=\"https://img-blog.csdnimg.cn/20210601220449802.png\" alt=\"在这里插入图片描述\"><br>(2)\t原理图：<br><img data-src=\"https://img-blog.csdnimg.cn/2021060122051847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"实验过程与原始数据\"><a href=\"#实验过程与原始数据\" class=\"headerlink\" title=\"实验过程与原始数据\"></a>实验过程与原始数据</h2><ol>\n<li><pre><code>调整静态工作点\n</code></pre>\n(1)\t实验过程：先根据UCE&#x3D;1&#x2F;2VCC计算出电阻RP阻值的大致范围，然后将电阻RP进行赋值，运行电路图，不断对电阻RP的阻值进行微小调整，直至出现符合要求的静态工作点。<br>(2)\t原始数据：<br>RB1&#x3D;20kΩ，RB2&#x3D;20kΩ，RC&#x3D;2.4kΩ，RE&#x3D;1kΩ，C1&#x3D;10μF，C2&#x3D;10μF，CE&#x3D;47μF，VCC&#x3D;12V，Ui&#x3D;10mV（有效值），频率f&#x3D;1kHz<br><img data-src=\"https://img-blog.csdnimg.cn/20210601220558523.png\" alt=\"在这里插入图片描述\"></li>\n<li><pre><code>测量电压放大倍数\n</code></pre>\n(1)\t实验过程：当静态工作点测量完毕之后，保持静态工作点不变，接通信号源。在画布中插入一个电阻RL，开始时RL无需接入电路，即RL&#x3D;∞，运行电路图，测量UO并计算Au；然后将RL接入电路，其阻值分别赋为10kΩ和1k欧姆，重复上述过程。<br>(2)\t原始数据：<br>RB1&#x3D;20kΩ，RB2&#x3D;20kΩ，RC&#x3D;2.4kΩ，RE&#x3D;1kΩ，RP&#x3D;44.67kΩ，C1&#x3D;10μF，C2&#x3D;10μF，CE&#x3D;47μF，VCC&#x3D;12V，Ui&#x3D;10mV（幅值），频率f&#x3D;1kHz<br><img data-src=\"https://img-blog.csdnimg.cn/2021060122062057.png\" alt=\"在这里插入图片描述\"></li>\n<li><pre><code>观测静态工作点对输出电压波形的影响\n</code></pre>\n(1)\t实验过程：<br>①\t最佳静态工作点的情况：调节RP，使静态工作点在最佳位置时，观察输出电压波形；然后断开信号源，测量UBE、UCE、VB的电压值以及IB、IC的电流值。<br>②\t饱和失真的情况：将RP的阻值逐渐减小，输入信号保持不变，观察输出电压波形，使波形出现饱和失真。然后断开信号源，测量UBE、UCE、VB的电压值以及IB、IC的电流值。<br>③\t输入信号增大的情况：输入信号Ui&#x3D;10mV，频率f&#x3D;1kHz，调节RP，使之达到最佳静态工作点。然后逐渐增大Ui，观察输出电压波形，使输出电压波形同时出现饱和失真和截止失真，测量UBE、UCE、VB的电压值以及IB、IC的电流值。<br>(2)\t原始数据：<br>RB1&#x3D;20kΩ，RB2&#x3D;20kΩ，RC&#x3D;2.4kΩ，RE&#x3D;1kΩ，C1&#x3D;10μF，C2&#x3D;10μF，CE&#x3D;47μF，VCC&#x3D;12V</li>\n</ol>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210601220741694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>四、实验结果及分析<br>1.\t调整静态工作点<br>(1)\t实验结果：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601220810184.png\" alt=\"在这里插入图片描述\"><br>2.\t测量电压放大倍数<br>(1)\t实验结果：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601220830736.png\" alt=\"在这里插入图片描述\"><br>(2)\t分析：电压放大倍数Au随着负载阻值RL的减小而减小。<br><img data-src=\"https://img-blog.csdnimg.cn/20210601220842469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3.\t观测静态工作点对输出电压波形的影响<br>(1)\t实验结果：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601220908135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>(2)\t分析：输入信号合适时，如果静态工作点过高，会出现饱和失真，如果静态工作点过低，会出现截止失真；静态工作点合适时，如果输入信号的幅值过大，则会导致电路同时出现饱和失真和截止失真。</p>\n<h2 id=\"思考题\"><a href=\"#思考题\" class=\"headerlink\" title=\"思考题\"></a>思考题</h2><p>(1)\t晶体管的静态工作点不合适。Q点过低时会导致截止失真，Q点过高时会导致饱和失真。可以通过调整RB的阻值来获得最佳静态工作点。<br>(2)\t增大负载RL的阻值。</p>\n<h2 id=\"实验体会与建议\"><a href=\"#实验体会与建议\" class=\"headerlink\" title=\"实验体会与建议\"></a>实验体会与建议</h2><p>(1)\t体会：在本次实验中，我学会了如何寻找放大电路的最佳静态工作点，并测量和计算最佳静态工作点时电路的各项参数；另外，我还学会了测量并分析电压放大倍数随着负载阻值的改变时产生的变化情况；最后，我还进一步理解了产生饱和失真和截止失真的条件以及两种失真对电路输出电压波形的影响。本次实验是对放大电路的综合考量，极大地增强了我对放大电路的原理及原理图、失真产生条件、输出电压特性、电压电流放大倍数等方面的理解。<br>(2)\t建议：在本次实验中，一些原理和步骤较难理解，而且在操作上不易实现，希望能够在正式实验之前能够对实验过程中可能出现的重点难点问题进行相应的提示和指导。</p>\n<p><strong>敲黑板！！！</strong></p>\n<p><strong>叠加定理与戴维南定理&#x2F;RLC串联谐振电路&#x2F;单管交流电压放大电路&#x2F;集成放大器的应用完整实验报告</strong><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9LaXNzTW9vbl8vMTkzMjI4OTY=\">https://download.csdn.net/download/KissMoon_&#x2F;19322896</span></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210601221106858.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "电工与电子技术",
                "单管交流电压放大电路",
                "实验",
                "电工与电子技术"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/Electrotechnics/RLC%E4%B8%B2%E8%81%94%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/",
            "url": "https://www.liangmeng.xyz/Electrotechnics/RLC%E4%B8%B2%E8%81%94%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/",
            "title": "RLC串联谐振电路",
            "date_published": "2021-06-01T14:27:00.000Z",
            "content_html": "<h2 id=\"实验目的\"><a href=\"#实验目的\" class=\"headerlink\" title=\"实验目的\"></a>实验目的</h2><p>(1)\t通过实验进一步理解RLC串联电路的频率特性；<br>(2)\t了解串联谐振的现象，研究电路参数对串联谐振电路的影响；<br>(3)\t理解串联谐振电路的选频特性及应用，掌握谐振曲线的测量方法；<br>(4)\t学会使用仿真实验平台查看电压和电流在不同频率表下的波形，并且根据波形找到发生串联谐振时的频率。<br>(5)\t学会通过仿真实验平台来分析不同频率、不同阻值情况下电压和电流波形的变化情况。</p>\n<h2 id=\"实验原理\"><a href=\"#实验原理\" class=\"headerlink\" title=\"实验原理\"></a>实验原理</h2><p>(1)RLC串联谐振原理：在RLC串联电路中，当外加角频率为ω的正弦电压U时，电路中的电流为I，即I&#x3D;U&#x2F;(R^’+j(ωL-1&#x2F;ωC) )，式中，R^’&#x3D;R+r，r为线圈电阻。当ωL&#x3D;1&#x2F;ωC时，电路发生串联谐振，谐振频率为f_0&#x3D;1&#x2F;(2π√LC)，\t该式即为产生串联谐振顶点条件。可见，改变L、C或电源频率f都可以实现谐振。本实验通过改变外加电压的频率来使电路达到谐振。<br>(2)原理图如下：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601214801596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"实验过程与原始数据\"><a href=\"#实验过程与原始数据\" class=\"headerlink\" title=\"实验过程与原始数据\"></a>实验过程与原始数据</h2><ol>\n<li><pre><code>验证串联谐振电路\n</code></pre>\n(1)实验过程：在画布中插入一个电阻R、一个电感L、一个电容C、一个电源U，再将电阻赋为51Ω、电感赋为10mH、电容赋为0.022μF、电源赋为交流250mV（幅值）。然后设置仿真频率范围，再查看电阻的电压波形和电流波形在不同频率下的变化情况，找到电压和电流同相位时的所对应的频率，即为该电路的串联谐振频率。之后将电源的频率调整为发生串联谐振时的频率，重新运行电路，测出电压和电流等相关参数，并计算品质因数。<br>(2)原始数据（U &#x3D; 250mV（幅值））：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601214949213.png\" alt=\"在这里插入图片描述\"></li>\n<li><pre><code>测量串联谐振曲线\n</code></pre>\n(1)\t实验过程：先将电阻的阻值赋为100Ω，同时将电源的频率设定为某一特定值，然后运行电路图，测量电压和电流等相关参数，并计算品质因数。重复上述过程。之后再讲电阻的阻值赋为510Ω，再重复上述过程。<br>(2)\t原始数据：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601215137285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/20210601215149575.png\" alt=\"在这里插入图片描述\"></li>\n<li><pre><code>用示波器观察RLC串联谐振电路的波形\n</code></pre>\n(1)\t实验过程：将电源的频率赋为串联谐振频率，然后运行电路图，查看并记录电压和电流的波形。之后更换电源的频率，重复上述过程。<br>(2)\t原始数据：串联谐振频率为10.7kHz，低频为5kHz，高频为20kHz。</li>\n</ol>\n<h2 id=\"实验结果及分析\"><a href=\"#实验结果及分析\" class=\"headerlink\" title=\"实验结果及分析\"></a>实验结果及分析</h2><ol>\n<li><pre><code>验证串联谐振电路\n</code></pre>\n(1)\t实验结果：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601215233796.png\" alt=\"在这里插入图片描述\"><br>(2)\t分析：当电路发生串联谐振时，电容和电感的电压近似相等，此时电路中的电流达到最大值。</li>\n<li><pre><code>测量串联谐振曲线\n</code></pre>\n(1)\t实验结果：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601215310673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/20210601215323478.png\" alt=\"在这里插入图片描述\"><br>(2)\t分析：<br>①无论是电阻的阻值如何变化，电压和电流的波形在不同频率下的变化情况相同，即串联谐振频率的大小与电阻无关，且在发生串联谐振时，电压和电流取得最大值。<br><img data-src=\"https://img-blog.csdnimg.cn/20210601215344226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/20210601215349545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>②电路的品质因数随着电阻的增大而减小。<br><img data-src=\"https://img-blog.csdnimg.cn/20210601215418257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>③Q值越大，通用串联谐振曲线的形状越尖锐，电路的选择性越好。<br><img data-src=\"https://img-blog.csdnimg.cn/20210601215459941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n<li><pre><code>用示波器观察RLC串联谐振电路的波形\n</code></pre>\n实验结果：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601215538222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/2021060121555242.png\" alt=\"在这里插入图片描述\"><h2 id=\"思考题\"><a href=\"#思考题\" class=\"headerlink\" title=\"思考题\"></a>思考题</h2>(1)①电压和电流同相位；<br>②电容和电感的电压大小相等；<br>③电路中电压和电流达到最大值。<h2 id=\"实验体会与建议\"><a href=\"#实验体会与建议\" class=\"headerlink\" title=\"实验体会与建议\"></a>实验体会与建议</h2>(1)\t体会：通过这次实验，我学会了如何使用仿真实验平台来查看电压和电流在不同频率下的波形并根据波形找到串联谐振频率，还掌握了通过仿真实验平台来分析不同频率、不通过阻值情况下电压和电流的波形变化情况。而且，这次实验使我对串联谐振的原理以及发生串联谐振时电路具有的特征的理解更加深刻，并熟练掌握了判断电路发生了串联谐振的方法。在此之外，我对串联谐振电路的相关参数的理论计算也变得更加熟练。<br>(2)\t建议：课前尽可能明确课程目标及实验要求，以防课上花费较长时间在修改和统一实验操作上。</li>\n</ol>\n<p><strong>敲黑板！！！</strong></p>\n<p><strong>叠加定理与戴维南定理&#x2F;RLC串联谐振电路&#x2F;单管交流电压放大电路&#x2F;集成放大器的应用完整实验报告</strong><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9LaXNzTW9vbl8vMTkzMjI4OTY=\">https://download.csdn.net/download/KissMoon_&#x2F;19322896</span></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210601215936285.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "电工与电子技术",
                "RLC串联谐振电路",
                "实验",
                "电工与电子技术"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/Electrotechnics/%E5%8F%A0%E5%8A%A0%E5%AE%9A%E7%90%86%E4%B8%8E%E6%88%B4%E7%BB%B4%E5%8D%97%E5%AE%9A%E7%90%86/",
            "url": "https://www.liangmeng.xyz/Electrotechnics/%E5%8F%A0%E5%8A%A0%E5%AE%9A%E7%90%86%E4%B8%8E%E6%88%B4%E7%BB%B4%E5%8D%97%E5%AE%9A%E7%90%86/",
            "title": "叠加定理与戴维南定理",
            "date_published": "2021-06-01T14:26:00.000Z",
            "content_html": "<h2 id=\"实验目的\"><a href=\"#实验目的\" class=\"headerlink\" title=\"实验目的\"></a>实验目的</h2><p>(1)\t学习和掌握常用电工电子仪器仪表使用方法；<br>(2)\t掌握电流、电压参考方向的含义及其应用；<br>(3)\t通过实验验证并加深对叠加定理、戴维南定理的理解；<br>(4)\t了解戴维南定理是化简复杂电路的一种有效方法；<br>(5)\t学习并熟练掌握仿真实验软件的基本操作。</p>\n<h2 id=\"实验原理\"><a href=\"#实验原理\" class=\"headerlink\" title=\"实验原理\"></a>实验原理</h2><p><img data-src=\"https://img-blog.csdnimg.cn/20210601120506702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/20210601120543324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/20210601120601656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"实验过程与原始数据\"><a href=\"#实验过程与原始数据\" class=\"headerlink\" title=\"实验过程与原始数据\"></a>实验过程与原始数据</h2><p>（1）叠加定理<br>实验过程：在画布中插入一个电压源US，一个电流源IS，两个电阻R1和R2；将US的电压值置为10V，IS的电流值置为20mA，R1的阻值置为220Ω，R2的阻值置为100Ω；用导线将各元件连接起来，然后接地。<br>1)\t当US，IS共同作用时，直接运行电路图，然后测量各支路电流和电阻元件两端的电压值。<br>2)\t当电压源US单独作用时，保持电压源US的电压值不变，将电流源IS的电流值置为0，然后运行电路图，再测量各支路电流和电阻元件两端的电压值。<br>3)\t当电流源IS单独作用时，将电流源IS的电流值恢复为20mA，电压源US的电压值置为0，然后运行电路图，再测量各支路电流和电阻元件两端的电压值。<br>初始数据：电压源US&#x3D;10V，直流电流源IS&#x3D;20mA，电阻R1&#x3D;220Ω，R2&#x3D;100Ω<br>理论值计算结果如下（V&#x2F;mA）：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601120718798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>（2）戴维南定理<br>实验过程：在画布中插入两个电压源US和UOC，一个电流源IS，六个电阻R1、R2、R3、RS、RL1、RL2；将US的电压值置为10V，IS的电流值置为20mA，R1的阻值置为510Ω，R2的阻值置为220Ω，R3的阻值置为100Ω；用导线将元件US、IS、R1、R2、R3、RL1和UOC、RS和RL2分别连接，然后各自接地；<br>1)\t测量有源一端口网络的等效电路参数：将RL1与ab端断开，然后运行电路图，测量出ab端开路电压，将电压源UOC的电压值置为该开路电压的值。在画布中插入一个电压源UO，将其电压值置为10V，并用导线将其与ab两端连接起来，然后运行电路图，测量出端口电流IO，计算出等效内阻，将电阻RS的阻值置为该等效内阻。<br>2)\t测量有缘一端口网络的外特性：用将RL与ab端连接起来，然后多次调节RL1和RL2的阻值，该过程需保证两者阻值相等，然后运行电路图，测量出通过RL1和RL2的电流及RL1和RL2两端电压。<br>初始数据：US&#x3D;10V，IS&#x3D;20mA，R1&#x3D;510Ω，R2&#x3D;220Ω，R3&#x3D;100Ω，RL是0~10kΩ的可调电阻<br>理论值计算结果及初始设定测量值如下（V&#x2F;mA）：<br>1.\t线性含源一端口电阻网络等效电路参数测试<br><img data-src=\"https://img-blog.csdnimg.cn/20210601120750414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>2.\t含源一端口网络及等效电路外特性测试<br><img data-src=\"https://img-blog.csdnimg.cn/20210601120820376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"实验结果及分析\"><a href=\"#实验结果及分析\" class=\"headerlink\" title=\"实验结果及分析\"></a>实验结果及分析</h2><p>（1）叠加定理<br>实验结果：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601120908506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>分析：<br>①\t无论是理论值还是测量值，对于电压和电流这两个参数，都满足：US、IS共同作用时产生的响应等于US和IS单独作用时产生的响应的代数和，即叠加定理成立。<br><img data-src=\"https://img-blog.csdnimg.cn/20210601120923341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>②\t无论是US、IS共同作用，还是US和IS单独作用，对于表中任一参数，测量值与理论值近似相等，验证了叠加定理用于理论计算的正确性。<br>（2）戴维南定理<br>1）线性含源一端口电阻网络等效电路参数测试<br>实验结果：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601120944365.png\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/20210601121011979.png\" alt=\"在这里插入图片描述\"><br>分析：等效电路端口电压的测量值与等效电路开路电压计算值相等，且采用两种不同的电阻测量方法时，等效电路等效内阻的测量值都与等效电路等效内阻计算值相等，验证了戴维南定理的正确性。<br>2）含源一端口网络及等效电路外特性测试<br>实验结果：<br><img data-src=\"https://img-blog.csdnimg.cn/20210601121033779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>分析：<br>①\t当外电路电阻减小时，外电路电流增大，而端口电压减小，即该等效电路与外电路满足闭合电路欧姆定律。<br><img data-src=\"https://img-blog.csdnimg.cn/20210601121045279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>②\t无论外电路电阻如何变化，外电路电流及端口电压的测量值始终与理论值相等，说明即使外电路发生变化，戴维南定理也始终成立。</p>\n<h2 id=\"思考题\"><a href=\"#思考题\" class=\"headerlink\" title=\"思考题\"></a>思考题</h2><p>(1)\tUS、IS共同作用时的功率为P1 &#x3D; U1×I1 &#x3D; （-5.500×25.000）J &#x3D; -137.500J<br>                         P2 &#x3D; U2×I2 &#x3D; （4.500×45.000）J &#x3D; 202.500J<br>US单独作用时的功率为P，1 &#x3D; U，1×I，1 &#x3D; （-6.875×31.250）J &#x3D; -214.844J<br>                       \tP，2 &#x3D; U，2×I，2 &#x3D; （3.125×31.250）J &#x3D; 97.656J<br>IS单独作用时的功率为P，，1 &#x3D; U，，1×I，，1 &#x3D; （1.375×-6.250）J &#x3D; -8.594J<br>                        P，，2 &#x3D; U，，2×I，，2 &#x3D; （1.375×13.750）J &#x3D; 18.906J<br>易得P，1 + P，，1 ≠ P1，P，2 + P，，2 ≠ P2<br>则电阻上的功率不符合叠加定理</p>\n<h2 id=\"实验体会与建议\"><a href=\"#实验体会与建议\" class=\"headerlink\" title=\"实验体会与建议\"></a>实验体会与建议</h2><ol>\n<li><pre><code>体会：①实验中，通过使用仿真实验平台对叠加定理和戴维南定理进行实验验证，我已经掌握了运用该平台模拟电路实验的基本操作，并且对两个定理的原理理解更加深刻，能够熟练运用相关原理来解决电路问题。②通过对思考题的分析解答，认识到了电阻的功率不满足叠加定理，避免了错误使用叠加定理的情况③提高了分析问题的全面性和逻辑思考的缜密性，同时也增强了我的耐心及专注度。\n</code></pre>\n</li>\n<li><pre><code>建议：①指导书及实验报告中有些说法较难理解，希望能够用一种更为通俗易懂的方式表达操作要求。②鉴于仿真实验平台的语言是英语，且学生对元件的英语名称不够熟悉，在平台中寻找所需元件或者其等效元件时较为困难，建议在实验要求中给出所需元件或其等效元件仿真实验平台中英文名称。\n</code></pre>\n</li>\n</ol>\n<p><strong>敲黑板！！！</strong></p>\n<p><strong>叠加定理与戴维南定理&#x2F;RLC串联谐振电路&#x2F;单管交流电压放大电路&#x2F;集成放大器的应用完整实验报告</strong><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9LaXNzTW9vbl8vMTkzMjI4OTY=\">https://download.csdn.net/download/KissMoon_&#x2F;19322896</span></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210601220105288.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "电工与电子技术",
                "叠加定理与戴维南定理",
                "实验",
                "电工与电子技术"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/GameDevelopment/%E4%BA%95%E5%AD%97%E6%A3%8B-Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/",
            "url": "https://www.liangmeng.xyz/GameDevelopment/%E4%BA%95%E5%AD%97%E6%A3%8B-Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/",
            "title": "井字棋-Python语言实现",
            "date_published": "2021-06-01T03:55:00.000Z",
            "content_html": "<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>井字棋，英文名叫Tic-Tac-Toe，是一种在3<em>3格子上进行的连珠游戏，由于棋盘一般不画边框，格线排成井字故得名。（</em><em><del>直接百度照抄哈哈哈</del></em>* ）</p>\n<p>另外，百度还给出了一些攻略，反正我是没看懂。。。（**<del>想不到小小井字棋都要勾心斗角</del>** ）</p>\n<p>当然，在这个小游戏中，要让电脑像人一样智能是不太可能的，因为要涉及到很多的技术。因此，为了简化游戏，<strong>电脑下棋的位置将采用随机数的方式来确定</strong>。<br><img data-src=\"https://img-blog.csdnimg.cn/20210601105203318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"绘制屏幕\"><a href=\"#绘制屏幕\" class=\"headerlink\" title=\"绘制屏幕\"></a>绘制屏幕</h2><pre><code class=\"python\">import pygame\nimport sys\n\n# 屏幕大小\nscreen_width, screen_height = 600, 600\n# 格子大小\nlattice_width = screen_width/3 - 1\nlattice_height = screen_height/3 - 1\n\n# 绘制屏幕\npygame.init()\nscreen = pygame.display.set_mode((screen_width, screen_height))\npygame.display.set_caption(&quot;井字棋&quot;)\n</code></pre>\n<h2 id=\"格子类\"><a href=\"#格子类\" class=\"headerlink\" title=\"格子类\"></a>格子类</h2><pre><code class=\"python\"># 格子\nclass Lattice():\n    def __init__(self, rect, screen):\n        self.rect = rect\n        self.screen = screen\n        # 格子状态 -1表示格子被用户占领，1表示格子被电脑占领\n        self.stats = 0\n        # 格子样式\n        self.text_color = (30, 30, 30)\n        self.bg_color = (255, 255, 255)\n        self.font = pygame.font.SysFont(None, 100)\n\n    def draw(self):\n        msg = &quot;&quot;\n        # 用户字符U，电脑字符C\n        if self.stats == -1:\n            msg = &quot;U&quot;\n        elif self.stats == 1:\n            msg = &quot;C&quot;\n        else:\n            msg = &quot;&quot;\n        # 绘制格子\n        if msg:\n            self.msg_image = self.font.render(msg, True, self.text_color, self.bg_color)\n            self.msg_rect = self.msg_image.get_rect()\n            self.msg_rect.center = self.rect.center\n            self.screen.blit(self.msg_image, self.msg_rect)\n</code></pre>\n<h2 id=\"九宫格\"><a href=\"#九宫格\" class=\"headerlink\" title=\"九宫格\"></a>九宫格</h2><pre><code class=\"python\"># 存储九宫格的内容\nrects = [0] * 9\n# 存储每个格子左上顶点的坐标\nrect_wh = [(1, 1), (lattice_width+3, 1), (lattice_width*2+5, 1),\n           (1, lattice_height+3), (lattice_width+3, lattice_height+3), (lattice_width*2+5, lattice_height+3),\n           (1, lattice_height*2+5), (lattice_width+3, lattice_height*2+5), (lattice_width*2+5, lattice_height*2+5)\n]\n\n# 绘制九宫格\nfor i in range(len(rects)):\n    rects[i] = pygame.rect.Rect(*rect_wh[i], lattice_width, lattice_height)\n    rects[i] = Lattice(rects[i], screen)\n</code></pre>\n<p><strong>说明：屏幕的原点位于左上角，x轴横向延伸，y轴纵向延伸。</strong><br><img data-src=\"https://img-blog.csdnimg.cn/20210601111515926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><strong>说明：绘制格子时涉及到参数的封装与解封装。</strong><br><img data-src=\"https://img-blog.csdnimg.cn/20210601113848983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"弹窗类\"><a href=\"#弹窗类\" class=\"headerlink\" title=\"弹窗类\"></a>弹窗类</h2><pre><code class=\"python\"># 弹窗\nclass Popup():\n    def __init__(self, screen, message):\n        self.msg = message\n        self.screen = screen\n        self.bg_color = (0, 0, 0)\n        self.text_color = (230, 230, 230)\n        self.font = pygame.font.SysFont(None, 48)\n        self.msg_image = self.font.render(self.msg, True, self.text_color, self.bg_color)\n        self.msg_rect = self.msg_image.get_rect()\n        self.screen_rect = self.screen.get_rect()\n        self.msg_rect.centerx = self.screen_rect.centerx\n        self.msg_rect.bottom = self.screen_rect.bottom\n        self.screen.blit(self.msg_image, self.msg_rect)\n</code></pre>\n<h2 id=\"更新屏幕\"><a href=\"#更新屏幕\" class=\"headerlink\" title=\"更新屏幕\"></a>更新屏幕</h2><pre><code class=\"python\"># 更新屏幕\ndef update(time_sleep = 0, msg = &quot;&quot;):\n    screen.fill((255, 228, 181))\n    for rect in rects:\n        pygame.draw.rect(screen, (255, 255, 255), rect.rect)\n        rect.draw()\n    if msg:\n        Popup(screen, msg)\n    pygame.display.flip()\n    if time_sleep:\n        time.sleep(time_sleep)\n</code></pre>\n<h2 id=\"电脑回合\"><a href=\"#电脑回合\" class=\"headerlink\" title=\"电脑回合\"></a>电脑回合</h2><pre><code class=\"python\"># 电脑回合\ndef computer_round():\n    # 可选序号列表\n    random_num = [i for i in range(len(rects)) if not rects[i].stats]\n    # 没有可选序号\n    if not random_num:\n        update(3, &quot;Draw!&quot;)\n        pygame.quit()\n        sys.exit()\n    rects[random.choice(random_num)].stats = 1\n</code></pre>\n<h2 id=\"判断胜负\"><a href=\"#判断胜负\" class=\"headerlink\" title=\"判断胜负\"></a>判断胜负</h2><pre><code class=\"python\"># 判断胜负\ndef judge_result():\n    global result\n    # 用户序号列表\n    stats_U = [i for i in range(len(rects)) if rects[i].stats == -1]\n    # 电脑序号列表\n    stats_C = [i for i in range(len(rects)) if rects[i].stats == 1]\n    # 胜出条件列表\n    win = [\n        [0, 1, 2], [3, 4, 5], [6, 7, 8],\n        [0, 3, 6], [1, 4, 7], [2, 5, 8],\n        [0, 4, 8], [2, 4, 6]\n    ]\n    # 遍历胜出条件列表，判断哪方胜出\n    for i in win:\n        if i == [j for j in i if j in stats_U]:\n            update(3, &quot;You win!&quot;)\n            pygame.quit()\n            sys.exit()\n        elif i == [j for j in i if j in stats_C]:\n            update(3, &quot;Computer win!&quot;)\n            pygame.quit()\n            sys.exit()\n</code></pre>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210601113408753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"判断先手\"><a href=\"#判断先手\" class=\"headerlink\" title=\"判断先手\"></a>判断先手</h2><pre><code class=\"python\"># 判断先手\ndef judge_first():\n    # 0表示用户先手，1表示电脑先手\n    x = random.randint(0, 1)\n    if x:\n        update(1, &quot;Computer&#39;s round!&quot;)\n        computer_round()\n    else:\n        update(1, &quot;Your round!&quot;)\n</code></pre>\n<h2 id=\"游戏入口\"><a href=\"#游戏入口\" class=\"headerlink\" title=\"游戏入口\"></a>游戏入口</h2><pre><code class=\"python\"># 游戏入口\njudge_first()\nwhile True:\n    update()\n    # 获取屏幕事件\n    for event in pygame.event.get():\n        # 退出游戏\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        # 点击屏幕\n        elif event.type == pygame.MOUSEBUTTONDOWN:\n            # 获取鼠标坐标\n            mouse_x, mouse_y = pygame.mouse.get_pos()\n            # 鼠标点击位置是否有效\n            position_valid = 0\n            for i in rects:\n                # 鼠标点击有效\n                if not i.stats and i.rect.collidepoint(mouse_x, mouse_y):\n                    position_valid = 1\n                    i.stats = -1\n                    update()\n                    judge_result()\n                    update(1, &quot;Computer&#39;s round!&quot;)\n                    time.sleep(1)\n                    computer_round()\n                    update()\n                    judge_result()\n                    update(1, &quot;Your round!&quot;)\n            # 鼠标点击无效\n            if not position_valid:\n                update(1, &quot;Your choice is invalid!&quot;)\n</code></pre>\n<h2 id=\"运行游戏\"><a href=\"#运行游戏\" class=\"headerlink\" title=\"运行游戏\"></a>运行游戏</h2><p><img data-src=\"https://img-blog.csdnimg.cn/20210601113958746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/20210601114043481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"lattice-py\"><a href=\"#lattice-py\" class=\"headerlink\" title=\"lattice.py\"></a>lattice.py</h2><pre><code class=\"python\">import pygame\n\n# 格子\nclass Lattice():\n    def __init__(self, rect, screen):\n        self.rect = rect\n        self.screen = screen\n        # 格子状态 -1表示格子被用户占领，1表示格子被电脑占领\n        self.stats = 0\n        # 格子样式\n        self.text_color = (30, 30, 30)\n        self.bg_color = (255, 255, 255)\n        self.font = pygame.font.SysFont(None, 100)\n\n    def draw(self):\n        msg = &quot;&quot;\n        # 用户字符U，电脑字符C\n        if self.stats == -1:\n            msg = &quot;U&quot;\n        elif self.stats == 1:\n            msg = &quot;C&quot;\n        else:\n            msg = &quot;&quot;\n        # 绘制格子\n        if msg:\n            self.msg_image = self.font.render(msg, True, self.text_color, self.bg_color)\n            self.msg_rect = self.msg_image.get_rect()\n            self.msg_rect.center = self.rect.center\n            self.screen.blit(self.msg_image, self.msg_rect)\n</code></pre>\n<h2 id=\"popup-py\"><a href=\"#popup-py\" class=\"headerlink\" title=\"popup.py\"></a>popup.py</h2><pre><code class=\"python\">import pygame\n\n# 弹窗\nclass Popup():\n    def __init__(self, screen, message):\n        self.msg = message\n        self.screen = screen\n        self.bg_color = (0, 0, 0)\n        self.text_color = (230, 230, 230)\n        self.font = pygame.font.SysFont(None, 48)\n        self.msg_image = self.font.render(self.msg, True, self.text_color, self.bg_color)\n        self.msg_rect = self.msg_image.get_rect()\n        self.screen_rect = self.screen.get_rect()\n        self.msg_rect.centerx = self.screen_rect.centerx\n        self.msg_rect.bottom = self.screen_rect.bottom\n        self.screen.blit(self.msg_image, self.msg_rect)\n</code></pre>\n<h2 id=\"main-py\"><a href=\"#main-py\" class=\"headerlink\" title=\"main.py\"></a>main.py</h2><pre><code class=\"python\">import pygame\nimport sys\nimport random\nimport time\nfrom lattice import Lattice\nfrom popup import Popup\n\n# 屏幕大小\nscreen_width, screen_height = 600, 600\nlattice_width = screen_width/3 - 1\nlattice_height = screen_height/3 - 1\n\n# 绘制屏幕\npygame.init()\nscreen = pygame.display.set_mode((screen_width, screen_height))\npygame.display.set_caption(&quot;井字棋&quot;)\n\n# 建立九宫格\nrects = [0] * 9\nrect_wh = [(1, 1), (lattice_width+3, 1), (lattice_width*2+5, 1),\n           (1, lattice_height+3), (lattice_width+3, lattice_height+3), (lattice_width*2+5, lattice_height+3),\n           (1, lattice_height*2+5), (lattice_width+3, lattice_height*2+5), (lattice_width*2+5, lattice_height*2+5)\n]\n\n# 绘制九宫格\nfor i in range(len(rects)):\n    rects[i] = pygame.rect.Rect(*rect_wh[i], lattice_width, lattice_height)\n    rects[i] = Lattice(rects[i], screen)\n\n# 更新屏幕\ndef update(time_sleep = 0, msg = &quot;&quot;):\n    screen.fill((255, 228, 181))\n    for rect in rects:\n        pygame.draw.rect(screen, (255, 255, 255), rect.rect)\n        rect.draw()\n    if msg:\n        Popup(screen, msg)\n    pygame.display.flip()\n    if time_sleep:\n        time.sleep(time_sleep)\n\n# 电脑回合\ndef computer_round():\n    # 可选序号列表\n    random_num = [i for i in range(len(rects)) if not rects[i].stats]\n    # 没有可选序号\n    if not random_num:\n        update(3, &quot;Draw!&quot;)\n        pygame.quit()\n        sys.exit()\n    rects[random.choice(random_num)].stats = 1\n\n# 判断胜负\ndef judge_result():\n    global result\n    # 用户序号列表\n    stats_U = [i for i in range(len(rects)) if rects[i].stats == -1]\n    # 电脑序号列表\n    stats_C = [i for i in range(len(rects)) if rects[i].stats == 1]\n    # 胜出条件列表\n    win = [\n        [0, 1, 2], [3, 4, 5], [6, 7, 8],\n        [0, 3, 6], [1, 4, 7], [2, 5, 8],\n        [0, 4, 8], [2, 4, 6]\n    ]\n    # 遍历胜出条件列表，判断哪方胜出\n    for i in win:\n        if i == [j for j in i if j in stats_U]:\n            update(3, &quot;You win!&quot;)\n            pygame.quit()\n            sys.exit()\n        elif i == [j for j in i if j in stats_C]:\n            update(3, &quot;Computer win!&quot;)\n            pygame.quit()\n            sys.exit()\n\n# 判断先手\ndef judge_first():\n    # 0表示用户先手，1表示电脑先手\n    x = random.randint(0, 1)\n    if x:\n        update(1, &quot;Computer&#39;s round!&quot;)\n        computer_round()\n    else:\n        update(1, &quot;Your round!&quot;)\n\n# 游戏入口\njudge_first()\nwhile True:\n    update()\n    # 获取屏幕事件\n    for event in pygame.event.get():\n        # 退出游戏\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        # 点击屏幕\n        elif event.type == pygame.MOUSEBUTTONDOWN:\n            # 获取鼠标坐标\n            mouse_x, mouse_y = pygame.mouse.get_pos()\n            # 鼠标点击位置是否有效\n            position_valid = 0\n            for i in rects:\n                # 鼠标点击有效\n                if not i.stats and i.rect.collidepoint(mouse_x, mouse_y):\n                    position_valid = 1\n                    i.stats = -1\n                    update()\n                    judge_result()\n                    update(1, &quot;Computer&#39;s round!&quot;)\n                    time.sleep(1)\n                    computer_round()\n                    update()\n                    judge_result()\n                    update(1, &quot;Your round!&quot;)\n            # 鼠标点击无效\n            if not position_valid:\n                update(1, &quot;Your choice is invalid!&quot;)\n</code></pre>\n<p><strong>敲黑板！！！祝各位兄弟姐妹六一儿童节快乐！！！</strong></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210601114826921.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "游戏开发",
                "井字棋-Python语言实现",
                "Python",
                "游戏",
                "井字棋"
            ]
        },
        {
            "id": "https://www.liangmeng.xyz/NumericalAnalysis/%E5%9B%9B%E9%98%B6%E9%BE%99%E6%A0%BC-%E5%BA%93%E5%A1%94%E6%96%B9%E6%B3%95/",
            "url": "https://www.liangmeng.xyz/NumericalAnalysis/%E5%9B%9B%E9%98%B6%E9%BE%99%E6%A0%BC-%E5%BA%93%E5%A1%94%E6%96%B9%E6%B3%95/",
            "title": "四阶龙格-库塔方法",
            "date_published": "2021-04-29T14:55:00.000Z",
            "content_html": "<h1 id=\"四阶龙格-库塔（Runge-Kutta）方法\"><a href=\"#四阶龙格-库塔（Runge-Kutta）方法\" class=\"headerlink\" title=\"四阶龙格-库塔（Runge-Kutta）方法\"></a>四阶龙格-库塔（Runge-Kutta）方法</h1><h2 id=\"方法摘要\"><a href=\"#方法摘要\" class=\"headerlink\" title=\"方法摘要\"></a>方法摘要</h2><p><img data-src=\"https://img-blog.csdnimg.cn/20210429224918843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"待求问题\"><a href=\"#待求问题\" class=\"headerlink\" title=\"待求问题\"></a>待求问题</h2><p><img data-src=\"https://img-blog.csdnimg.cn/20210429224949269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/2021042922500855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/2021042922502658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/20210429225040433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"程序流程\"><a href=\"#程序流程\" class=\"headerlink\" title=\"程序流程\"></a>程序流程</h2><p><img data-src=\"https://img-blog.csdnimg.cn/20210429225105122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"程序代码\"><a href=\"#程序代码\" class=\"headerlink\" title=\"程序代码\"></a>程序代码</h2><pre><code class=\"c\">/*Matlab函数\nfunction Result = Runge_Kutta(a, b, alpha, N, f, has_x, has_y)\n    x0 = a;\n    y0 = alpha;\n    h = (b-a)/N;\n    X = zeros(N, 1);\n    Y = zeros(N, 1);\n    if(has_x == 0 &amp;&amp; has_y == 1)\n        for n = 1:N\n            K1 = h*subs(f, symvar(f), y0);\n            K2 = h*subs(f, symvar(f), y0+1/2*K1);\n            K3 = h*subs(f, symvar(f), y0+1/2*K2);\n            K4 = h*subs(f, symvar(f), y0+K3);\n            X(n) = x0+h;\n            Y(n) = y0+(K1+2*K2+2*K3+K4)/6;\n            x0 = X(n);\n            y0 = Y(n);\n        end\n    elseif(has_x == 1 &amp;&amp; has_y == 0)\n        for n = 1:N\n            K1 = h*subs(f, symvar(f), x0);\n            K2 = h*subs(f, symvar(f), x0+h/2);\n            K3 = h*subs(f, symvar(f), x0+h/2);\n            K4 = h*subs(f, symvar(f), x0+h);\n            X(n) = x0+h;\n            Y(n) = y0+(K1+2*K2+2*K3+K4)/6;\n            x0 = X(n);\n            y0 = Y(n);\n        end\n    elseif(has_x == 1 &amp;&amp; has_y == 1)\n        for n = 1:N\n            K1 = h*subs(f, symvar(f), [x0, y0]);\n            K2 = h*subs(f, symvar(f), [x0+h/2, y0+1/2*K1]);\n            K3 = h*subs(f, symvar(f), [x0+h/2, y0+1/2*K2]);\n            K4 = h*subs(f, symvar(f), [x0+h, y0+K3]);\n            X(n) = x0+h;\n            Y(n) = y0+(K1+2*K2+2*K3+K4)/6;\n            x0 = X(n);\n            y0 = Y(n);\n        end\n    else\n        Result = &#39;No independent variables!&#39;;\n        return;\n    end\n    Result = [X,Y];\nend*/\n/*C语言程序\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n\nint n;\ndouble a, b, fa;\n\ndouble f(double x, double y) &#123; return -y * y; &#125;\ndouble f_(double x) &#123; return 1.0 / (x + 1.0); &#125;\n\nint main() &#123;\n    scanf(&quot;%lf%lf%lf%d&quot;, &amp;a, &amp;b, &amp;fa, &amp;n);\n    double x = a, y = fa, h = (b - a) / n;\n    for (int i = 1; i &lt;= n; i++) &#123;\n        double k1 = h * f(x, y);\n        double k2 = h * f(x + h / 2, y + k1 / 2);\n        double k3 = h * f(x + h / 2, y + k2 / 2);\n        double k4 = h * f(x + h, y + k3);\n        x += h;\n        y += 1.0 / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4);\n        printf(&quot;%.2lf\\t%lf\\t%.2lf\\n&quot;, x, y, fabs(f_(x) - y));\n    &#125;\n    return 0;\n&#125;*/\n</code></pre>\n<h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><p><img data-src=\"https://img-blog.csdnimg.cn/20210429225314667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/2021042922532258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/20210429225329845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/20210429225342867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/20210429225353271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/20210429225401789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/20210429225410276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img data-src=\"https://img-blog.csdnimg.cn/20210429225415226.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"Newton-x2F-Gauss-x2F-Lagrange-x2F-Runge-Kutta实验内容-方法指导-Matlab脚本-Matlab函数-Matlab运行报告-C程序-实验报告，一键下载：\"><a href=\"#Newton-x2F-Gauss-x2F-Lagrange-x2F-Runge-Kutta实验内容-方法指导-Matlab脚本-Matlab函数-Matlab运行报告-C程序-实验报告，一键下载：\" class=\"headerlink\" title=\"Newton&#x2F;Gauss&#x2F;Lagrange&#x2F;Runge-Kutta实验内容+方法指导+Matlab脚本+Matlab函数+Matlab运行报告+C程序+实验报告，一键下载：\"></a>Newton&#x2F;Gauss&#x2F;Lagrange&#x2F;Runge-Kutta实验内容+方法指导+Matlab脚本+Matlab函数+Matlab运行报告+C程序+实验报告，一键下载：</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9LaXNzTW9vbl8vMTgyNDQ0MTk=\">https://download.csdn.net/download/KissMoon_&#x2F;18244419</span></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210429225501168.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpc3NNb29uXw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "数值分析原理",
                "四阶龙格-库塔方法",
                "实验",
                "数值分析原理",
                "四阶龙格-库塔法",
                "算法"
            ]
        }
    ]
}